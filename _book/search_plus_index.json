{"./":{"url":"./","title":"简介","keywords":"","body":"ES6 基础入门 以下内容多节选自 阮一峰 的 ES6 博客，本人摘抄了他的精髓，记录成册，与君共享 1. ECMAScript 和 JavaScript 的关系是 ​ 前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。 2. ES6 与 ECMAScript2015 的关系 ​ 2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。 ​ 但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。 ​ 但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。 ​ 标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。 ​ ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。 ​ 因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。 3. 查看 Node.js 默认没有打开的 ES6 实验性语法 // Linux & Mac $ node --v8-options | grep harmony // Windows $ node --v8-options | findstr harmony 4. Babel 转码器 Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。 // 转码前 input.map(item => item + 1); // 转码后 input.map(function (item) { return item + 1; }); 上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。 下面的命令在项目目录中，安装 Babel。 $ npm install --save-dev @babel/core 1. 配置文件 .babelrc Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。 该文件用来设置转码规则和插件，基本格式如下。 presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。 # 最新转码规则 $ npm install --save-dev @babel/preset-env # react 转码规则 $ npm install --save-dev @babel/preset-react 然后，将这些规则加入.babelrc。 { \"presets\": [ \"@babel/env\", \"@babel/preset-react\" ], \"plugins\": [] } 注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。 2. 命令行转码 Babel 提供命令行工具@babel/cli，用于命令行转码。 安装模块 $ npm install --save-dev @babel/cli 基本用法如下： # 转码结果输出到标准输出 $ npx babel example.js # 转码结果写入一个文件 # --out-file 或 -o 参数指定输出文件 $ npx babel example.js --out-file compiled.js # 或者 $ npx babel example.js -o compiled.js # 整个目录转码 # --out-dir 或 -d 参数指定输出目录 $ npx babel src --out-dir lib # 或者 $ npx babel src -d lib # -s 参数生成source map文件 $ npx babel src -d lib -s 3. babel-node @babel/node模块的babel-node命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。 安装模块 $ npm install --save-dev @babel/node 然后，执行babel-node就进入 REPL 环境。 $ npx babel-node > (x => x * 2)(1) 2 babel-node命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。 # es6.js 的代码 # console.log((x => x * 2)(1)); $ npx babel-node es6.js 2 4. babel/register 模块 @babel/register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 Babel 进行转码。 $ npm install --save-dev @babel/register 使用时，必须首先加载@babel/register。 // index.js require('@babel/register'); require('./es6.js') 然后，就不需要手动对index.js转码了。 $ node index.js 2 需要注意的是，@babel/register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。 5. babel API 如果某些代码需要调用 Babel 的 API 进行转码，就要使用@babel/core模块。 // 字符串转码 babel.transform('code();', options); // => { code, map, ast } // 文件转码（异步） babel.transformFile('filename.js', options, function(err, result) { result; // => { code, map, ast } }); // 文件转码（同步） babel.transformFileSync('filename.js', options); // => { code, map, ast } // Babel AST转码 babel.transformFromAst(ast, code, options); // => { code, map, ast } 配置对象options，可以参看官方文档http://babeljs.io/docs/usage/options/。 下面是一个例子。 var es6Code = 'let x = n => n + 1'; var es5Code = require('@babel/core') .transform(es6Code, { presets: ['@babel/env'] }) .code; console.log(es5Code); // '\"use strict\";\\n\\nvar x = function x(n) {\\n return n + 1;\\n};' 上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的 ES6 代码，第二个参数是转换的配置对象。 6. babel/polyfill Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。 安装命令如下: $ npm install --save-dev @babel/polyfill 然后，在脚本头部，加入如下一行代码。 import '@babel/polyfill'; // 或者 require('@babel/polyfill'); Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的definitions.js文件。 7. 浏览器环境 Babel 也可以用于浏览器环境，使用@babel/standalone模块提供的浏览器版本，将其插入网页。 // Your ES6 code 注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。 Babel 提供一个REPL 在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-24 23:53 "},"let-const.html":{"url":"let-const.html","title":"let 和 const 命令","keywords":"","body":"let 和 const 命令 1. let 命令 1.）基本用法 * ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 { let a = 10; var b = 1; } a // ReferenceError: a is not defined. b // 1 for循环的计数器，就很合适使用let命令。 for (let i = 0; i 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 var a = []; for (var i = 0; i 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。 var a = []; for (let i = 0; i 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 for (let i = 0; i 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 2）不存在变量提升 * var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; 3）暂时性死区 * 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 if (true) { // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123 } 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 typeof x; // ReferenceError let x; 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 typeof undeclared_variable // \"undefined\" 有些“死区”比较隐蔽，不太容易发现。 function bar(x = y, y = 2) { return [x, y]; } bar(); // 报错 Uncaught ReferenceError: Cannot access 'y' before initialization 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。 function bar(x = 2, y = x) { return [x, y]; } bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。 // 不报错 var x = x; // 报错 let x = x; // ReferenceError: x is not defined ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 4）不允许重复声明 * let不允许在相同作用域内，重复声明同一个变量。 // 报错 function func() { let a = 10; var a = 1; } // 报错 function func() { let a = 10; let a = 1; } 不能在函数内部重新声明参数。 function func(arg) { let arg; } func() // 报错 function func(arg) { { let arg; } } func() // 不报错 2. 块级作用域 1）为什么需要块级作用域 * ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 内层变量可能会覆盖外层变量。 var tmp = 'hello'; function f() { console.log(tmp); if (false) { var tmp = 'world'; } } f(); // undefined 用来计数的循环变量泄露为全局变量。 var tmp = 'hello'; for (var i = 0; i 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。 { {let insane = 'Hello World'} console.log(insane); // 报错 }; 内层作用域可以定义外层作用域的同名变量。 { let insane = 'Hello'; {let insane = 'World'} }; 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。 // IIFE 写法 (function () { var tmp = ...; ... }()); // 块级作用域写法 { let tmp = ...; ... } 2）块级作用域与函数声明 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 // 情况一 if (true) { function f() {} } // 情况二 try { function f() {} } catch(e) { // ... } 上面两种函数声明，根据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 function f() { console.log('I am outside!'); } (function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f(); }()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。 // ES5 环境 function f() { console.log('I am outside!'); } (function () { function f() { console.log('I am inside!'); } if (false) { } f(); }()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ // 浏览器的 ES6 环境 function f() { console.log('I am outside!'); } (function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f(); }()); // Uncaught TypeError: f is not a function ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。上面的例子实际运行的代码如下。 // 浏览器的 ES6 环境 function f() { console.log('I am outside!'); } (function () { var f = undefined; if (false) { function f() { console.log('I am inside!'); } } f(); }()); // Uncaught TypeError: f is not a function 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 // 块级作用域内部的函数声明语句，建议不要使用 { let a = 'secret'; function f() { return a; } } // 块级作用域内部，优先使用函数表达式 { let a = 'secret'; let f = function () { return a; }; } 另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。 // 第一种写法，报错 if (true) let x = 1; // 第二种写法，不报错 if (true) { let x = 1; } 函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。 // 不报错 'use strict'; if (true) { function f() {} } // 报错 'use strict'; if (true) function f() {} 3. const 命令 1）基本用法 * const声明一个只读的常量。一旦声明，常量的值就不能改变。 const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. const一旦声明变量，就必须立即初始化，不能留到以后赋值。只声明不赋值，就会报错。 const foo; // SyntaxError: Missing initializer in const declaration 除了不可改变值，其他用法和let相似 3）本质 * const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 const foo = {}; // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop // 123 // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: \"foo\" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 const a = []; a.push('Hello'); // 可执行 a.length = 0; // 可执行 a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果真的想将对象冻结，应该使用Object.freeze方法。 const foo = Object.freeze({}); // 常规模式时，下面一行不起作用； // 严格模式时，该行会报错 foo.prop = 123; 将对象彻底冻结的函数。 var constantize = (obj) => { Object.freeze(obj); Object.keys(obj).forEach( (key, i) => { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } }); }; 4. 顶层对象的属性 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 window.a = 1; a // 1 a = 2; window.a // 2 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题： 没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）。 程序员很容易不知不觉地就创建了全局变量（比如打字出错）。 顶层对象的属性是到处可以读写的，这非常不利于模块化编程。 window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性。 另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。 var a = 1; // 如果在 Node 的 REPL 环境，可以写成 global.a // 或者采用通用方法，写成 this.a window.a // 1 let b = 1; window.b // undefined 5. globalThis对象 * JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。 ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"destructuring-assignment.html":{"url":"destructuring-assignment.html","title":"变量的解构赋值","keywords":"","body":"变量的解构赋值 重要知识点 ： 1. 交换变量的值 * let [x,y] = [1,2] [x,y] = [y,x] 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 2. 从函数返回多个值 * 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 // 返回一个数组,数组中取出多个对象 function example() { return [1, 2, 3]; } let [a, b, c] = example(); // 返回一个对象,对象中取出多个对象 function example() { return { foo: 1, bar: 2 }; } let { foo, bar } = example(); 3. 函数参数的定义 * 解构赋值可以方便地将一组参数与变量名对应起来。 // 参数是一组有次序的值 function f([x, y, z]) { ... } f([1, 2, 3]); // 参数是一组无次序的值 function f({x, y, z}) { ... } f({z: 3, y: 2, x: 1}); 4. 提取 JSON 数据 * 可以快速提取 JSON 数据的值。 let jsonData = { id: 42, status: \"OK\", data: [867, 5309] }; let { id, status, data: number } = jsonData; console.log(id, status, number); // 42, \"OK\", [867, 5309] 5. 函数参数的默认值 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。 const fn = function({x='hello',y='world'}={}){ ... } 6. 遍历 Map 结构 * 任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 const map = new Map(); map.set('first', 'hello'); map.set('second', 'world'); for (let [key, value] of map) { console.log(key + \" is \" + value); } // first is hello // second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 // 获取键名 for (let [key] of map) { // ... } // 获取键值 for (let [,value] of map) { // ... } 7. 引入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 const { SourceMapConsumer, SourceNode } = require(\"source-map\"); Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-24 23:53 "},"string-extend.html":{"url":"string-extend.html","title":"字符串的扩展","keywords":"","body":"字符串的扩展 1. 字符串的遍历接口 for (let codePoint of 'foo') { console.log(codePoint) } // \"f\" // \"o\" // \"o\" 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 let text = String.fromCodePoint(0x20BB7); for (let i = 0; i 2. 直接输入 U+2028 和 U+2029 JavaScript 字符串允许直接输入字符，以及输入字符的转义形式（Unicode编码） JavaScript 规定有3个字符，不能在字符串里面直接使用，只能使用转义形式。 U+005C：反斜杠（reverse solidus) U+000D：回车（carriage return） U+000A：换行符（line feed） 3. 模板字符串 * 传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。 $('#result').append( 'There are ' + basket.count + ' ' + 'items in your basket, ' + '' + basket.onSale + ' are on sale!' ); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 $('#result').append(` There are ${basket.count} items in your basket, ${basket.onSale} are on sale! `); 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 let greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 $('#list').html(` first second `); 模板字符串中嵌入变量，需要将变量名写在${}之中。 `User ${user.name} is not authorized to do ${action}.` 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 let x = 1; let y = 2; `${x} + ${y} = ${x + y}` // \"1 + 2 = 3\" `${x} + ${y * 2} = ${x + y * 2}` // \"1 + 4 = 5\" let obj = {x: 1, y: 2}; `${obj.x + obj.y}` // \"3\" 模板字符串之中还能调用函数。 function fn() { return \"Hello World\"; } `foo ${fn()} bar` // foo Hello World bar 模板字符串甚至还能嵌套。 const tmpl = addrs => ` ${addrs.map(addr => ` ${addr.first} ${addr.last} `).join('')} `; 4. 标签模板 它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 alert`hello` // 等同于 alert(['hello']) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 let a = 5; let b = 10; tag`Hello ${ a + b } world ${ a * b }`; // 等同于 tag(['Hello ', ' world ', ''], 15, 50); “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 let message = SaferHTML`${sender} has sent you a message.`; function SaferHTML(templateData) { let s = templateData[0]; for (let i = 1; i /g, \"&gt;\"); // Don't escape special characters in the template. s += templateData[i]; } return s; } 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 let sender = 'alert(\"abc\")'; // 恶意代码 let message = SaferHTML`${sender} has sent you a message.`; message // &lt;script&gt;alert(\"abc\")&lt;/script&gt; has sent you a message. 标签模板的另一个应用，就是多语言转换（国际化处理）。 i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!` // \"欢迎访问xxx，您是第xxxx位访问者！\" Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-25 23:45 "},"string-new-method.html":{"url":"string-new-method.html","title":"字符串的新增方法","keywords":"","body":"字符串的新增方法 1. includes(), startsWith(), endsWith() 传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 let s = 'Hello world!'; s.startsWith('Hello') // true s.endsWith('!') // true s.includes('o') // true 这三个方法都支持第二个参数，表示开始搜索的位置。 let s = 'Hello world!'; s.startsWith('world', 6) // true s.endsWith('Hello', 5) // true s.includes('Hello', 6) // false 使用第二个参数n时 endsWith针对前n个字符 startsWith针对从第n个位置直到字符串结束。 includes针对从第n个位置直到字符串结束。 2. repeat() repeat方法返回一个新字符串，表示将原字符串重复n次。 'x'.repeat(3) // \"xxx\" 'hello'.repeat(2) // \"hellohello\" 'na'.repeat(0) // \"\" 参数如果是小数，会被向下取整。 'na'.repeat(2.9) // \"nana\" 如果repeat的参数是负数或者Infinity，会报错。 'na'.repeat(Infinity) // RangeError 'na'.repeat(-1) // RangeError 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。 'na'.repeat(-0.9) // \"\" 参数NaN等同于 0。 'na'.repeat(NaN) // \"\" 如果repeat的参数是字符串，则会返回空字符串。 'na'.repeat('sdg') // \"\" 3. padStart(), padEnd() ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 'x'.padStart(5, 'ab') // 'ababx' 'x'.padStart(4, 'ab') // 'abax' 'x'.padEnd(5, 'ab') // 'xabab' 'x'.padEnd(4, 'ab') // 'xaba' padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。 'xxx'.padStart(2, 'ab') // 'xxx' 'xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。 'abc'.padStart(10, '0123456789') // '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 'x'.padStart(4) // ' x' 'x'.padEnd(4) // 'x ' padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 '1'.padStart(10, '0') // \"0000000001\" '12'.padStart(10, '0') // \"0000000012\" 另一个用途是提示字符串格式。 '12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\" '09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\" 4. trimStart(), trimEnd() ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。 const s = ' abc '; s.trim() // \"abc\" s.trimStart() // \"abc \" s.trimEnd() // \" abc\" 除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-25 23:51 "},"RegExp-extend.html":{"url":"RegExp-extend.html","title":"正则的扩展","keywords":"","body":"正则的扩展 1. RegExp 构造函数 * 在 ES5 中，RegExp构造函数的参数有两种情况。 第一种情况是，第一个参数是字符串，第二个参数是正则表达式的修饰符（flag）。 var regex = new RegExp('xyz', 'i'); // 等价于 var regex = /xyz/i; 第二种情况是，只有一个参数，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 var regex = new RegExp(/xyz/i); // 等价于 var regex = /xyz/i; 但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。 var regex = new RegExp(/xyz/, 'i'); // Uncaught TypeError: Cannot supply flags when constructing one RegExp from another 在ES6中，第一个参数是正则表示式，第二个参数可以使用修饰符（flag），返回的正则表达式会忽略原有的修饰符，使用第二个参数给的修饰符 new RegExp(/abc/ig, 'i').flags // \"i\" 2. 字符串的正则表达式 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] 3. RegExp.prototype.flags 属性 ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 // ES5 的 source 属性 // 返回正则表达式的正文 /abc/ig.source // \"abc\" // ES6 的 flags 属性 // 返回正则表达式的修饰符 /abc/sigu.flags // 'gi' 4. 具名组匹配 * 正则表达式使用圆括号进行组匹配。使用exec方法，就可以将这三组匹配结果提取出来。 const RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/; const matchObj = RE_DATE.exec('1999-12-31'); const year = matchObj[1]; // 1999 const month = matchObj[2]; // 12 const day = matchObj[3]; // 31 组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。 ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。同时，数字序号（matchObj[1]）依然有效。 const RE_DATE = /(?\\d{4})-(?\\d{2})-(?\\d{2})/; const matchObj = RE_DATE.exec('1999-12-31'); const year = matchObj.groups.year; // 1999 const month = matchObj.groups.month; // 12 const day = matchObj.groups.day; // 31 如果具名组没有匹配，那么对应的groups对象属性会是undefined。 const RE_OPT_A = /^(?a+)?$/; const matchObj = RE_OPT_A.exec(''); matchObj.groups.as // undefined 'as' in matchObj.groups // true 5. 解构赋值和替换 * 有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。 let {groups: {one, two}} = /^(?.*):(?.*)$/u.exec('foo:bar'); one // foo two // bar 字符串替换时，使用$引用具名组。 let re = /(?\\d{4})-(?\\d{2})-(?\\d{2})/u; '2015-01-02'.replace(re, '$/$/$') // '02/01/2015' 上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。 replace方法的第二个参数也可以是函数，该函数的参数序列如下。 '2015-01-02'.replace(re, ( matched, // 整个匹配结果 2015-01-02 capture1, // 第一个组匹配 2015 capture2, // 第二个组匹配 01 capture3, // 第三个组匹配 02 position, // 匹配开始的位置 0 S, // 原字符串 2015-01-02 groups // 具名组构成的一个对象 {year, month, day} ) => { let {day, month, year} = groups; return `${day}/${month}/${year}`; }); 6. 引用 如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k的写法。 const RE_TWICE = /^(?[a-z]+)!\\k$/; RE_TWICE.test('abc!abc') // true RE_TWICE.test('abc!ab') // false 数字引用（\\1）依然有效。 const RE_TWICE = /^(?[a-z]+)!\\1$/; RE_TWICE.test('abc!abc') // true RE_TWICE.test('abc!ab') // false 这两种引用语法还可以同时使用。 const RE_TWICE = /^(?[a-z]+)!\\k!\\1$/; RE_TWICE.test('abc!abc!abc') // true RE_TWICE.test('abc!abc!ab') // false 7. String.prototype.matchAll() * ES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 const string = 'test1test2test3'; // g 修饰符加不加都可以 const regex = /t(e)(st(\\d?))/g; for (const match of string.matchAll(regex)) { console.log(match); } // [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"] // [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"] // [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"] 上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for...of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。 遍历器转为数组是非常简单的，使用...运算符和Array.from()方法就可以了。 // 转为数组方法一 [...string.matchAll(regex)] // 转为数组方法二 Array.from(string.matchAll(regex)) Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-25 23:45 "},"number-extend.html":{"url":"number-extend.html","title":"数值的扩展","keywords":"","body":"数值的扩展 1. 二进制和八进制的写法 ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 0b111110111 === 503 // true 0o767 === 503 // true 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 Number('0b111') // 7 Number('0o10') // 8 2. Number.isFinite(), Number.isNaN() * Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。 如果参数类型不是数值，Number.isFinite一律返回false。 Number.isFinite(15); // true Number.isFinite(0.8); // true Number.isFinite(NaN); // false Number.isFinite(Infinity); // false Number.isFinite(-Infinity); // false Number.isFinite('foo'); // false Number.isFinite('15'); // false Number.isFinite(true); // false Number.isNaN()用来检查一个值是否为NaN。 如果参数类型不是NaN，Number.isNaN()一律返回false。 Number.isNaN(NaN) // true Number.isNaN(15) // false Number.isNaN('15') // false Number.isNaN(true) // false Number.isNaN(9/NaN) // true Number.isNaN('true' / 0) // true Number.isNaN('true' / 'true') // true 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 isFinite(25) // true isFinite(\"25\") // true Number.isFinite(25) // true Number.isFinite(\"25\") // false isNaN(NaN) // true isNaN(\"NaN\") // true Number.isNaN(NaN) // true Number.isNaN(\"NaN\") // false 3. Number.parseInt(), Number,parseFloat() * // ES5的写法 parseInt('12.34') // 12 parseFloat('123.45#') // 123.45 // ES6的写法 Number.parseInt('12.34') // 12 Number.parseFloat('123.45#') // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 Number.parseInt === parseInt // true Number.parseFloat === parseFloat // true 4. Number.isInterger() * Number.isInteger()用来判断一个数值是否为整数。 Number.isInteger(25) // true Number.isInteger(25.1) // false JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。 Number.isInteger(25) // true Number.isInteger(25.0) // true 如果参数不是数值，Number.isInteger返回false。 Number.isInteger() // false Number.isInteger(null) // false Number.isInteger('15') // false Number.isInteger(true) // false 注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。 Number.isInteger(3.0000000000000002) // true 5. Number.EPSILON * ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。 对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。 Number.EPSILON === Math.pow(2, -52) // true Number.EPSILON // 2.220446049250313e-16 Number.EPSILON.toFixed(20) // \"0.00000000000000022204\" Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。 0.1 + 0.2 // 0.30000000000000004 0.1 + 0.2 - 0.3 // 5.551115123125783e-17 5.551115123125783e-17.toFixed(20) // '0.00000000000000005551' 上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。 0.1 + 0.2 === 0.3 // false Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。 5.551115123125783e-17 因此，Number.EPSILON的实质是一个可以接受的最小误差范围。 function withinErrorMargin (left, right) { return Math.abs(left - right) 上面的代码为浮点数运算，部署了一个误差检查函数。 6. Math.trunc() * Math.trunc方法用于去除一个数的小数部分，返回整数部分。 Math.trunc(4.1) // 4 Math.trunc(4.9) // 4 Math.trunc(-4.1) // -4 Math.trunc(-4.9) // -4 Math.trunc(-0.1234) // -0 对于非数值，Math.trunc内部使用Number方法将其先转为数值。 Math.trunc('123.456') // 123 Math.trunc(true) //1 Math.trunc(false) // 0 Math.trunc(null) // 0 对于空值和无法截取整数的值，返回NaN。 Math.trunc(NaN); // NaN Math.trunc('foo'); // NaN Math.trunc('1w'); // NaN Math.trunc(); // NaN Math.trunc(undefined) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 Math.trunc = Math.trunc || function(x) { return x 7. Math.sign() Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 它会返回五种值。 参数为正数，返回+1； 参数为负数，返回-1； 参数为 0，返回0； 参数为-0，返回-0; 其他数值，返回NaN。 如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。 Math.sign('') // 0 Math.sign(true) // +1 Math.sign(false) // 0 Math.sign(null) // 0 Math.sign('9') // +1 Math.sign('foo') // NaN Math.sign() // NaN Math.sign(undefined) // NaN 8. Math.cbrt() Math.cbrt方法用于计算一个数的立方根。 Math.cbrt(-1) // -1 Math.cbrt(0) // 0 Math.cbrt(1) // 1 Math.cbrt(2) // 1.2599210498948734 对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。 Math.cbrt('8') // 2 Math.cbrt('hello') // NaN 9. Math.hypot() Math.hypot方法返回所有参数的平方和的平方根。 如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。 Math.hypot(3, 4); // 5 Math.hypot(3, 4, 5); // 7.0710678118654755 Math.hypot(); // 0 Math.hypot(NaN); // NaN Math.hypot(3, 4, 'foo'); // NaN Math.hypot(3, 4, '5'); // 7.0710678118654755 Math.hypot(-3); // 3 10. 指数运算符 ** ES2016 新增了一个指数运算符（**）。 2 ** 2 // 4 2 ** 3 // 8 这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。 // 相当于 2 ** (3 ** 2) 2 ** 3 ** 2 // 512 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。 let a = 1.5; a **= 2; // 等同于 a = a * a; let b = 4; b **= 3; // 等同于 b = b * b * b; Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-26 23:57 "},"function-extend.html":{"url":"function-extend.html","title":"函数的扩展","keywords":"","body":"函数的扩展 1. 函数参数的默认值 * 1）基本用法 ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 function log(x, y) { y = y || 'World'; console.log(x, y); } log('Hello') // Hello World log('Hello', 'China') // Hello China log('Hello', '') // Hello World 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。 if (typeof y === 'undefined') { y = 'World'; } ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 function log(x, y = 'World') { console.log(x, y); } log('Hello') // Hello World log('Hello', 'China') // Hello China log('Hello', '') // Hello 参数变量是默认声明的，所以不能用let或const再次声明。 function foo(x = 5) { let x = 1; // error } 2）与结构赋值默认值的结合使用 参数默认值可以与解构赋值的默认值，结合起来使用。 function foo({x, y = 5}) { console.log(x, y); } foo({}) // undefined 5 foo({x: 1}) // 1 5 foo({x: 1, y: 2}) // 1 2 foo() // TypeError: Cannot read property 'x' of undefined function fetch(url, { body = '', method = 'GET', headers = {} } = {}) { console.log(method); } fetch('http://example.com') // \"GET\" 上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET 请问下面两种写法有什么差别？ // 写法一 function m1({x = 0, y = 0} = {}) { return [x, y]; } // 写法二 function m2({x, y} = { x: 0, y: 0 }) { return [x, y]; } 上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。 // 函数没有参数的情况 m1() // [0, 0] m2() // [0, 0] // x 和 y 都有值的情况 m1({x: 3, y: 8}) // [3, 8] m2({x: 3, y: 8}) // [3, 8] // x 有值，y 无值的情况 m1({x: 3}) // [3, 0] m2({x: 3}) // [3, undefined] // x 和 y 都无值的情况 m1({}) // [0, 0]; m2({}) // [undefined, undefined] m1({z: 3}) // [0, 0] m2({z: 3}) // [undefined, undefined] 3）参数默认值的位置 通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 // 例一 function f(x = 1, y) { return [x, y]; } f() // [1, undefined] f(2) // [2, undefined]) f(, 1) // 报错 f(undefined, 1) // [1, 1] // 例二 function f(x, y = 5, z) { return [x, y, z]; } f() // [undefined, 5, undefined] f(1) // [1, 5, undefined] f(1, ,2) // 报错 f(1, undefined, 2) // [1, 5, 2] 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 function foo(x = 5, y = 6) { console.log(x, y); } foo(undefined, null) // 5 null 4）函数的length属性 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数 (function (a) {}).length // 1 (function (a = 5) {}).length // 0 (function (a, b, c = 5) {}).length // 2 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。 (function(...args) {}).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 (function (a = 0, b, c) {}).length // 0 (function (a, b = 1, c) {}).length // 1 5）作用域 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 var x = 1; function f(x, y = x) { console.log(y); } f(2) // 2 上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。 let x = 1; function f(y = x) { let x = 2; console.log(y); } f() // 1 上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。 如果此时，全局变量x不存在，就会报错。 function f(y = x) { let x = 2; console.log(y); } f() // ReferenceError: x is not defined 上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。 如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。 let foo = 'outer'; function bar(func = () => foo) { let foo = 'inner'; console.log(func()); } bar(); // outer 6）应用 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 function throwIfMissing() { throw new Error('Missing parameter'); } function foo(mustBeProvided = throwIfMissing()) { return mustBeProvided; } foo() // Error: Missing parameter 也可以将参数默认值设为undefined，表明这个参数是可以省略的。 function foo(optional = undefined) { ··· } 2. reset 参数 ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 function add(...values) { let sum = 0; for (var val of values) { sum += val; } return sum; } add(2, 5, 3) // 10 上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。 下面是一个 rest 参数代替arguments变量的例子。 // arguments变量的写法 function sortNumbers() { return Array.prototype.slice.call(arguments).sort(); } // rest参数的写法 const sortNumbers = (...numbers) => numbers.sort(); arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组 下面是一个利用 rest 参数改写数组push方法的例子。 function push(array, ...items) { items.forEach(function(item) { array.push(item); console.log(item); }); } var a = []; push(a, 1, 2, 3) 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 // 报错 function f(a, ...b, c) { // ... } 函数的length属性，不包括 rest 参数。 (function(a) {}).length // 1 (function(...a) {}).length // 0 (function(a, ...b) {}).length // 1 3. 严格模式 从 ES5 开始，函数内部可以设定为严格模式。 function doSomething(a, b) { 'use strict'; // code } ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 // 报错 function doSomething(a, b = a) { 'use strict'; // code } // 报错 const doSomething = function ({a, b}) { 'use strict'; // code }; // 报错 const doSomething = (...a) => { 'use strict'; // code }; const obj = { // 报错 doSomething({a, b}) { 'use strict'; // code } }; 两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。 'use strict'; function doSomething(a, b = a) { // code } 第二种是把函数包在一个无参数的立即执行函数里面。 const doSomething = (function () { 'use strict'; return function(value = 42) { return value; }; }()); 4. name属性 函数的name属性，返回该函数的函数名。 function foo() {} foo.name // \"foo\" Function构造函数返回的函数实例，name属性的值为anonymous。 (new Function).name // \"anonymous\" 5. 箭头函数 * 1）基本用法 var f = v => v; // 等同于 var f = function (v) { return v; }; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 var f = () => 5; // 等同于 var f = function () { return 5 }; var sum = (num1, num2) => num1 + num2; // 等同于 var sum = function(num1, num2) { return num1 + num2; }; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 var sum = (num1, num2) => { if(true){ return num1 + num2; } } 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 // 报错 let getTempItem = id => { id: id, name: \"Temp\" }; // 不报错 let getTempItem = id => ({ id: id, name: \"Temp\" }); 如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。 let fn = () => void doesNotReturn(); 箭头函数可以与变量解构结合使用。 const full = ({ first, last }) => first + ' ' + last; 箭头函数使得表达更加简洁。 const isEven = n => n % 2 === 0; const square = n => n * n; 箭头函数的一个用处是简化回调函数。 // 正常函数写法 [1,2,3].map(function (x) { return x * x; }); // 箭头函数写法 [1,2,3].map(x => x * x); // 正常函数写法 var result = values.sort(function (a, b) { return a - b; }); // 箭头函数写法 var result = values.sort((a, b) => a - b); 下面是 rest 参数与箭头函数结合的例子。 const numbers = (...nums) => nums; numbers(1, 2, 3, 4, 5) // [1,2,3,4,5] const headAndTail = (head, ...tail) => [head, tail]; headAndTail(1, 2, 3, 4, 5) // [1,[2,3,4,5]] 2）使用注意点 * 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 this对象的指向是可变的，但是在箭头函数中，它是固定的。 function foo() { setTimeout(() => { console.log('id:', this.id); }, 100); } var id = 21; foo.call({ id: 42 }); // id: 42 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。 function Timer() { this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() => this.s1++, 1000); // 普通函数 setInterval(function () { this.s2++; }, 1000); } var timer = new Timer(); setTimeout(() => console.log('s1: ', timer.s1), 3100); setTimeout(() => console.log('s2: ', timer.s2), 3100); // s1: 3 // s2: 0 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 箭头函数转成 ES5 的代码如下。 // ES6 function foo() { setTimeout(() => { console.log('id:', this.id); }, 100); } // ES5 function foo() { var _this = this; setTimeout(function () { console.log('id:', _this.id); }, 100); } 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 function foo() { setTimeout(() => { console.log('args:', arguments); }, 100); } foo(2, 4, 6, 8) // args: [2, 4, 6, 8] 由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 (function() { return [ (() => this.x).bind({ x: 'inner' })() ]; }).call({ x: 'outer' }); // ['outer'] 3）不适用场合 * 定义对象的方法时使用箭头函数，且该方法内部包括this，以下是错误示范 const cat = { lives: 9, jumps: () => { this.lives--; } } cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致jumps箭头函数定义时的作用域就是全局作用域。 需要动态this的时候，也不应使用箭头函数。 var button = document.getElementById('press'); button.addEventListener('click', () => { this.classList.toggle('on'); }); 上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。 另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。 6. 尾调用优化 1）什么是尾调用 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 function f(x){ return g(x); } 函数f的最后一步是调用函数g，这就叫尾调用。 以下三种情况，都不属于尾调用。 // 情况一 function f(x){ let y = g(x); return y; } // 情况二 function f(x){ return g(x) + 1; } // 情况三 function f(x){ g(x); } 情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。函数无返回值默认返回 undefined function f(x){ g(x); return undefined; } 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 function f(x) { if (x > 0) { return m(x) } return n(x); } 函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 2）尾调用优化 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 function f() { let m = 1; let n = 2; return g(m + n); } f(); // 等同于 function f() { return g(3); } f(); // 等同于 g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 3）尾递归 * 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1); } factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5, 1) // 120 4）递归函数的改写 * 柯里化 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，两个方法可以解决这个问题 在尾递归函数之外，再提供一个正常形式的函数。 function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total); } function factorial(n) { return tailFactorial(n, 1); } factorial(5) // 120 上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 就是采用 ES6 的函数默认值，这种就简单多了 function factorial(n, total = 1) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5) // 120 5）严格模式 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。 function restricted() { 'use strict'; restricted.caller; // 报错 restricted.arguments; // 报错 } restricted(); 6）尾递归优化的实现 * 蹦床函数 尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 下面是一个正常的递归函数。 function sum(x, y) { if (y > 0) { return sum(x + 1, y - 1); } else { return x; } } sum(1, 100000) // Uncaught RangeError: Maximum call stack size exceeded(…) 蹦床函数（trampoline）可以将递归执行转为循环执行。 function trampoline(f) { while (f && f instanceof Function) { f = f(); } return f; } 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。 function sum(x, y) { if (y > 0) { return sum.bind(null, x + 1, y - 1); } else { return x; } } trampoline(sum(1, 100000)) // 100001 上面代码中，sum函数的每次执行，都会返回自身的另一个版本，使用蹦床函数执行sum，就不会发生调用栈溢出。 蹦床函数并不是真正的尾递归优化，下面的实现才是。 function tco(f) { var value; var active = false; var accumulated = []; return function accumulator() { accumulated.push(arguments); if (!active) { active = true; while (accumulated.length) { value = f.apply(this, accumulated.shift()); } active = false; return value; } }; } var sum = tco(function(x, y) { if (y > 0) { return sum(x + 1, y - 1) } else { return x } }); sum(1, 100000) // 100001 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。 7. 函数参数的尾逗号 ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。 function a( x, y ){ ... } a( 'xxx', 'yyy' ) 如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数a添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。因此新的语法规定定义和调用函数时，尾部允许有逗号 function a( x, y, ){ ... } a( 'xxx', 'yyy', ) 这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。 8. Function.prototype.toString() ES2019 对函数实例的toString()方法做出了修改。 toString()方法返回函数代码本身，以前会省略注释和空格。 修改前 function /* foo comment */ foo () {} foo.toString() // function foo() {} 修改后的写法 function /* foo comment */ foo () {} foo.toString() // \"function /* foo comment */ foo () {}\" 9. catch 命令的参数省略 JavaScript 语言的try...catch结构，以前明确要求catch命令后面必须跟参数，接受try代码块抛出的错误对象 try { // ... } catch (err) { // 处理错误 } 上面代码中，catch命令后面带有参数err。 很多时候，catch代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。ES2019 做出了改变，允许catch语句省略参数。 try { // ... } catch { // ... } Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-27 23:48 "},"array-extend.html":{"url":"array-extend.html","title":"数组的扩展","keywords":"","body":"数组的扩展 1. 扩展运算符 1）含义 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 console.log(...[1, 2, 3]) // 1 2 3 console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5 扩展运算符后面还可以放置表达式。 const arr = [ ...(x > 0 ? ['a'] : []), 'b', ]; 如果扩展运算符后面是一个空数组，则不产生任何效果。 [...[], 1] // [1] 注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。 (...[1, 2]) // Uncaught SyntaxError: Unexpected number console.log((...[1, 2])) // Uncaught SyntaxError: Unexpected number console.log(...[1, 2]) // 1 2 2）替代函数的 apply 方法 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。 // ES5 的写法 function f(x, y, z) { // ... } var args = [0, 1, 2]; f.apply(null, args); // ES6的写法 function f(x, y, z) { // ... } let args = [0, 1, 2]; f(...args); 通过push函数，将一个数组添加到另一个数组的尾部。 // ES5的 写法 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; Array.prototype.push.apply(arr1, arr2); // ES6 的写法 let arr1 = [0, 1, 2]; let arr2 = [3, 4, 5]; arr1.push(...arr2); 上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。 3）扩展运算符的应用 * （1）复制数组 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。 const a1 = [1, 2]; const a2 = a1; a2[0] = 2; a1 // [2, 2] ES5 只能用变通方法来复制数组。 const a1 = [1, 2]; const a2 = a1.concat(); a2[0] = 2; a1 // [1, 2] 扩展运算符提供了复制数组的简便写法。 const a1 = [1, 2]; // 写法一,这种写法较为常用 const a2 = [...a1]; // 写法二 const [...a2] = a1; （2）合并数组 扩展运算符提供了数组合并的新写法。 const arr1 = ['a', 'b']; const arr2 = ['c']; const arr3 = ['d', 'e']; // ES5 的合并数组 arr1.concat(arr2, arr3); // [ 'a', 'b', 'c', 'd', 'e' ] // ES6 的合并数组 [...arr1, ...arr2, ...arr3] // [ 'a', 'b', 'c', 'd', 'e' ] 不过，这两种方法都是浅拷贝，使用的时候需要注意。 const a1 = [{ foo: 1 }]; const a2 = [{ bar: 2 }]; const a3 = a1.concat(a2); const a4 = [...a1, ...a2]; a3[0] === a1[0] // true a4[0] === a1[0] // true 上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。 （3）与结构赋值结合 扩展运算符可以与解构赋值结合起来，用于生成数组。 // ES5 a = list[0], rest = list.slice(1) // ES6 [a, ...rest] = list const [first, ...rest] = [1, 2, 3, 4, 5]; first // 1 rest // [2, 3, 4, 5] const [first, ...rest] = []; first // undefined rest // [] const [first, ...rest] = [\"foo\"]; first // \"foo\" rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 const [...butLast, last] = [1, 2, 3, 4, 5]; // 报错 const [first, ...middle, last] = [1, 2, 3, 4, 5]; // 报错 （4）字符串 扩展运算符还可以将字符串转为真正的数组。 [...'hello'] // [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。 'x\\uD83D\\uDE80y'.length // 4 [...'x\\uD83D\\uDE80y'].length // 3 （5）实现了 Iterator 接口的对象 任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。 let nodeList = document.querySelectorAll('div'); let array = [...nodeList]; 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。 let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3 }; // TypeError: Cannot spread non-iterable object. let arr = [...arrayLike]; 上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 （6）Map 和 Set 结构， Generator函数 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。 let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'], ]); let arr = [...map.keys()]; // [1, 2, 3] Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 const go = function*(){ yield 1; yield 2; yield 3; }; [...go()] // [1, 2, 3] 2. Array.from() 1）含义 Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 2）用法 把一个类似数组的对象，Array.from将它转为真正的数组。 let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3 }; // ES5的写法 var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c'] // ES6的写法 let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 // NodeList对象 let ps = document.querySelectorAll('p'); Array.from(ps).filter(p => { return p.textContent.length > 100; }); // arguments对象 function foo() { var args = Array.from(arguments); // ... } 只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。 Array.from('hello') // ['h', 'e', 'l', 'l', 'o'] let namesSet = new Set(['a', 'b']) Array.from(namesSet) // ['a', 'b'] 参数是一个真正的数组，Array.from会返回一个一模一样的新数组。 Array.from([1, 2, 3]) // [1, 2, 3] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 Array.from({ length: 3 }); // [ undefined, undefined, undefined ] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 Array.from(arrayLike, x => x * x); // 等同于 Array.from(arrayLike).map(x => x * x); Array.from([1, 2, 3], (x) => x * x) // [1, 4, 9] 将数组中布尔值为false的成员转为0。 Array.from([1, , 2, , 3], (n) => n || 0) // [1, 0, 2, 0, 3] 返回各种数据的类型。 function typesOf () { return Array.from(arguments, value => typeof value) } typesOf(null, [], NaN) // ['object', 'object', 'number'] 3）模拟实现 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 const toArray = (() => Array.from ? Array.from : obj => [].slice.call(obj) )(); 3. Array.of() 1） 含义 Array.of方法用于将一组值，转换为数组。 Array.of(3, 11, 8) // [3,11,8] Array.of(3) // [3] Array.of(3).length // 1 2）用法 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 Array() // [] Array(3) // [, , ,] Array(3, 11, 8) // [3, 11, 8] 只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 3）模拟实现 Array.of方法可以用下面的代码模拟实现。 function ArrayOf(){ return [].slice.call(arguments); } 4. 数组实例的 copyWith() 1）含义 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 2）用法 它接受三个参数。 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。 这三个参数都应该是数值，如果不是，会自动转为数值。 [1, 2, 3, 4, 5,6,7,8].copyWithin(0, 3) // [4, 5, 6, 7, 8, 6, 7, 8] // 将3号位复制到0号位 [1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5] // -2相当于3号位，-1相当于4号位 [1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5] 5. 数组实例的 find() 和 findIndex() 1）find 含义 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 [1, 4, -5, 10].find((n) => n 2）find 用法 find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 [1, 5, 10, 15].find(function(value, index, arr) { return value > 9; }) // 10 3）findIndex 含义 返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 [1, 5, 10, 15].findIndex(function(value, index, arr) { return value > 9; }) // 2 4）用法 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 function f(v){ return v > this.age; } let person = {name: 'John', age: 20}; [10, 12, 26, 15].find(f, person); // 26 这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。 [NaN].indexOf(NaN) // -1 [NaN].findIndex(y => Object.is(NaN, y)) // 0 indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。 6. 数组实例的 fill() 1）含义 fill方法使用给定值，填充一个数组。 ['a', 'b', 'c'].fill(7) // [7, 7, 7] new Array(3).fill(7) // [7, 7, 7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 2）用法 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 ['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] 如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 let arr = new Array(3).fill({name: \"Mike\"}); arr[0].name = \"Ben\"; arr // [{name: \"Ben\"}, {name: \"Ben\"}, {name: \"Ben\"}] let arr = new Array(3).fill([]); arr[0].push(5); arr // [[5], [5], [5]] 7. 数组实例的 entries()， keys()，和values() 1）含义 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 for (let index of ['a', 'b'].keys()) { console.log(index); } // 0 // 1 for (let elem of ['a', 'b'].values()) { console.log(elem); } // 'a' // 'b' for (let [index, elem] of ['a', 'b'].entries()) { console.log(index, elem); } // 0 \"a\" // 1 \"b\" 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。 let letter = ['a', 'b', 'c']; let entries = letter.entries(); console.log(entries.next().value); // [0, 'a'] console.log(entries.next().value); // [1, 'b'] console.log(entries.next().value); // [2, 'c'] 8. 数组实例的 includes() 1）含义 Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。 [1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false [1, 2, NaN].includes(NaN) // true 2）用法 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 [1, 2, 3].includes(3, 3); // false [1, 2, 3].includes(3, -1); // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。 if (arr.indexOf(el) !== -1) { // ... } indexOf方法有两个缺点 不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。 它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。 [NaN].indexOf(NaN) // -1 includes使用的是不一样的判断算法，就没有这个问题。 [NaN].includes(NaN) // true Map 和 Set 数据结构有一个has方法，需要注意与includes区分。 Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。 Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。 9. 数组实例的 flat(), flatMap() 1）flat() 含义 数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。 [1, 2, [3, 4]].flat() // [1, 2, 3, 4] 2）flat() 用法 flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。参数为2，表示要“拉平”两层的嵌套数组。 [1, 2, [3, [4, 5]]].flat() // [1, 2, 3, [4, 5]] [1, 2, [3, [4, 5]]].flat(2) // [1, 2, 3, 4, 5] 如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。 [1, [2, [3]]].flat(Infinity) // [1, 2, 3] 如果原数组有空位，flat()方法会跳过空位。 [1, 2, , 4, 5].flat() // [1, 2, 4, 5] 3） flatMap() 含义 flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。 // 相当于 [[2, 4], [3, 6], [4, 8]].flat() [2, 3, 4].flatMap((x) => [x, x * 2]) // [2, 4, 3, 6, 4, 8] flatMap()只能展开一层数组，返回的还是一个嵌套数组。 // 相当于 [[[2]], [[4]], [[6]], [[8]]].flat() [1, 2, 3, 4].flatMap(x => [[x * 2]]) // [[2], [4], [6], [8]] 4）flatMap() 用法 flatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。 10. 数组的空位 1）含义 数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 Array(3) // [, , ,] 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。 0 in [undefined, undefined, undefined] // true 0 in [, , ,] // false 2）用法 ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 ES6 则是明确将空位转为undefined。 Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。 Array.from(['a',,'b']) // [ \"a\", undefined, \"b\" ] 扩展运算符（...）也会将空位转为undefined。 [...['a',,'b']] // [ \"a\", undefined, \"b\" ] copyWithin()会连空位一起拷贝。 [,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"] fill()会将空位视为正常的数组位置。 new Array(3).fill('a') // [\"a\",\"a\",\"a\"] for...of循环也会遍历空位。 let arr = [, ,]; for (let i of arr) { console.log(1); } // 1 // 1 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 // entries() [...[,'a'].entries()] // [[0,undefined], [1,\"a\"]] // keys() [...[,'a'].keys()] // [0,1] // values() [...[,'a'].values()] // [undefined,\"a\"] // find() [,'a'].find(x => true) // undefined // findIndex() [,'a'].findIndex(x => true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。 11. Array.prototype.sort() 的排序稳定性 2）含义 排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。 const arr = [ 'peach', 'straw', 'apple', 'spork' ]; const stableSorting = (s1, s2) => { if (s1[0] 上面代码对数组arr按照首字母进行排序。排序结果中，straw在spork的前面，跟原始顺序一致，所以排序算法stableSorting是稳定排序。 const unstableSorting = (s1, s2) => { if (s1[0] 上面代码中，排序结果是spork在straw前面，跟原始顺序相反，所以排序算法unstableSorting是不稳定的。 早先的 ECMAScript 没有规定，Array.prototype.sort()的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。ES2019 明确规定，Array.prototype.sort()的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"object-extend.html":{"url":"object-extend.html","title":"对象的扩展","keywords":"","body":"对象的扩展 1. 属性的简介表示法 ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 const foo = 'bar'; const baz = {foo}; baz // {foo: \"bar\"} // 等同于 const baz = {foo: foo}; 变量foo直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。 函数也可以简写 let birth = '2000/01/01'; const Person = { name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() { console.log('我的名字是', this.name); } }; 属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。 const cart = { _wheels: 4, get wheels () { return this._wheels; }, set wheels (value) { if (value 简洁写法在打印对象时也很有用。 let user = { name: 'test' }; let foo = { bar: 'baz' }; console.log(user, foo) // {name: \"test\"} {bar: \"baz\"} console.log({user, foo}) // {user: {name: \"test\"}, foo: {bar: \"baz\"}} 上面代码中，console.log直接输出user和foo两个对象时，就是两组键值对，可能会混淆。把它们放在大括号里面输出，就变成了对象的简洁表示法，每组键值对前面会打印对象名，这样就比较清晰了。 注意，简写的对象方法不能用作构造函数，会报错。 const obj = { f() { this.foo = 'bar'; } }; new obj.f() // 报错 2. 属性名表达式 1）定义属性名 JavaScript 定义对象的属性，有两种方法。 // 方法一 obj.foo = true; // 方法二 obj['a' + 'bc'] = 123; 上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。 ES6 允许字面量定义对象时，把表达式放在方括号内。 let propKey = 'foo'; let obj = { [propKey]: true, ['a' + 'bc']: 123 }; // {foo: true, abc: 123} let lastWord = 'last word'; const a = { 'first word': 'hello', [lastWord]: 'world' }; a['first word'] // \"hello\" a['firstWord'] // undefined a[lastWord] // \"world\" a['last word'] // \"world\" 属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。 const keyA = {a: 1}; const keyB = {b: 2}; const myObject = { [keyA]: 'valueA', [keyB]: 'valueB' }; myObject // Object {[object Object]: \"valueB\"} [keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。 2）定义方法名 let obj = { ['h' + 'ello']() { return 'hi'; } }; obj.hello() // hi 3. 方法的 name 属性 函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。 const person = { sayName() { console.log('hello!'); }, }; person.sayName.name // \"sayName\" 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 const obj = { get foo() {}, set foo(x) {} }; obj.foo.name // TypeError: Cannot read property 'name' of undefined const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo'); descriptor.get.name // \"get foo\" descriptor.set.name // \"set foo\" 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。 (new Function()).name // \"anonymous\" var doSomething = function() { // ... }; doSomething.bind().name // \"bound doSomething\" 4. 属性的可没举性和遍历 1）可枚举性 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 let obj = { foo: 123 }; Object.getOwnPropertyDescriptor(obj, 'foo') // { // value: 123, // writable: true, // enumerable: true, // configurable: true // } 引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for...in遍历到。 Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable // false Object.getOwnPropertyDescriptor([], 'length').enumerable // false ES6 规定，所有 Class 的原型的方法都是不可枚举的。 Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable // false 操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替。 2）属性的遍历 ES6 公有5种方法可以实现对属性的遍历 （1）for...in for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 （2）Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 （3）Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 （4）Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 （5）Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。 Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 }) // ['2', '10', 'b', 'a', Symbol()] 5. super 关键字 this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。 const proto = { foo: 'hello' }; const obj = { foo: 'world', find() { return super.foo; } }; Object.setPrototypeOf(obj, proto); obj.find() // \"hello\" 上面代码中，对象obj.find()方法之中，通过super.foo引用了原型对象proto的foo属性。 注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 // 报错 const obj = { foo: super.foo } // 报错 const obj = { foo: () => super.foo } // 报错 const obj = { foo: function () { return super.foo } } 上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。 JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。 const proto = { x: 'hello', foo() { console.log(this.x); }, }; const obj = { x: 'world', foo() { super.foo(); } } Object.setPrototypeOf(obj, proto); obj.foo() // \"world\" 6. 对象的扩展运算符 1）解构赋值 对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; x // 1 y // 2 z // { a: 3, b: 4 } 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。 let { ...z } = null; // 运行时错误 let { ...z } = undefined; // 运行时错误 解构赋值必须是最后一个参数，否则会报错。 let { ...x, y, z } = someObject; // 句法错误 let { x, ...y, ...z } = someObject; // 句法错误 注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。 let obj = { a: { b: 1 } }; let { ...x } = obj; obj.a.b = 2; x.a.b // 2 扩展运算符的解构赋值，不能复制继承自原型对象的属性。 let o1 = { a: 1 }; let o2 = { b: 2 }; o2.__proto__ = o1; let { ...o3 } = o2; o3 // { b: 2 } o3.a // undefined 2）扩展运算符 对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 let z = { a: 3, b: 4 }; let n = { ...z }; n // { a: 3, b: 4 } 由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。 let foo = { ...['a', 'b', 'c'] }; foo // {0: \"a\", 1: \"b\", 2: \"c\"} 如果扩展运算符后面是一个空对象，则没有任何效果。 {...{}, a: 1} // { a: 1 } 如果扩展运算符后面不是对象，则会自动将其转为对象。 // 等同于 {...Object(1)} {...1} // {} // 等同于 {...Object(true)} {...true} // {} // 等同于 {...Object(undefined)} {...undefined} // {} // 等同于 {...Object(null)} {...null} // {} 但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。 {...'hello'} // {0: \"h\", 1: \"e\", 2: \"l\", 3: \"l\", 4: \"o\"} 对象的扩展运算符等同于使用Object.assign()方法。 let aClone = { ...a }; // 等同于 let aClone = Object.assign({}, a); 上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。 // 写法一 const clone1 = { __proto__: Object.getPrototypeOf(obj), ...obj }; // 写法二 const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj ); // 写法三 const clone3 = Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj) ) 上面代码中，写法一的__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。 扩展运算符可以用于合并两个对象。 let ab = { ...a, ...b }; // 等同于 let ab = Object.assign({}, a, b); 如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。这用来修改现有对象部分的属性就很方便了。 let newVersion = { ...previousVersion, name: 'New Name' // Override the name property }; 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。 let aWithDefaults = { x: 1, y: 2, ...a }; // 等同于 let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a); // 等同于 let aWithDefaults = Object.assign({ x: 1, y: 2 }, a); 与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。 const obj = { ...(x > 1 ? {a: 1} : {}), b: 2, }; 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。 // 并不会抛出错误，因为 x 属性只是被定义，但没执行 let aWithXGetter = { ...a, get x() { throw new Error('not throw yet'); } }; // 会抛出错误，因为 x 属性被执行了 let runtimeError = { ...a, ...{ get x() { throw new Error('throw now'); } } }; 7. 链判断运算符 ?. * 编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。 比如，要读取message.body.user.firstName，安全的写法是写成下面这样。 const firstName = (message && message.body && message.body.user && message.body.user.firstName) || 'default'; 这样的层层判断非常麻烦，因此 ES2020 引入了“链判断运算符”（optional chaining operator）?.，简化上面的写法。 const firstName = message?.body?.user?.firstName || 'default'; 上面代码使用了?.运算符，直接在链式调用的时候判断，左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined。 链判断运算符有三种用法。 obj?.prop // 对象属性 obj?.[expr] // 同上 func?.(...args) // 函数或对象方法的调用 下面是判断对象方法是否存在，如果存在就立即执行的例子。 obj.fn?.() 上面代码中，obj.fn如果有定义，就会调用该方法，否则直接返回undefined`。 对于那些可能没有实现的方法，这个运算符尤其有用。 if (myForm.checkValidity?.() === false) { // 表单校验失败 return; } 上面代码中，老式浏览器的表单可能没有checkValidity这个方法，这时?.运算符就会返回undefined，判断语句就变成了undefined === false，所以就会跳过下面的代码。 下面是这个运算符常见的使用形式，以及不使用该运算符时的等价形式。 a?.b // 等同于 a == null ? undefined : a.b a?.[x] // 等同于 a == null ? undefined : a[x] a?.b() // 等同于 a == null ? undefined : a.b() a?.() // 等同于 a == null ? undefined : a() 使用这个运算符，有几个注意点。 1）断路机制 a?.[++x] // 等同于 a == null ? undefined : a[++x] 上面代码中，如果a是undefined或null，那么x不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。 2）delete 运算符 delete a?.b // 等同于 a == null ? undefined : delete a.b 上面代码中，如果a是undefined或null，会直接返回undefined，而不会进行delete运算。 3）括号的影响 如果属性链有圆括号，链判断运算符只对圆括号内部有影响。 (a?.b).c // 等价于 (a == null ? undefined : a.b).c 一般来说，使用?.运算符的场合，不应该使用圆括号。 4）报错场合 以下写法是禁止的，会报错。 // 构造函数 new a?.() new a?.b() // 链判断运算符的右侧有模板字符串 a?.`{b}` a?.b`{c}` // 链判断运算符的左侧是 super super?.() super?.foo // 链运算符用于赋值运算符左侧 a?.b = c 5）右侧不得为十进制数值 为了保证兼容以前的代码，允许foo?.3:0被解析成foo ? .3 : 0，因此规定如果?.后面紧跟一个十进制数字，那么?.不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。 8. Null 判断运算符 ?? * 读取对象属性的时候，如果某个属性的值是null或undefined，有时候需要为它们指定默认值。常见做法是通过||运算符指定默认值。 const headerText = response.settings.headerText || 'Hello, world!'; const animationDuration = response.settings.animationDuration || 300; const showSplashScreen = response.settings.showSplashScreen || true; 上面的三行代码都通过||运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为null或undefined，默认值就会生效，但是属性的值如果为空字符串或false或0，默认值也会生效。 ES2020 引入了一个新的 Null 判断运算符??。它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值。 const headerText = response.settings.headerText ?? 'Hello, world!'; const animationDuration = response.settings.animationDuration ?? 300; const showSplashScreen = response.settings.showSplashScreen ?? true; 这个运算符的一个目的，就是跟链判断运算符?.配合使用，为null或undefined的值设置默认值。 const animationDuration = response.settings?.animationDuration ?? 300; 这个运算符很适合判断函数参数是否赋值。 function Component(props) { const enable = props.enabled ?? true; // … } //等同于 function Component(props) { const { enabled: enable = true, } = props; // … } ??有一个运算优先级问题，它与&&和||的优先级孰高孰低。现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。 // 报错 lhs && middle ?? rhs lhs ?? middle && rhs lhs || middle ?? rhs lhs ?? middle || rhs 必须加入表明优先级的括号。 (lhs && middle) ?? rhs; lhs && (middle ?? rhs); (lhs ?? middle) && rhs; lhs ?? (middle && rhs); (lhs || middle) ?? rhs; lhs || (middle ?? rhs); (lhs ?? middle) || rhs; lhs ?? (middle || rhs); 9. 操作符反回值 && || 1）&& （1）真真反后 let a = 1 && 2 // a = 2 （2）假假反前 let a = 0 && null // a = 0 （3）真假反假 let a = 0 && 1 // a = 0 let a = 1 && 0 // a = 0 2）|| （1）真真反前 let a = 1 || 2 // a = 1 （2）假假反后 let a = 0 || null // a = null （3）真假反真 let a = 0 && 1 // a = 1 let a = 1 && 0 // a = 1 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"object-new-method.html":{"url":"object-new-method.html","title":"对象的新增方法","keywords":"","body":"对象的新增方法 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"Symbol.html":{"url":"Symbol.html","title":"Symbol","keywords":"","body":"Symbol Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"Set-Map.html":{"url":"Set-Map.html","title":"Set 和 Map 数据结构","keywords":"","body":"Set 和 Map 数据结构 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"Proxy.html":{"url":"Proxy.html","title":"Proxy","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"Reflect.html":{"url":"Reflect.html","title":"Reflect","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"Promise.html":{"url":"Promise.html","title":"Promise","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"Interator-for...of.html":{"url":"Interator-for...of.html","title":"Interator 和 for...of 循环","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"Generator.html":{"url":"Generator.html","title":"Generator函数的语法","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"Generator-async.html":{"url":"Generator-async.html","title":"Generator函数的异步调用","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"async.html":{"url":"async.html","title":"async函数","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"Class.html":{"url":"Class.html","title":"Class的基本语法","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"Class-inherit.html":{"url":"Class-inherit.html","title":"Class的继承","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"Module.html":{"url":"Module.html","title":"Module的语法","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"Module-loading.html":{"url":"Module-loading.html","title":"Module的加载实现","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"programming-style.html":{"url":"programming-style.html","title":"编程风格","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"understand-specification.html":{"url":"understand-specification.html","title":"读懂规格","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"async-iterator.html":{"url":"async-iterator.html","title":"异步遍历器","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"ArrayBuffer.html":{"url":"ArrayBuffer.html","title":"ArrayBuffer","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"reference-linking.html":{"url":"reference-linking.html","title":"参考链接","keywords":"","body":"参考链接 感谢 阮一峰 文档的支持，学后受益匪浅，更快的理解ES6，更容易的上手ES6，以下都是复制来的，大家可以去他的官网翻阅。 1. 官方文件 ECMAScript® 2015 Language Specification: ECMAScript 2015 规格 ECMAScript® 2016 Language Specification: ECMAScript 2016 规格 ECMAScript® 2017 Language Specification：ECMAScript 2017 规格（草案） ECMAScript Current Proposals: ECMAScript 当前的所有提案 ECMAScript Active Proposals: 已经进入正式流程的提案 ECMAScript proposals：从阶段 0 到阶段 4 的所有提案列表 TC39 meeting agendas: TC39 委员会历年的会议记录 ECMAScript Daily: TC39 委员会的动态 The TC39 Process: 提案进入正式规格的流程 TC39: A Process Sketch, Stages 0 and 1: Stage 0 和 Stage 1 的含义 TC39 Process Sketch, Stage 2: Stage 2 的含义 2. 综合介绍 Axel Rauschmayer, Exploring ES6: Upgrade to the next version of JavaScript: ES6 的专著，本书的许多代码实例来自该书 Sayanee Basu, Use ECMAScript 6 Today Ariya Hidayat, Toward Modern Web Apps with ECMAScript 6 Dale Schouten, 10 Ecmascript-6 tricks you can perform right now Colin Toh, Lightweight ES6 Features That Pack A Punch: ES6 的一些“轻量级”的特性介绍 Domenic Denicola, ES6: The Awesome Parts Nicholas C. Zakas, Understanding ECMAScript 6 Justin Drake, ECMAScript 6 in Node.JS Ryan Dao, Summary of ECMAScript 6 major features Luke Hoban, ES6 features: ES6 新语法点的罗列 Traceur-compiler, Language Features: Traceur 文档列出的一些 ES6 例子 Axel Rauschmayer, ECMAScript 6: what’s next for JavaScript?: 关于 ES6 新增语法的综合介绍，有很多例子 Axel Rauschmayer, Getting started with ECMAScript 6: ES6 语法点的综合介绍 Toby Ho, ES6 in io.js Guillermo Rauch, ECMAScript 6 Benjamin De Cock, Frontend Guidelines: ES6 最佳实践 Jani Hartikainen, ES6: What are the benefits of the new features in practice? kangax, JavaScript quiz. ES6 edition: ES6 小测试 Jeremy Fairbank, HTML5DevConf ES7 and Beyond!: ES7 新增语法点介绍 Timothy Gu, How to Read the ECMAScript Specification: 如何读懂 ES6 规格 3. let和const Kyle Simpson, For and against let: 讨论 let 命令的作用域 kangax, Why typeof is no longer “safe”: 讨论在块级作用域内，let 命令的变量声明和赋值的行为 Axel Rauschmayer, Variables and scoping in ECMAScript 6: 讨论块级作用域与 let 和 const 的行为 Nicolas Bevacqua, ES6 Let, Const and the “Temporal Dead Zone” (TDZ) in Depth acorn, Function statements in strict mode: 块级作用域对严格模式的函数声明的影响 Axel Rauschmayer, ES proposal: global: 顶层对象global Mathias Bynens, A horrifying globalThis polyfill in universal JavaScript：如何写 globalThis 的垫片库 4. 解构赋值 Nick Fitzgerald, Destructuring Assignment in ECMAScript 6: 详细介绍解构赋值的用法 Nicholas C. Zakas, ECMAScript 6 destructuring gotcha 5. 字符串 Nicholas C. Zakas, A critical review of ECMAScript 6 quasi-literals Mozilla Developer Network, Template strings Addy Osmani, Getting Literal With ES6 Template Strings: 模板字符串的介绍 Blake Winton, ES6 Templates: 模板字符串的介绍 Peter Jaszkowiak, How to write a template compiler in JavaScript: 使用模板字符串，编写一个模板编译函数 Axel Rauschmayer, ES.stage3: string padding 6. 正则 Mathias Bynens, Unicode-aware regular expressions in ES6: 详细介绍正则表达式的 u 修饰符 Axel Rauschmayer, New regular expression features in ECMAScript 6：ES6 正则特性的详细介绍 Yang Guo, RegExp lookbehind assertions：介绍后行断言 Axel Rauschmayer, ES proposal: RegExp named capture groups: 具名组匹配的介绍 Mathias Bynens, ECMAScript regular expressions are getting better!: 介绍 ES2018 添加的多项正则语法 7. 数值 Nicolas Bevacqua, ES6 Number Improvements in Depth Axel Rauschmayer, ES proposal: arbitrary precision integers Mathias Bynens, BigInt: arbitrary-precision integers in JavaScript 8. 数组 Axel Rauschmayer, ECMAScript 6’s new array methods: 对 ES6 新增的数组方法的全面介绍 TC39, Array.prototype.includes: 数组的 includes 方法的规格 Axel Rauschmayer, ECMAScript 6: holes in Arrays: 数组的空位问题 9. 函数 Nicholas C. Zakas, Understanding ECMAScript 6 arrow functions Jack Franklin, Real Life ES6 - Arrow Functions Axel Rauschmayer, Handling required parameters in ECMAScript 6 Dmitry Soshnikov, ES6 Notes: Default values of parameters: 介绍参数的默认值 Ragan Wald, Destructuring and Recursion in ES6: rest 参数和扩展运算符的详细介绍 Axel Rauschmayer, The names of functions in ES6: 函数的 name 属性的详细介绍 Kyle Simpson, Arrow This: 箭头函数并没有自己的 this Derick Bailey, Do ES6 Arrow Functions Really Solve “this” In JavaScript?：使用箭头函数处理 this 指向，必须非常小心 Mark McDonnell, Understanding recursion in functional JavaScript programming: 如何自己实现尾递归优化 Nicholas C. Zakas, The ECMAScript 2016 change you probably don't know: 使用参数默认值时，不能在函数内部显式开启严格模式 Axel Rauschmayer, ES proposal: optional catch binding Cynthia Lee, When you should use ES6 arrow functions — and when you shouldn’t: 讨论箭头函数的适用场合 Eric Elliott, What is this?: 箭头函数内部的 this 的解释。 10. 对象 Addy Osmani, Data-binding Revolutions with Object.observe(): 介绍 Object.observe()的概念 Sella Rafaeli, Native JavaScript Data-Binding: 如何使用 Object.observe 方法，实现数据对象与 DOM 对象的双向绑定 Axel Rauschmayer, __proto__ in ECMAScript 6 Axel Rauschmayer, Enumerability in ECMAScript 6 Axel Rauschmayer, ES proposal: Object.getOwnPropertyDescriptors() TC39, Object.getOwnPropertyDescriptors Proposal David Titarenco, How Spread Syntax Breaks JavaScript: 扩展运算符的一些不合理的地方 11. Symbol Axel Rauschmayer, Symbols in ECMAScript 6: Symbol 简介 MDN, Symbol: Symbol 类型的详细介绍 Jason Orendorff, ES6 In Depth: Symbols Keith Cirkel, Metaprogramming in ES6: Symbols and why they're awesome: Symbol 的深入介绍 Axel Rauschmayer, Customizing ES6 via well-known symbols Derick Bailey, Creating A True Singleton In Node.js, With ES6 Symbols Das Surma, How to read web specs Part IIa – Or: ECMAScript Symbols: 介绍 Symbol 的规格 12. Set 和 Map Mozilla Developer Network, WeakSet：介绍 WeakSet 数据结构 Dwayne Charrington, What Are Weakmaps In ES6?: WeakMap 数据结构介绍 Axel Rauschmayer, ECMAScript 6: maps and sets: Set 和 Map 结构的详细介绍 Jason Orendorff, ES6 In Depth: Collections：Set 和 Map 结构的设计思想 Axel Rauschmayer, Converting ES6 Maps to and from JSON: 如何将 Map 与其他数据结构互相转换 13. Proxy 和 Reflect Nicholas C. Zakas, Creating defensive objects with ES6 proxies Axel Rauschmayer, Meta programming with ECMAScript 6 proxies: Proxy 详解 Daniel Zautner, Meta-programming JavaScript Using Proxies: 使用 Proxy 实现元编程 Tom Van Cutsem, Harmony-reflect: Reflect 对象的设计目的 Tom Van Cutsem, Proxy Traps: Proxy 拦截操作一览 Tom Van Cutsem, Reflect API Tom Van Cutsem, Proxy Handler API Nicolas Bevacqua, ES6 Proxies in Depth Nicolas Bevacqua, ES6 Proxy Traps in Depth Nicolas Bevacqua, More ES6 Proxy Traps in Depth Axel Rauschmayer, Pitfall: not all objects can be wrapped transparently by proxies Bertalan Miklos, Writing a JavaScript Framework - Data Binding with ES6 Proxies: 使用 Proxy 实现观察者模式 Keith Cirkel, Metaprogramming in ES6: Part 2 - Reflect: Reflect API 的详细介绍 14. Promise Jake Archibald, JavaScript Promises: There and back again Jake Archibald, Tasks, microtasks, queues and schedules Tilde, rsvp.js Sandeep Panda, An Overview of JavaScript Promises: ES6 Promise 入门介绍 Dave Atchley, ES6 Promises: Promise 的语法介绍 Axel Rauschmayer, ECMAScript 6 promises (2/2): the API: 对 ES6 Promise 规格和用法的详细介绍 Jack Franklin, Embracing Promises in JavaScript: catch 方法的例子 Ronald Chen, How to escape Promise Hell: 如何使用Promise.all方法的一些很好的例子 Jordan Harband, proposal-promise-try: Promise.try() 方法的提案 Sven Slootweg, What is Promise.try, and why does it matter?: Promise.try() 方法的优点 Yehuda Katz, TC39: Promises, Promises: Promise.try() 的用处 15. Iterator Mozilla Developer Network, Iterators and generators Mozilla Developer Network, The Iterator protocol Jason Orendorff, ES6 In Depth: Iterators and the for-of loop: 遍历器与 for...of 循环的介绍 Axel Rauschmayer, Iterators and generators in ECMAScript 6: 探讨 Iterator 和 Generator 的设计目的 Axel Rauschmayer, Iterables and iterators in ECMAScript 6: Iterator 的详细介绍 Kyle Simpson, Iterating ES6 Numbers: 在数值对象上部署遍历器 16. Generator Matt Baker, Replacing callbacks with ES6 Generators Steven Sanderson, Experiments with Koa and JavaScript Generators jmar777, What's the Big Deal with Generators? Marc Harter, Generators in Node.js: Common Misconceptions and Three Good Use Cases: 讨论 Generator 函数的作用 StackOverflow, ES6 yield : what happens to the arguments of the first call next()?: 第一次使用 next 方法时不能带有参数 Kyle Simpson, ES6 Generators: Complete Series: 由浅入深探讨 Generator 的系列文章，共四篇 Gajus Kuizinas, The Definitive Guide to the JavaScript Generators: 对 Generator 的综合介绍 Jan Krems, Generators Are Like Arrays: 讨论 Generator 可以被当作数据结构看待 Harold Cooper, Coroutine Event Loops in JavaScript: Generator 用于实现状态机 Ruslan Ismagilov, learn-generators: 编程练习，共 6 道题 Steven Sanderson, Experiments with Koa and JavaScript Generators: Generator 入门介绍，以 Koa 框架为例 Mahdi Dibaiee, ES7 Array and Generator comprehensions：ES7 的 Generator 推导 Nicolas Bevacqua, ES6 Generators in Depth Axel Rauschmayer, ES6 generators in depth: Generator 规格的详尽讲解 Derick Bailey, Using ES6 Generators To Short-Circuit Hierarchical Data Iteration：使用 for...of 循环完成预定的操作步骤 17. 异步操作和 Async函数 Luke Hoban, Async Functions for ECMAScript: Async 函数的设计思想，与 Promise、Gernerator 函数的关系 Jafar Husain, Asynchronous Generators for ES7: Async 函数的深入讨论 Nolan Lawson, Taming the asynchronous beast with ES7: async 函数通俗的实例讲解 Jafar Husain, Async Generators: 对 async 与 Generator 混合使用的一些讨论 Daniel Brain, Understand promises before you start using async/await: 讨论 async/await 与 Promise 的关系 Jake Archibald, Async functions - making promises friendly Axel Rauschmayer, ES proposal: asynchronous iteration: 异步遍历器的详细介绍 Dima Grossman, How to write async await without try-catch blocks in JavaScript: 除了 try/catch 以外的 async 函数内部捕捉错误的方法 Mostafa Gaafa, 6 Reasons Why JavaScript’s Async/Await Blows Promises Away: Async 函数的6个好处 Mathias Bynens, Asynchronous stack traces: why await beats Promise#then(): async 函数可以保留错误堆栈 18. Class Sebastian Porto, ES6 classes and JavaScript prototypes: ES6 Class 的写法与 ES5 Prototype 的写法对比 Jack Franklin, An introduction to ES6 classes: ES6 class 的入门介绍 Axel Rauschmayer, ECMAScript 6: new OOP features besides classes Axel Rauschmayer, Classes in ECMAScript 6 (final semantics): Class 语法的详细介绍和设计思想分析 Eric Faust, ES6 In Depth: Subclassing: Class 语法的深入介绍 Nicolás Bevacqua, Binding Methods to Class Instance Objects: 如何绑定类的实例中的 this Jamie Kyle, JavaScript's new #private class fields：私有属性的介绍。 Mathias Bynens, Public and private class fields：实例属性的新写法的介绍。 19. Decorator Maximiliano Fierro, Declarative vs Imperative: Decorators 和 Mixin 介绍 Justin Fagnani, \"Real\" Mixins with JavaScript Classes: 使用类的继承实现 Mixin Addy Osmani, Exploring ES2016 Decorators: Decorator 的深入介绍 Sebastian McKenzie, Allow decorators for functions as well: 为什么修饰器不能用于函数 Maximiliano Fierro, Traits with ES7 Decorators: Trait 的用法介绍 Jonathan Creamer: Using ES2016 Decorators to Publish on an Event Bus: 使用修饰器实现自动发布事件 20. Module Jack Franklin, JavaScript Modules the ES6 Way: ES6 模块入门 Axel Rauschmayer, ECMAScript 6 modules: the final syntax: ES6 模块的介绍，以及与 CommonJS 规格的详细比较 Dave Herman, Static module resolution: ES6 模块的静态化设计思想 Jason Orendorff, ES6 In Depth: Modules: ES6 模块设计思想的介绍 Ben Newman, The Importance of import and export: ES6 模块的设计思想 ESDiscuss, Why is \"export default var a = 1;\" invalid syntax? Bradley Meck, ES6 Module Interoperability: 介绍 Node 如何处理 ES6 语法加载 CommonJS 模块 Axel Rauschmayer, Making transpiled ES modules more spec-compliant: ES6 模块编译成 CommonJS 模块的详细介绍 Axel Rauschmayer, ES proposal: import() – dynamically importing ES modules: import() 的用法 Node EPS, ES Module Interoperability: Node 对 ES6 模块的处理规格 21. 二进制数组 Ilmari Heikkinen, Typed Arrays: Binary Data in the Browser Khronos, Typed Array Specification Ian Elliot, Reading A BMP File In JavaScript Renato Mangini, How to convert ArrayBuffer to and from String Axel Rauschmayer, Typed Arrays in ECMAScript 6 Axel Rauschmayer, ES proposal: Shared memory and atomics Lin Clark, Avoiding race conditions in SharedArrayBuffers with Atomics: Atomics 对象使用场景的解释 Lars T Hansen, Shared memory - a brief tutorial James Milner, The Return of SharedArrayBuffers and Atomics 22. SIMD TC39, SIMD.js Stage 2 MDN, SIMD TC39, ECMAScript SIMD Axel Rauschmayer, JavaScript gains support for SIMD 23. 工具 Babel, Babel Handbook: Babel 的用法介绍 Google, traceur-compiler: Traceur 编译器 Casper Beyer, ECMAScript 6 Features and Tools Stoyan Stefanov, Writing ES6 today with jstransform ES6 Module Loader, ES6 Module Loader Polyfill: 在浏览器和 node.js 加载 ES6 模块的一个库，文档里对 ES6 模块有详细解释 Paul Miller, es6-shim: 一个针对老式浏览器，模拟 ES6 部分功能的垫片库（shim） army8735, JavaScript Downcast: 国产的 ES6 到 ES5 的转码器 esnext, ES6 Module Transpiler：基于 node.js 的将 ES6 模块转为 ES5 代码的命令行工具 Sebastian McKenzie, BabelJS: ES6 转译器 SystemJS, SystemJS: 在浏览器中加载 AMD、CJS、ES6 模块的一个垫片库 Modernizr, HTML5 Cross Browser Polyfills: ES6 垫片库清单 Facebook, regenerator: 将 Generator 函数转为 ES5 的转码器 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "}}