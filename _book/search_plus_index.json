{"./":{"url":"./","title":"简介","keywords":"","body":"ES6 基础入门 以下内容多节选自 阮一峰 的 ES6 博客，本人摘抄了他的精髓，记录成册，与君共享 1. ECMAScript 和 JavaScript 的关系是 ​ 前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。 2. ES6 与 ECMAScript2015 的关系 ​ 2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。 ​ 但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。 ​ 但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。 ​ 标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。 ​ ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。 ​ 因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。 3. 查看 Node.js 默认没有打开的 ES6 实验性语法 // Linux & Mac $ node --v8-options | grep harmony // Windows $ node --v8-options | findstr harmony 4. Babel 转码器 Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。 // 转码前 input.map(item => item + 1); // 转码后 input.map(function (item) { return item + 1; }); 上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。 下面的命令在项目目录中，安装 Babel。 $ npm install --save-dev @babel/core 1. 配置文件 .babelrc Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。 该文件用来设置转码规则和插件，基本格式如下。 presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。 # 最新转码规则 $ npm install --save-dev @babel/preset-env # react 转码规则 $ npm install --save-dev @babel/preset-react 然后，将这些规则加入.babelrc。 { \"presets\": [ \"@babel/env\", \"@babel/preset-react\" ], \"plugins\": [] } 注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。 2. 命令行转码 Babel 提供命令行工具@babel/cli，用于命令行转码。 安装模块 $ npm install --save-dev @babel/cli 基本用法如下： # 转码结果输出到标准输出 $ npx babel example.js # 转码结果写入一个文件 # --out-file 或 -o 参数指定输出文件 $ npx babel example.js --out-file compiled.js # 或者 $ npx babel example.js -o compiled.js # 整个目录转码 # --out-dir 或 -d 参数指定输出目录 $ npx babel src --out-dir lib # 或者 $ npx babel src -d lib # -s 参数生成source map文件 $ npx babel src -d lib -s 3. babel-node @babel/node模块的babel-node命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。 安装模块 $ npm install --save-dev @babel/node 然后，执行babel-node就进入 REPL 环境。 $ npx babel-node > (x => x * 2)(1) 2 babel-node命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。 # es6.js 的代码 # console.log((x => x * 2)(1)); $ npx babel-node es6.js 2 4. babel/register 模块 @babel/register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 Babel 进行转码。 $ npm install --save-dev @babel/register 使用时，必须首先加载@babel/register。 // index.js require('@babel/register'); require('./es6.js') 然后，就不需要手动对index.js转码了。 $ node index.js 2 需要注意的是，@babel/register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。 5. babel API 如果某些代码需要调用 Babel 的 API 进行转码，就要使用@babel/core模块。 // 字符串转码 babel.transform('code();', options); // => { code, map, ast } // 文件转码（异步） babel.transformFile('filename.js', options, function(err, result) { result; // => { code, map, ast } }); // 文件转码（同步） babel.transformFileSync('filename.js', options); // => { code, map, ast } // Babel AST转码 babel.transformFromAst(ast, code, options); // => { code, map, ast } 配置对象options，可以参看官方文档http://babeljs.io/docs/usage/options/。 下面是一个例子。 var es6Code = 'let x = n => n + 1'; var es5Code = require('@babel/core') .transform(es6Code, { presets: ['@babel/env'] }) .code; console.log(es5Code); // '\"use strict\";\\n\\nvar x = function x(n) {\\n return n + 1;\\n};' 上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的 ES6 代码，第二个参数是转换的配置对象。 6. babel/polyfill Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。 安装命令如下: $ npm install --save-dev @babel/polyfill 然后，在脚本头部，加入如下一行代码。 import '@babel/polyfill'; // 或者 require('@babel/polyfill'); Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的definitions.js文件。 7. 浏览器环境 Babel 也可以用于浏览器环境，使用@babel/standalone模块提供的浏览器版本，将其插入网页。 // Your ES6 code 注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。 Babel 提供一个REPL 在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-24 23:53 "},"let-const.html":{"url":"let-const.html","title":"let 和 const 命令","keywords":"","body":"let 和 const 命令 1. let 命令 1.）基本用法 * ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 { let a = 10; var b = 1; } a // ReferenceError: a is not defined. b // 1 for循环的计数器，就很合适使用let命令。 for (let i = 0; i 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 var a = []; for (var i = 0; i 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。 var a = []; for (let i = 0; i 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 for (let i = 0; i 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 2）不存在变量提升 * var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; 3）暂时性死区 * 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 if (true) { // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123 } 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 typeof x; // ReferenceError let x; 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 typeof undeclared_variable // \"undefined\" 有些“死区”比较隐蔽，不太容易发现。 function bar(x = y, y = 2) { return [x, y]; } bar(); // 报错 Uncaught ReferenceError: Cannot access 'y' before initialization 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。 function bar(x = 2, y = x) { return [x, y]; } bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。 // 不报错 var x = x; // 报错 let x = x; // ReferenceError: x is not defined ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 4）不允许重复声明 * let不允许在相同作用域内，重复声明同一个变量。 // 报错 function func() { let a = 10; var a = 1; } // 报错 function func() { let a = 10; let a = 1; } 不能在函数内部重新声明参数。 function func(arg) { let arg; } func() // 报错 function func(arg) { { let arg; } } func() // 不报错 2. 块级作用域 1）为什么需要块级作用域 * ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 内层变量可能会覆盖外层变量。 var tmp = 'hello'; function f() { console.log(tmp); if (false) { var tmp = 'world'; } } f(); // undefined 用来计数的循环变量泄露为全局变量。 var tmp = 'hello'; for (var i = 0; i 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。 { {let insane = 'Hello World'} console.log(insane); // 报错 }; 内层作用域可以定义外层作用域的同名变量。 { let insane = 'Hello'; {let insane = 'World'} }; 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。 // IIFE 写法 (function () { var tmp = ...; ... }()); // 块级作用域写法 { let tmp = ...; ... } 2）块级作用域与函数声明 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 // 情况一 if (true) { function f() {} } // 情况二 try { function f() {} } catch(e) { // ... } 上面两种函数声明，根据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 function f() { console.log('I am outside!'); } (function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f(); }()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。 // ES5 环境 function f() { console.log('I am outside!'); } (function () { function f() { console.log('I am inside!'); } if (false) { } f(); }()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ // 浏览器的 ES6 环境 function f() { console.log('I am outside!'); } (function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f(); }()); // Uncaught TypeError: f is not a function ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。上面的例子实际运行的代码如下。 // 浏览器的 ES6 环境 function f() { console.log('I am outside!'); } (function () { var f = undefined; if (false) { function f() { console.log('I am inside!'); } } f(); }()); // Uncaught TypeError: f is not a function 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 // 块级作用域内部的函数声明语句，建议不要使用 { let a = 'secret'; function f() { return a; } } // 块级作用域内部，优先使用函数表达式 { let a = 'secret'; let f = function () { return a; }; } 另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。 // 第一种写法，报错 if (true) let x = 1; // 第二种写法，不报错 if (true) { let x = 1; } 函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。 // 不报错 'use strict'; if (true) { function f() {} } // 报错 'use strict'; if (true) function f() {} 3. const 命令 1）基本用法 * const声明一个只读的常量。一旦声明，常量的值就不能改变。 const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. const一旦声明变量，就必须立即初始化，不能留到以后赋值。只声明不赋值，就会报错。 const foo; // SyntaxError: Missing initializer in const declaration 除了不可改变值，其他用法和let相似 3）本质 * const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 const foo = {}; // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop // 123 // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: \"foo\" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 const a = []; a.push('Hello'); // 可执行 a.length = 0; // 可执行 a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果真的想将对象冻结，应该使用Object.freeze方法。 const foo = Object.freeze({}); // 常规模式时，下面一行不起作用； // 严格模式时，该行会报错 foo.prop = 123; 将对象彻底冻结的函数。 var constantize = (obj) => { Object.freeze(obj); Object.keys(obj).forEach( (key, i) => { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } }); }; 4. 顶层对象的属性 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 window.a = 1; a // 1 a = 2; window.a // 2 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题： 没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）。 程序员很容易不知不觉地就创建了全局变量（比如打字出错）。 顶层对象的属性是到处可以读写的，这非常不利于模块化编程。 window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性。 另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。 var a = 1; // 如果在 Node 的 REPL 环境，可以写成 global.a // 或者采用通用方法，写成 this.a window.a // 1 let b = 1; window.b // undefined 5. globalThis对象 * JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。 ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-27 23:48 "},"destructuring-assignment.html":{"url":"destructuring-assignment.html","title":"变量的解构赋值","keywords":"","body":"变量的解构赋值 重要知识点 ： 1. 交换变量的值 * let [x,y] = [1,2] [x,y] = [y,x] 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 2. 从函数返回多个值 * 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 // 返回一个数组,数组中取出多个对象 function example() { return [1, 2, 3]; } let [a, b, c] = example(); // 返回一个对象,对象中取出多个对象 function example() { return { foo: 1, bar: 2 }; } let { foo, bar } = example(); 3. 函数参数的定义 * 解构赋值可以方便地将一组参数与变量名对应起来。 // 参数是一组有次序的值 function f([x, y, z]) { ... } f([1, 2, 3]); // 参数是一组无次序的值 function f({x, y, z}) { ... } f({z: 3, y: 2, x: 1}); 4. 提取 JSON 数据 * 可以快速提取 JSON 数据的值。 let jsonData = { id: 42, status: \"OK\", data: [867, 5309] }; let { id, status, data: number } = jsonData; console.log(id, status, number); // 42, \"OK\", [867, 5309] 5. 函数参数的默认值 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。 const fn = function({x='hello',y='world'}={}){ ... } 6. 遍历 Map 结构 * 任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 const map = new Map(); map.set('first', 'hello'); map.set('second', 'world'); for (let [key, value] of map) { console.log(key + \" is \" + value); } // first is hello // second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 // 获取键名 for (let [key] of map) { // ... } // 获取键值 for (let [,value] of map) { // ... } 7. 引入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 const { SourceMapConsumer, SourceNode } = require(\"source-map\"); Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-24 23:53 "},"string-extend.html":{"url":"string-extend.html","title":"字符串的扩展","keywords":"","body":"字符串的扩展 1. 字符串的遍历接口 for (let codePoint of 'foo') { console.log(codePoint) } // \"f\" // \"o\" // \"o\" 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 let text = String.fromCodePoint(0x20BB7); for (let i = 0; i 2. 直接输入 U+2028 和 U+2029 JavaScript 字符串允许直接输入字符，以及输入字符的转义形式（Unicode编码） JavaScript 规定有3个字符，不能在字符串里面直接使用，只能使用转义形式。 U+005C：反斜杠（reverse solidus) U+000D：回车（carriage return） U+000A：换行符（line feed） 3. 模板字符串 * 传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。 $('#result').append( 'There are ' + basket.count + ' ' + 'items in your basket, ' + '' + basket.onSale + ' are on sale!' ); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 $('#result').append(` There are ${basket.count} items in your basket, ${basket.onSale} are on sale! `); 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 let greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 $('#list').html(` first second `); 模板字符串中嵌入变量，需要将变量名写在${}之中。 `User ${user.name} is not authorized to do ${action}.` 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 let x = 1; let y = 2; `${x} + ${y} = ${x + y}` // \"1 + 2 = 3\" `${x} + ${y * 2} = ${x + y * 2}` // \"1 + 4 = 5\" let obj = {x: 1, y: 2}; `${obj.x + obj.y}` // \"3\" 模板字符串之中还能调用函数。 function fn() { return \"Hello World\"; } `foo ${fn()} bar` // foo Hello World bar 模板字符串甚至还能嵌套。 const tmpl = addrs => ` ${addrs.map(addr => ` ${addr.first} ${addr.last} `).join('')} `; 4. 标签模板 它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 alert`hello` // 等同于 alert(['hello']) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 let a = 5; let b = 10; tag`Hello ${ a + b } world ${ a * b }`; // 等同于 tag(['Hello ', ' world ', ''], 15, 50); “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 let message = SaferHTML`${sender} has sent you a message.`; function SaferHTML(templateData) { let s = templateData[0]; for (let i = 1; i /g, \"&gt;\"); // Don't escape special characters in the template. s += templateData[i]; } return s; } 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 let sender = 'alert(\"abc\")'; // 恶意代码 let message = SaferHTML`${sender} has sent you a message.`; message // &lt;script&gt;alert(\"abc\")&lt;/script&gt; has sent you a message. 标签模板的另一个应用，就是多语言转换（国际化处理）。 i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!` // \"欢迎访问xxx，您是第xxxx位访问者！\" Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-25 23:45 "},"string-new-method.html":{"url":"string-new-method.html","title":"字符串的新增方法","keywords":"","body":"字符串的新增方法 1. includes(), startsWith(), endsWith() 传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 let s = 'Hello world!'; s.startsWith('Hello') // true s.endsWith('!') // true s.includes('o') // true 这三个方法都支持第二个参数，表示开始搜索的位置。 let s = 'Hello world!'; s.startsWith('world', 6) // true s.endsWith('Hello', 5) // true s.includes('Hello', 6) // false 使用第二个参数n时 endsWith针对前n个字符 startsWith针对从第n个位置直到字符串结束。 includes针对从第n个位置直到字符串结束。 2. repeat() repeat方法返回一个新字符串，表示将原字符串重复n次。 'x'.repeat(3) // \"xxx\" 'hello'.repeat(2) // \"hellohello\" 'na'.repeat(0) // \"\" 参数如果是小数，会被向下取整。 'na'.repeat(2.9) // \"nana\" 如果repeat的参数是负数或者Infinity，会报错。 'na'.repeat(Infinity) // RangeError 'na'.repeat(-1) // RangeError 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。 'na'.repeat(-0.9) // \"\" 参数NaN等同于 0。 'na'.repeat(NaN) // \"\" 如果repeat的参数是字符串，则会返回空字符串。 'na'.repeat('sdg') // \"\" 3. padStart(), padEnd() ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 'x'.padStart(5, 'ab') // 'ababx' 'x'.padStart(4, 'ab') // 'abax' 'x'.padEnd(5, 'ab') // 'xabab' 'x'.padEnd(4, 'ab') // 'xaba' padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。 'xxx'.padStart(2, 'ab') // 'xxx' 'xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。 'abc'.padStart(10, '0123456789') // '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 'x'.padStart(4) // ' x' 'x'.padEnd(4) // 'x ' padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 '1'.padStart(10, '0') // \"0000000001\" '12'.padStart(10, '0') // \"0000000012\" 另一个用途是提示字符串格式。 '12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\" '09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\" 4. trimStart(), trimEnd() ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。 const s = ' abc '; s.trim() // \"abc\" s.trimStart() // \"abc \" s.trimEnd() // \" abc\" 除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-25 23:51 "},"RegExp-extend.html":{"url":"RegExp-extend.html","title":"正则的扩展","keywords":"","body":"正则的扩展 1. RegExp 构造函数 * 在 ES5 中，RegExp构造函数的参数有两种情况。 第一种情况是，第一个参数是字符串，第二个参数是正则表达式的修饰符（flag）。 var regex = new RegExp('xyz', 'i'); // 等价于 var regex = /xyz/i; 第二种情况是，只有一个参数，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 var regex = new RegExp(/xyz/i); // 等价于 var regex = /xyz/i; 但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。 var regex = new RegExp(/xyz/, 'i'); // Uncaught TypeError: Cannot supply flags when constructing one RegExp from another 在ES6中，第一个参数是正则表示式，第二个参数可以使用修饰符（flag），返回的正则表达式会忽略原有的修饰符，使用第二个参数给的修饰符 new RegExp(/abc/ig, 'i').flags // \"i\" 2. 字符串的正则表达式 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] 3. RegExp.prototype.flags 属性 ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 // ES5 的 source 属性 // 返回正则表达式的正文 /abc/ig.source // \"abc\" // ES6 的 flags 属性 // 返回正则表达式的修饰符 /abc/sigu.flags // 'gi' 4. 具名组匹配 * 正则表达式使用圆括号进行组匹配。使用exec方法，就可以将这三组匹配结果提取出来。 const RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/; const matchObj = RE_DATE.exec('1999-12-31'); const year = matchObj[1]; // 1999 const month = matchObj[2]; // 12 const day = matchObj[3]; // 31 组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。 ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。同时，数字序号（matchObj[1]）依然有效。 const RE_DATE = /(?\\d{4})-(?\\d{2})-(?\\d{2})/; const matchObj = RE_DATE.exec('1999-12-31'); const year = matchObj.groups.year; // 1999 const month = matchObj.groups.month; // 12 const day = matchObj.groups.day; // 31 如果具名组没有匹配，那么对应的groups对象属性会是undefined。 const RE_OPT_A = /^(?a+)?$/; const matchObj = RE_OPT_A.exec(''); matchObj.groups.as // undefined 'as' in matchObj.groups // true 5. 解构赋值和替换 * 有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。 let {groups: {one, two}} = /^(?.*):(?.*)$/u.exec('foo:bar'); one // foo two // bar 字符串替换时，使用$引用具名组。 let re = /(?\\d{4})-(?\\d{2})-(?\\d{2})/u; '2015-01-02'.replace(re, '$/$/$') // '02/01/2015' 上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。 replace方法的第二个参数也可以是函数，该函数的参数序列如下。 '2015-01-02'.replace(re, ( matched, // 整个匹配结果 2015-01-02 capture1, // 第一个组匹配 2015 capture2, // 第二个组匹配 01 capture3, // 第三个组匹配 02 position, // 匹配开始的位置 0 S, // 原字符串 2015-01-02 groups // 具名组构成的一个对象 {year, month, day} ) => { let {day, month, year} = groups; return `${day}/${month}/${year}`; }); 6. 引用 如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k的写法。 const RE_TWICE = /^(?[a-z]+)!\\k$/; RE_TWICE.test('abc!abc') // true RE_TWICE.test('abc!ab') // false 数字引用（\\1）依然有效。 const RE_TWICE = /^(?[a-z]+)!\\1$/; RE_TWICE.test('abc!abc') // true RE_TWICE.test('abc!ab') // false 这两种引用语法还可以同时使用。 const RE_TWICE = /^(?[a-z]+)!\\k!\\1$/; RE_TWICE.test('abc!abc!abc') // true RE_TWICE.test('abc!abc!ab') // false 7. String.prototype.matchAll() * ES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 const string = 'test1test2test3'; // g 修饰符加不加都可以 const regex = /t(e)(st(\\d?))/g; for (const match of string.matchAll(regex)) { console.log(match); } // [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"] // [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"] // [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"] 上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for...of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。 遍历器转为数组是非常简单的，使用...运算符和Array.from()方法就可以了。 // 转为数组方法一 [...string.matchAll(regex)] // 转为数组方法二 Array.from(string.matchAll(regex)) Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-25 23:45 "},"number-extend.html":{"url":"number-extend.html","title":"数值的扩展","keywords":"","body":"数值的扩展 1. 二进制和八进制的写法 ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 0b111110111 === 503 // true 0o767 === 503 // true 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 Number('0b111') // 7 Number('0o10') // 8 2. Number.isFinite(), Number.isNaN() * Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。 如果参数类型不是数值，Number.isFinite一律返回false。 Number.isFinite(15); // true Number.isFinite(0.8); // true Number.isFinite(NaN); // false Number.isFinite(Infinity); // false Number.isFinite(-Infinity); // false Number.isFinite('foo'); // false Number.isFinite('15'); // false Number.isFinite(true); // false Number.isNaN()用来检查一个值是否为NaN。 如果参数类型不是NaN，Number.isNaN()一律返回false。 Number.isNaN(NaN) // true Number.isNaN(15) // false Number.isNaN('15') // false Number.isNaN(true) // false Number.isNaN(9/NaN) // true Number.isNaN('true' / 0) // true Number.isNaN('true' / 'true') // true 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 isFinite(25) // true isFinite(\"25\") // true Number.isFinite(25) // true Number.isFinite(\"25\") // false isNaN(NaN) // true isNaN(\"NaN\") // true Number.isNaN(NaN) // true Number.isNaN(\"NaN\") // false 3. Number.parseInt(), Number,parseFloat() * // ES5的写法 parseInt('12.34') // 12 parseFloat('123.45#') // 123.45 // ES6的写法 Number.parseInt('12.34') // 12 Number.parseFloat('123.45#') // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 Number.parseInt === parseInt // true Number.parseFloat === parseFloat // true 4. Number.isInterger() * Number.isInteger()用来判断一个数值是否为整数。 Number.isInteger(25) // true Number.isInteger(25.1) // false JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。 Number.isInteger(25) // true Number.isInteger(25.0) // true 如果参数不是数值，Number.isInteger返回false。 Number.isInteger() // false Number.isInteger(null) // false Number.isInteger('15') // false Number.isInteger(true) // false 注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。 Number.isInteger(3.0000000000000002) // true 5. Number.EPSILON * ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。 对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。 Number.EPSILON === Math.pow(2, -52) // true Number.EPSILON // 2.220446049250313e-16 Number.EPSILON.toFixed(20) // \"0.00000000000000022204\" Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。 0.1 + 0.2 // 0.30000000000000004 0.1 + 0.2 - 0.3 // 5.551115123125783e-17 5.551115123125783e-17.toFixed(20) // '0.00000000000000005551' 上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。 0.1 + 0.2 === 0.3 // false Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。 5.551115123125783e-17 因此，Number.EPSILON的实质是一个可以接受的最小误差范围。 function withinErrorMargin (left, right) { return Math.abs(left - right) 上面的代码为浮点数运算，部署了一个误差检查函数。 6. Math.trunc() * Math.trunc方法用于去除一个数的小数部分，返回整数部分。 Math.trunc(4.1) // 4 Math.trunc(4.9) // 4 Math.trunc(-4.1) // -4 Math.trunc(-4.9) // -4 Math.trunc(-0.1234) // -0 对于非数值，Math.trunc内部使用Number方法将其先转为数值。 Math.trunc('123.456') // 123 Math.trunc(true) //1 Math.trunc(false) // 0 Math.trunc(null) // 0 对于空值和无法截取整数的值，返回NaN。 Math.trunc(NaN); // NaN Math.trunc('foo'); // NaN Math.trunc('1w'); // NaN Math.trunc(); // NaN Math.trunc(undefined) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 Math.trunc = Math.trunc || function(x) { return x 7. Math.sign() Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 它会返回五种值。 参数为正数，返回+1； 参数为负数，返回-1； 参数为 0，返回0； 参数为-0，返回-0; 其他数值，返回NaN。 如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。 Math.sign('') // 0 Math.sign(true) // +1 Math.sign(false) // 0 Math.sign(null) // 0 Math.sign('9') // +1 Math.sign('foo') // NaN Math.sign() // NaN Math.sign(undefined) // NaN 8. Math.cbrt() Math.cbrt方法用于计算一个数的立方根。 Math.cbrt(-1) // -1 Math.cbrt(0) // 0 Math.cbrt(1) // 1 Math.cbrt(2) // 1.2599210498948734 对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。 Math.cbrt('8') // 2 Math.cbrt('hello') // NaN 9. Math.hypot() Math.hypot方法返回所有参数的平方和的平方根。 如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。 Math.hypot(3, 4); // 5 Math.hypot(3, 4, 5); // 7.0710678118654755 Math.hypot(); // 0 Math.hypot(NaN); // NaN Math.hypot(3, 4, 'foo'); // NaN Math.hypot(3, 4, '5'); // 7.0710678118654755 Math.hypot(-3); // 3 10. 指数运算符 ** ES2016 新增了一个指数运算符（**）。 2 ** 2 // 4 2 ** 3 // 8 这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。 // 相当于 2 ** (3 ** 2) 2 ** 3 ** 2 // 512 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。 let a = 1.5; a **= 2; // 等同于 a = a * a; let b = 4; b **= 3; // 等同于 b = b * b * b; Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-26 23:57 "},"function-extend.html":{"url":"function-extend.html","title":"函数的扩展","keywords":"","body":"函数的扩展 1. 函数参数的默认值 * 1）基本用法 ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 function log(x, y) { y = y || 'World'; console.log(x, y); } log('Hello') // Hello World log('Hello', 'China') // Hello China log('Hello', '') // Hello World 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。 if (typeof y === 'undefined') { y = 'World'; } ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 function log(x, y = 'World') { console.log(x, y); } log('Hello') // Hello World log('Hello', 'China') // Hello China log('Hello', '') // Hello 参数变量是默认声明的，所以不能用let或const再次声明。 function foo(x = 5) { let x = 1; // error } 2）与结构赋值默认值的结合使用 参数默认值可以与解构赋值的默认值，结合起来使用。 function foo({x, y = 5}) { console.log(x, y); } foo({}) // undefined 5 foo({x: 1}) // 1 5 foo({x: 1, y: 2}) // 1 2 foo() // TypeError: Cannot read property 'x' of undefined function fetch(url, { body = '', method = 'GET', headers = {} } = {}) { console.log(method); } fetch('http://example.com') // \"GET\" 上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET 请问下面两种写法有什么差别？ // 写法一 function m1({x = 0, y = 0} = {}) { return [x, y]; } // 写法二 function m2({x, y} = { x: 0, y: 0 }) { return [x, y]; } 上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。 // 函数没有参数的情况 m1() // [0, 0] m2() // [0, 0] // x 和 y 都有值的情况 m1({x: 3, y: 8}) // [3, 8] m2({x: 3, y: 8}) // [3, 8] // x 有值，y 无值的情况 m1({x: 3}) // [3, 0] m2({x: 3}) // [3, undefined] // x 和 y 都无值的情况 m1({}) // [0, 0]; m2({}) // [undefined, undefined] m1({z: 3}) // [0, 0] m2({z: 3}) // [undefined, undefined] 3）参数默认值的位置 通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 // 例一 function f(x = 1, y) { return [x, y]; } f() // [1, undefined] f(2) // [2, undefined]) f(, 1) // 报错 f(undefined, 1) // [1, 1] // 例二 function f(x, y = 5, z) { return [x, y, z]; } f() // [undefined, 5, undefined] f(1) // [1, 5, undefined] f(1, ,2) // 报错 f(1, undefined, 2) // [1, 5, 2] 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 function foo(x = 5, y = 6) { console.log(x, y); } foo(undefined, null) // 5 null 4）函数的length属性 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数 (function (a) {}).length // 1 (function (a = 5) {}).length // 0 (function (a, b, c = 5) {}).length // 2 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。 (function(...args) {}).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 (function (a = 0, b, c) {}).length // 0 (function (a, b = 1, c) {}).length // 1 5）作用域 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 var x = 1; function f(x, y = x) { console.log(y); } f(2) // 2 上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。 let x = 1; function f(y = x) { let x = 2; console.log(y); } f() // 1 上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。 如果此时，全局变量x不存在，就会报错。 function f(y = x) { let x = 2; console.log(y); } f() // ReferenceError: x is not defined 上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。 如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。 let foo = 'outer'; function bar(func = () => foo) { let foo = 'inner'; console.log(func()); } bar(); // outer 6）应用 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 function throwIfMissing() { throw new Error('Missing parameter'); } function foo(mustBeProvided = throwIfMissing()) { return mustBeProvided; } foo() // Error: Missing parameter 也可以将参数默认值设为undefined，表明这个参数是可以省略的。 function foo(optional = undefined) { ··· } 2. reset 参数 ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 function add(...values) { let sum = 0; for (var val of values) { sum += val; } return sum; } add(2, 5, 3) // 10 上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。 下面是一个 rest 参数代替arguments变量的例子。 // arguments变量的写法 function sortNumbers() { return Array.prototype.slice.call(arguments).sort(); } // rest参数的写法 const sortNumbers = (...numbers) => numbers.sort(); arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组 下面是一个利用 rest 参数改写数组push方法的例子。 function push(array, ...items) { items.forEach(function(item) { array.push(item); console.log(item); }); } var a = []; push(a, 1, 2, 3) 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 // 报错 function f(a, ...b, c) { // ... } 函数的length属性，不包括 rest 参数。 (function(a) {}).length // 1 (function(...a) {}).length // 0 (function(a, ...b) {}).length // 1 3. 严格模式 从 ES5 开始，函数内部可以设定为严格模式。 function doSomething(a, b) { 'use strict'; // code } ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 // 报错 function doSomething(a, b = a) { 'use strict'; // code } // 报错 const doSomething = function ({a, b}) { 'use strict'; // code }; // 报错 const doSomething = (...a) => { 'use strict'; // code }; const obj = { // 报错 doSomething({a, b}) { 'use strict'; // code } }; 两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。 'use strict'; function doSomething(a, b = a) { // code } 第二种是把函数包在一个无参数的立即执行函数里面。 const doSomething = (function () { 'use strict'; return function(value = 42) { return value; }; }()); 4. name属性 函数的name属性，返回该函数的函数名。 function foo() {} foo.name // \"foo\" Function构造函数返回的函数实例，name属性的值为anonymous。 (new Function).name // \"anonymous\" 5. 箭头函数 * 1）基本用法 var f = v => v; // 等同于 var f = function (v) { return v; }; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 var f = () => 5; // 等同于 var f = function () { return 5 }; var sum = (num1, num2) => num1 + num2; // 等同于 var sum = function(num1, num2) { return num1 + num2; }; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 var sum = (num1, num2) => { if(true){ return num1 + num2; } } 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 // 报错 let getTempItem = id => { id: id, name: \"Temp\" }; // 不报错 let getTempItem = id => ({ id: id, name: \"Temp\" }); 如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。 let fn = () => void doesNotReturn(); 箭头函数可以与变量解构结合使用。 const full = ({ first, last }) => first + ' ' + last; 箭头函数使得表达更加简洁。 const isEven = n => n % 2 === 0; const square = n => n * n; 箭头函数的一个用处是简化回调函数。 // 正常函数写法 [1,2,3].map(function (x) { return x * x; }); // 箭头函数写法 [1,2,3].map(x => x * x); // 正常函数写法 var result = values.sort(function (a, b) { return a - b; }); // 箭头函数写法 var result = values.sort((a, b) => a - b); 下面是 rest 参数与箭头函数结合的例子。 const numbers = (...nums) => nums; numbers(1, 2, 3, 4, 5) // [1,2,3,4,5] const headAndTail = (head, ...tail) => [head, tail]; headAndTail(1, 2, 3, 4, 5) // [1,[2,3,4,5]] 2）使用注意点 * 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 this对象的指向是可变的，但是在箭头函数中，它是固定的。 function foo() { setTimeout(() => { console.log('id:', this.id); }, 100); } var id = 21; foo.call({ id: 42 }); // id: 42 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。 function Timer() { this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() => this.s1++, 1000); // 普通函数 setInterval(function () { this.s2++; }, 1000); } var timer = new Timer(); setTimeout(() => console.log('s1: ', timer.s1), 3100); setTimeout(() => console.log('s2: ', timer.s2), 3100); // s1: 3 // s2: 0 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 箭头函数转成 ES5 的代码如下。 // ES6 function foo() { setTimeout(() => { console.log('id:', this.id); }, 100); } // ES5 function foo() { var _this = this; setTimeout(function () { console.log('id:', _this.id); }, 100); } 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 function foo() { setTimeout(() => { console.log('args:', arguments); }, 100); } foo(2, 4, 6, 8) // args: [2, 4, 6, 8] 由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 (function() { return [ (() => this.x).bind({ x: 'inner' })() ]; }).call({ x: 'outer' }); // ['outer'] 3）不适用场合 * 定义对象的方法时使用箭头函数，且该方法内部包括this，以下是错误示范 const cat = { lives: 9, jumps: () => { this.lives--; } } cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致jumps箭头函数定义时的作用域就是全局作用域。 需要动态this的时候，也不应使用箭头函数。 var button = document.getElementById('press'); button.addEventListener('click', () => { this.classList.toggle('on'); }); 上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。 另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。 6. 尾调用优化 1）什么是尾调用 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 function f(x){ return g(x); } 函数f的最后一步是调用函数g，这就叫尾调用。 以下三种情况，都不属于尾调用。 // 情况一 function f(x){ let y = g(x); return y; } // 情况二 function f(x){ return g(x) + 1; } // 情况三 function f(x){ g(x); } 情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。函数无返回值默认返回 undefined function f(x){ g(x); return undefined; } 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 function f(x) { if (x > 0) { return m(x) } return n(x); } 函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 2）尾调用优化 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 function f() { let m = 1; let n = 2; return g(m + n); } f(); // 等同于 function f() { return g(3); } f(); // 等同于 g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 3）尾递归 * 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1); } factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5, 1) // 120 4）递归函数的改写 * 柯里化 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，两个方法可以解决这个问题 在尾递归函数之外，再提供一个正常形式的函数。 function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total); } function factorial(n) { return tailFactorial(n, 1); } factorial(5) // 120 上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 就是采用 ES6 的函数默认值，这种就简单多了 function factorial(n, total = 1) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5) // 120 5）严格模式 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。 function restricted() { 'use strict'; restricted.caller; // 报错 restricted.arguments; // 报错 } restricted(); 6）尾递归优化的实现 * 蹦床函数 尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 下面是一个正常的递归函数。 function sum(x, y) { if (y > 0) { return sum(x + 1, y - 1); } else { return x; } } sum(1, 100000) // Uncaught RangeError: Maximum call stack size exceeded(…) 蹦床函数（trampoline）可以将递归执行转为循环执行。 function trampoline(f) { while (f && f instanceof Function) { f = f(); } return f; } 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。 function sum(x, y) { if (y > 0) { return sum.bind(null, x + 1, y - 1); } else { return x; } } trampoline(sum(1, 100000)) // 100001 上面代码中，sum函数的每次执行，都会返回自身的另一个版本，使用蹦床函数执行sum，就不会发生调用栈溢出。 蹦床函数并不是真正的尾递归优化，下面的实现才是。 function tco(f) { var value; var active = false; var accumulated = []; return function accumulator() { accumulated.push(arguments); if (!active) { active = true; while (accumulated.length) { value = f.apply(this, accumulated.shift()); } active = false; return value; } }; } var sum = tco(function(x, y) { if (y > 0) { return sum(x + 1, y - 1) } else { return x } }); sum(1, 100000) // 100001 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。 7. 函数参数的尾逗号 ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。 function a( x, y ){ ... } a( 'xxx', 'yyy' ) 如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数a添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。因此新的语法规定定义和调用函数时，尾部允许有逗号 function a( x, y, ){ ... } a( 'xxx', 'yyy', ) 这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。 8. Function.prototype.toString() ES2019 对函数实例的toString()方法做出了修改。 toString()方法返回函数代码本身，以前会省略注释和空格。 修改前 function /* foo comment */ foo () {} foo.toString() // function foo() {} 修改后的写法 function /* foo comment */ foo () {} foo.toString() // \"function /* foo comment */ foo () {}\" 9. catch 命令的参数省略 JavaScript 语言的try...catch结构，以前明确要求catch命令后面必须跟参数，接受try代码块抛出的错误对象 try { // ... } catch (err) { // 处理错误 } 上面代码中，catch命令后面带有参数err。 很多时候，catch代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。ES2019 做出了改变，允许catch语句省略参数。 try { // ... } catch { // ... } Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-27 23:48 "},"array-extend.html":{"url":"array-extend.html","title":"数组的扩展","keywords":"","body":"数组的扩展 1. 扩展运算符 1）含义 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 console.log(...[1, 2, 3]) // 1 2 3 console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5 扩展运算符后面还可以放置表达式。 const arr = [ ...(x > 0 ? ['a'] : []), 'b', ]; 如果扩展运算符后面是一个空数组，则不产生任何效果。 [...[], 1] // [1] 注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。 (...[1, 2]) // Uncaught SyntaxError: Unexpected number console.log((...[1, 2])) // Uncaught SyntaxError: Unexpected number console.log(...[1, 2]) // 1 2 2）替代函数的 apply 方法 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。 // ES5 的写法 function f(x, y, z) { // ... } var args = [0, 1, 2]; f.apply(null, args); // ES6的写法 function f(x, y, z) { // ... } let args = [0, 1, 2]; f(...args); 通过push函数，将一个数组添加到另一个数组的尾部。 // ES5的 写法 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; Array.prototype.push.apply(arr1, arr2); // ES6 的写法 let arr1 = [0, 1, 2]; let arr2 = [3, 4, 5]; arr1.push(...arr2); 上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。 3）扩展运算符的应用 * （1）复制数组 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。 const a1 = [1, 2]; const a2 = a1; a2[0] = 2; a1 // [2, 2] ES5 只能用变通方法来复制数组。 const a1 = [1, 2]; const a2 = a1.concat(); a2[0] = 2; a1 // [1, 2] 扩展运算符提供了复制数组的简便写法。 const a1 = [1, 2]; // 写法一,这种写法较为常用 const a2 = [...a1]; // 写法二 const [...a2] = a1; （2）合并数组 扩展运算符提供了数组合并的新写法。 const arr1 = ['a', 'b']; const arr2 = ['c']; const arr3 = ['d', 'e']; // ES5 的合并数组 arr1.concat(arr2, arr3); // [ 'a', 'b', 'c', 'd', 'e' ] // ES6 的合并数组 [...arr1, ...arr2, ...arr3] // [ 'a', 'b', 'c', 'd', 'e' ] 不过，这两种方法都是浅拷贝，使用的时候需要注意。 const a1 = [{ foo: 1 }]; const a2 = [{ bar: 2 }]; const a3 = a1.concat(a2); const a4 = [...a1, ...a2]; a3[0] === a1[0] // true a4[0] === a1[0] // true 上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。 （3）与结构赋值结合 扩展运算符可以与解构赋值结合起来，用于生成数组。 // ES5 a = list[0], rest = list.slice(1) // ES6 [a, ...rest] = list const [first, ...rest] = [1, 2, 3, 4, 5]; first // 1 rest // [2, 3, 4, 5] const [first, ...rest] = []; first // undefined rest // [] const [first, ...rest] = [\"foo\"]; first // \"foo\" rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 const [...butLast, last] = [1, 2, 3, 4, 5]; // 报错 const [first, ...middle, last] = [1, 2, 3, 4, 5]; // 报错 （4）字符串 扩展运算符还可以将字符串转为真正的数组。 [...'hello'] // [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。 'x\\uD83D\\uDE80y'.length // 4 [...'x\\uD83D\\uDE80y'].length // 3 （5）实现了 Iterator 接口的对象 任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。 let nodeList = document.querySelectorAll('div'); let array = [...nodeList]; 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。 let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3 }; // TypeError: Cannot spread non-iterable object. let arr = [...arrayLike]; 上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 （6）Map 和 Set 结构， Generator函数 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。 let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'], ]); let arr = [...map.keys()]; // [1, 2, 3] Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 const go = function*(){ yield 1; yield 2; yield 3; }; [...go()] // [1, 2, 3] 2. Array.from() 1）含义 Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 2）用法 把一个类似数组的对象，Array.from将它转为真正的数组。 let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3 }; // ES5的写法 var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c'] // ES6的写法 let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 // NodeList对象 let ps = document.querySelectorAll('p'); Array.from(ps).filter(p => { return p.textContent.length > 100; }); // arguments对象 function foo() { var args = Array.from(arguments); // ... } 只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。 Array.from('hello') // ['h', 'e', 'l', 'l', 'o'] let namesSet = new Set(['a', 'b']) Array.from(namesSet) // ['a', 'b'] 参数是一个真正的数组，Array.from会返回一个一模一样的新数组。 Array.from([1, 2, 3]) // [1, 2, 3] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 Array.from({ length: 3 }); // [ undefined, undefined, undefined ] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 Array.from(arrayLike, x => x * x); // 等同于 Array.from(arrayLike).map(x => x * x); Array.from([1, 2, 3], (x) => x * x) // [1, 4, 9] 将数组中布尔值为false的成员转为0。 Array.from([1, , 2, , 3], (n) => n || 0) // [1, 0, 2, 0, 3] 返回各种数据的类型。 function typesOf () { return Array.from(arguments, value => typeof value) } typesOf(null, [], NaN) // ['object', 'object', 'number'] 3）模拟实现 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 const toArray = (() => Array.from ? Array.from : obj => [].slice.call(obj) )(); 3. Array.of() 1） 含义 Array.of方法用于将一组值，转换为数组。 Array.of(3, 11, 8) // [3,11,8] Array.of(3) // [3] Array.of(3).length // 1 2）用法 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 Array() // [] Array(3) // [, , ,] Array(3, 11, 8) // [3, 11, 8] 只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 3）模拟实现 Array.of方法可以用下面的代码模拟实现。 function ArrayOf(){ return [].slice.call(arguments); } 4. 数组实例的 copyWith() 1）含义 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 2）用法 它接受三个参数。 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。 这三个参数都应该是数值，如果不是，会自动转为数值。 [1, 2, 3, 4, 5,6,7,8].copyWithin(0, 3) // [4, 5, 6, 7, 8, 6, 7, 8] // 将3号位复制到0号位 [1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5] // -2相当于3号位，-1相当于4号位 [1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5] 5. 数组实例的 find() 和 findIndex() 1）find 含义 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 [1, 4, -5, 10].find((n) => n 2）find 用法 find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 [1, 5, 10, 15].find(function(value, index, arr) { return value > 9; }) // 10 3）findIndex 含义 返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 [1, 5, 10, 15].findIndex(function(value, index, arr) { return value > 9; }) // 2 4）用法 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 function f(v){ return v > this.age; } let person = {name: 'John', age: 20}; [10, 12, 26, 15].find(f, person); // 26 这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。 [NaN].indexOf(NaN) // -1 [NaN].findIndex(y => Object.is(NaN, y)) // 0 indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。 6. 数组实例的 fill() Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-27 23:48 "},"object-extend.html":{"url":"object-extend.html","title":"对象的扩展","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-27 23:48 "},"object-new-method.html":{"url":"object-new-method.html","title":"对象的新增方法","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-27 23:48 "}}