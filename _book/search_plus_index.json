{"./":{"url":"./","title":"简介","keywords":"","body":"ES6 基础入门 以下内容多节选自 阮一峰 的 ES6 博客，本人摘抄了他的精髓，记录成册，与君共享 1. ECMAScript 和 JavaScript 的关系是 ​ 前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。 2. ES6 与 ECMAScript2015 的关系 ​ 2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。 ​ 但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。 ​ 但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。 ​ 标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。 ​ ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。 ​ 因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。 3. 查看 Node.js 默认没有打开的 ES6 实验性语法 // Linux & Mac $ node --v8-options | grep harmony // Windows $ node --v8-options | findstr harmony 4. Babel 转码器 Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。 // 转码前 input.map(item => item + 1); // 转码后 input.map(function (item) { return item + 1; }); 上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。 下面的命令在项目目录中，安装 Babel。 $ npm install --save-dev @babel/core 1. 配置文件 .babelrc Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。 该文件用来设置转码规则和插件，基本格式如下。 presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。 # 最新转码规则 $ npm install --save-dev @babel/preset-env # react 转码规则 $ npm install --save-dev @babel/preset-react 然后，将这些规则加入.babelrc。 { \"presets\": [ \"@babel/env\", \"@babel/preset-react\" ], \"plugins\": [] } 注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。 2. 命令行转码 Babel 提供命令行工具@babel/cli，用于命令行转码。 安装模块 $ npm install --save-dev @babel/cli 基本用法如下： # 转码结果输出到标准输出 $ npx babel example.js # 转码结果写入一个文件 # --out-file 或 -o 参数指定输出文件 $ npx babel example.js --out-file compiled.js # 或者 $ npx babel example.js -o compiled.js # 整个目录转码 # --out-dir 或 -d 参数指定输出目录 $ npx babel src --out-dir lib # 或者 $ npx babel src -d lib # -s 参数生成source map文件 $ npx babel src -d lib -s 3. babel-node @babel/node模块的babel-node命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。 安装模块 $ npm install --save-dev @babel/node 然后，执行babel-node就进入 REPL 环境。 $ npx babel-node > (x => x * 2)(1) 2 babel-node命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。 # es6.js 的代码 # console.log((x => x * 2)(1)); $ npx babel-node es6.js 2 4. babel/register 模块 @babel/register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 Babel 进行转码。 $ npm install --save-dev @babel/register 使用时，必须首先加载@babel/register。 // index.js require('@babel/register'); require('./es6.js') 然后，就不需要手动对index.js转码了。 $ node index.js 2 需要注意的是，@babel/register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。 5. babel API 如果某些代码需要调用 Babel 的 API 进行转码，就要使用@babel/core模块。 // 字符串转码 babel.transform('code();', options); // => { code, map, ast } // 文件转码（异步） babel.transformFile('filename.js', options, function(err, result) { result; // => { code, map, ast } }); // 文件转码（同步） babel.transformFileSync('filename.js', options); // => { code, map, ast } // Babel AST转码 babel.transformFromAst(ast, code, options); // => { code, map, ast } 配置对象options，可以参看官方文档http://babeljs.io/docs/usage/options/。 下面是一个例子。 var es6Code = 'let x = n => n + 1'; var es5Code = require('@babel/core') .transform(es6Code, { presets: ['@babel/env'] }) .code; console.log(es5Code); // '\"use strict\";\\n\\nvar x = function x(n) {\\n return n + 1;\\n};' 上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的 ES6 代码，第二个参数是转换的配置对象。 6. babel/polyfill Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。 安装命令如下: $ npm install --save-dev @babel/polyfill 然后，在脚本头部，加入如下一行代码。 import '@babel/polyfill'; // 或者 require('@babel/polyfill'); Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的definitions.js文件。 7. 浏览器环境 Babel 也可以用于浏览器环境，使用@babel/standalone模块提供的浏览器版本，将其插入网页。 // Your ES6 code 注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。 Babel 提供一个REPL 在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-24 23:53 "},"let-const.html":{"url":"let-const.html","title":"let 和 const 命令","keywords":"","body":"let 和 const 命令 1. let 命令 1.）基本用法 * ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 { let a = 10; var b = 1; } a // ReferenceError: a is not defined. b // 1 for循环的计数器，就很合适使用let命令。 for (let i = 0; i 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 var a = []; for (var i = 0; i 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。 var a = []; for (let i = 0; i 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 for (let i = 0; i 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 2）不存在变量提升 * var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; 3）暂时性死区 * 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 if (true) { // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123 } 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 typeof x; // ReferenceError let x; 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 typeof undeclared_variable // \"undefined\" 有些“死区”比较隐蔽，不太容易发现。 function bar(x = y, y = 2) { return [x, y]; } bar(); // 报错 Uncaught ReferenceError: Cannot access 'y' before initialization 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。 function bar(x = 2, y = x) { return [x, y]; } bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。 // 不报错 var x = x; // 报错 let x = x; // ReferenceError: x is not defined ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 4）不允许重复声明 * let不允许在相同作用域内，重复声明同一个变量。 // 报错 function func() { let a = 10; var a = 1; } // 报错 function func() { let a = 10; let a = 1; } 不能在函数内部重新声明参数。 function func(arg) { let arg; } func() // 报错 function func(arg) { { let arg; } } func() // 不报错 2. 块级作用域 1）为什么需要块级作用域 * ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 内层变量可能会覆盖外层变量。 var tmp = 'hello'; function f() { console.log(tmp); if (false) { var tmp = 'world'; } } f(); // undefined 用来计数的循环变量泄露为全局变量。 var tmp = 'hello'; for (var i = 0; i 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。 { {let insane = 'Hello World'} console.log(insane); // 报错 }; 内层作用域可以定义外层作用域的同名变量。 { let insane = 'Hello'; {let insane = 'World'} }; 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。 // IIFE 写法 (function () { var tmp = ...; ... }()); // 块级作用域写法 { let tmp = ...; ... } 2）块级作用域与函数声明 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 // 情况一 if (true) { function f() {} } // 情况二 try { function f() {} } catch(e) { // ... } 上面两种函数声明，根据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 function f() { console.log('I am outside!'); } (function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f(); }()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。 // ES5 环境 function f() { console.log('I am outside!'); } (function () { function f() { console.log('I am inside!'); } if (false) { } f(); }()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ // 浏览器的 ES6 环境 function f() { console.log('I am outside!'); } (function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f(); }()); // Uncaught TypeError: f is not a function ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。上面的例子实际运行的代码如下。 // 浏览器的 ES6 环境 function f() { console.log('I am outside!'); } (function () { var f = undefined; if (false) { function f() { console.log('I am inside!'); } } f(); }()); // Uncaught TypeError: f is not a function 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 // 块级作用域内部的函数声明语句，建议不要使用 { let a = 'secret'; function f() { return a; } } // 块级作用域内部，优先使用函数表达式 { let a = 'secret'; let f = function () { return a; }; } 另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。 // 第一种写法，报错 if (true) let x = 1; // 第二种写法，不报错 if (true) { let x = 1; } 函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。 // 不报错 'use strict'; if (true) { function f() {} } // 报错 'use strict'; if (true) function f() {} 3. const 命令 1）基本用法 * const声明一个只读的常量。一旦声明，常量的值就不能改变。 const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. const一旦声明变量，就必须立即初始化，不能留到以后赋值。只声明不赋值，就会报错。 const foo; // SyntaxError: Missing initializer in const declaration 除了不可改变值，其他用法和let相似 3）本质 * const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 const foo = {}; // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop // 123 // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: \"foo\" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 const a = []; a.push('Hello'); // 可执行 a.length = 0; // 可执行 a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果真的想将对象冻结，应该使用Object.freeze方法。 const foo = Object.freeze({}); // 常规模式时，下面一行不起作用； // 严格模式时，该行会报错 foo.prop = 123; 将对象彻底冻结的函数。 var constantize = (obj) => { Object.freeze(obj); Object.keys(obj).forEach( (key, i) => { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } }); }; 4. 顶层对象的属性 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 window.a = 1; a // 1 a = 2; window.a // 2 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题： 没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）。 程序员很容易不知不觉地就创建了全局变量（比如打字出错）。 顶层对象的属性是到处可以读写的，这非常不利于模块化编程。 window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性。 另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。 var a = 1; // 如果在 Node 的 REPL 环境，可以写成 global.a // 或者采用通用方法，写成 this.a window.a // 1 let b = 1; window.b // undefined 5. globalThis对象 * JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。 ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-09 23:15 "},"destructuring-assignment.html":{"url":"destructuring-assignment.html","title":"变量的解构赋值","keywords":"","body":"变量的解构赋值 重要知识点 ： 1. 交换变量的值 * let [x,y] = [1,2] [x,y] = [y,x] 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 2. 从函数返回多个值 * 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 // 返回一个数组,数组中取出多个对象 function example() { return [1, 2, 3]; } let [a, b, c] = example(); // 返回一个对象,对象中取出多个对象 function example() { return { foo: 1, bar: 2 }; } let { foo, bar } = example(); 3. 函数参数的定义 * 解构赋值可以方便地将一组参数与变量名对应起来。 // 参数是一组有次序的值 function f([x, y, z]) { ... } f([1, 2, 3]); // 参数是一组无次序的值 function f({x, y, z}) { ... } f({z: 3, y: 2, x: 1}); 4. 提取 JSON 数据 * 可以快速提取 JSON 数据的值。 let jsonData = { id: 42, status: \"OK\", data: [867, 5309] }; let { id, status, data: number } = jsonData; console.log(id, status, number); // 42, \"OK\", [867, 5309] 5. 函数参数的默认值 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。 const fn = function({x='hello',y='world'}={}){ ... } 6. 遍历 Map 结构 * 任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 const map = new Map(); map.set('first', 'hello'); map.set('second', 'world'); for (let [key, value] of map) { console.log(key + \" is \" + value); } // first is hello // second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 // 获取键名 for (let [key] of map) { // ... } // 获取键值 for (let [,value] of map) { // ... } 7. 引入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 const { SourceMapConsumer, SourceNode } = require(\"source-map\"); Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-24 23:53 "},"string-extend.html":{"url":"string-extend.html","title":"字符串的扩展","keywords":"","body":"字符串的扩展 1. 字符串的遍历接口 for (let codePoint of 'foo') { console.log(codePoint) } // \"f\" // \"o\" // \"o\" 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 let text = String.fromCodePoint(0x20BB7); for (let i = 0; i 2. 直接输入 U+2028 和 U+2029 JavaScript 字符串允许直接输入字符，以及输入字符的转义形式（Unicode编码） JavaScript 规定有3个字符，不能在字符串里面直接使用，只能使用转义形式。 U+005C：反斜杠（reverse solidus) U+000D：回车（carriage return） U+000A：换行符（line feed） 3. 模板字符串 * 传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。 $('#result').append( 'There are ' + basket.count + ' ' + 'items in your basket, ' + '' + basket.onSale + ' are on sale!' ); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 $('#result').append(` There are ${basket.count} items in your basket, ${basket.onSale} are on sale! `); 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 let greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 $('#list').html(` first second `); 模板字符串中嵌入变量，需要将变量名写在${}之中。 `User ${user.name} is not authorized to do ${action}.` 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 let x = 1; let y = 2; `${x} + ${y} = ${x + y}` // \"1 + 2 = 3\" `${x} + ${y * 2} = ${x + y * 2}` // \"1 + 4 = 5\" let obj = {x: 1, y: 2}; `${obj.x + obj.y}` // \"3\" 模板字符串之中还能调用函数。 function fn() { return \"Hello World\"; } `foo ${fn()} bar` // foo Hello World bar 模板字符串甚至还能嵌套。 const tmpl = addrs => ` ${addrs.map(addr => ` ${addr.first} ${addr.last} `).join('')} `; 4. 标签模板 它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 alert`hello` // 等同于 alert(['hello']) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 let a = 5; let b = 10; tag`Hello ${ a + b } world ${ a * b }`; // 等同于 tag(['Hello ', ' world ', ''], 15, 50); “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 let message = SaferHTML`${sender} has sent you a message.`; function SaferHTML(templateData) { let s = templateData[0]; for (let i = 1; i /g, \"&gt;\"); // Don't escape special characters in the template. s += templateData[i]; } return s; } 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 let sender = 'alert(\"abc\")'; // 恶意代码 let message = SaferHTML`${sender} has sent you a message.`; message // &lt;script&gt;alert(\"abc\")&lt;/script&gt; has sent you a message. 标签模板的另一个应用，就是多语言转换（国际化处理）。 i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!` // \"欢迎访问xxx，您是第xxxx位访问者！\" Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-25 23:45 "},"string-new-method.html":{"url":"string-new-method.html","title":"字符串的新增方法","keywords":"","body":"字符串的新增方法 1. includes(), startsWith(), endsWith() 传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 let s = 'Hello world!'; s.startsWith('Hello') // true s.endsWith('!') // true s.includes('o') // true 这三个方法都支持第二个参数，表示开始搜索的位置。 let s = 'Hello world!'; s.startsWith('world', 6) // true s.endsWith('Hello', 5) // true s.includes('Hello', 6) // false 使用第二个参数n时 endsWith针对前n个字符 startsWith针对从第n个位置直到字符串结束。 includes针对从第n个位置直到字符串结束。 2. repeat() repeat方法返回一个新字符串，表示将原字符串重复n次。 'x'.repeat(3) // \"xxx\" 'hello'.repeat(2) // \"hellohello\" 'na'.repeat(0) // \"\" 参数如果是小数，会被向下取整。 'na'.repeat(2.9) // \"nana\" 如果repeat的参数是负数或者Infinity，会报错。 'na'.repeat(Infinity) // RangeError 'na'.repeat(-1) // RangeError 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。 'na'.repeat(-0.9) // \"\" 参数NaN等同于 0。 'na'.repeat(NaN) // \"\" 如果repeat的参数是字符串，则会返回空字符串。 'na'.repeat('sdg') // \"\" 3. padStart(), padEnd() ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 'x'.padStart(5, 'ab') // 'ababx' 'x'.padStart(4, 'ab') // 'abax' 'x'.padEnd(5, 'ab') // 'xabab' 'x'.padEnd(4, 'ab') // 'xaba' padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。 'xxx'.padStart(2, 'ab') // 'xxx' 'xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。 'abc'.padStart(10, '0123456789') // '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 'x'.padStart(4) // ' x' 'x'.padEnd(4) // 'x ' padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 '1'.padStart(10, '0') // \"0000000001\" '12'.padStart(10, '0') // \"0000000012\" 另一个用途是提示字符串格式。 '12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\" '09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\" 4. trimStart(), trimEnd() ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。 const s = ' abc '; s.trim() // \"abc\" s.trimStart() // \"abc \" s.trimEnd() // \" abc\" 除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-25 23:51 "},"RegExp-extend.html":{"url":"RegExp-extend.html","title":"正则的扩展","keywords":"","body":"正则的扩展 1. RegExp 构造函数 * 在 ES5 中，RegExp构造函数的参数有两种情况。 第一种情况是，第一个参数是字符串，第二个参数是正则表达式的修饰符（flag）。 var regex = new RegExp('xyz', 'i'); // 等价于 var regex = /xyz/i; 第二种情况是，只有一个参数，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 var regex = new RegExp(/xyz/i); // 等价于 var regex = /xyz/i; 但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。 var regex = new RegExp(/xyz/, 'i'); // Uncaught TypeError: Cannot supply flags when constructing one RegExp from another 在ES6中，第一个参数是正则表示式，第二个参数可以使用修饰符（flag），返回的正则表达式会忽略原有的修饰符，使用第二个参数给的修饰符 new RegExp(/abc/ig, 'i').flags // \"i\" 2. 字符串的正则表达式 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] 3. RegExp.prototype.flags 属性 ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 // ES5 的 source 属性 // 返回正则表达式的正文 /abc/ig.source // \"abc\" // ES6 的 flags 属性 // 返回正则表达式的修饰符 /abc/sigu.flags // 'gi' 4. 具名组匹配 * 正则表达式使用圆括号进行组匹配。使用exec方法，就可以将这三组匹配结果提取出来。 const RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/; const matchObj = RE_DATE.exec('1999-12-31'); const year = matchObj[1]; // 1999 const month = matchObj[2]; // 12 const day = matchObj[3]; // 31 组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。 ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。同时，数字序号（matchObj[1]）依然有效。 const RE_DATE = /(?\\d{4})-(?\\d{2})-(?\\d{2})/; const matchObj = RE_DATE.exec('1999-12-31'); const year = matchObj.groups.year; // 1999 const month = matchObj.groups.month; // 12 const day = matchObj.groups.day; // 31 如果具名组没有匹配，那么对应的groups对象属性会是undefined。 const RE_OPT_A = /^(?a+)?$/; const matchObj = RE_OPT_A.exec(''); matchObj.groups.as // undefined 'as' in matchObj.groups // true 5. 解构赋值和替换 * 有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。 let {groups: {one, two}} = /^(?.*):(?.*)$/u.exec('foo:bar'); one // foo two // bar 字符串替换时，使用$引用具名组。 let re = /(?\\d{4})-(?\\d{2})-(?\\d{2})/u; '2015-01-02'.replace(re, '$/$/$') // '02/01/2015' 上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。 replace方法的第二个参数也可以是函数，该函数的参数序列如下。 '2015-01-02'.replace(re, ( matched, // 整个匹配结果 2015-01-02 capture1, // 第一个组匹配 2015 capture2, // 第二个组匹配 01 capture3, // 第三个组匹配 02 position, // 匹配开始的位置 0 S, // 原字符串 2015-01-02 groups // 具名组构成的一个对象 {year, month, day} ) => { let {day, month, year} = groups; return `${day}/${month}/${year}`; }); 6. 引用 如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k的写法。 const RE_TWICE = /^(?[a-z]+)!\\k$/; RE_TWICE.test('abc!abc') // true RE_TWICE.test('abc!ab') // false 数字引用（\\1）依然有效。 const RE_TWICE = /^(?[a-z]+)!\\1$/; RE_TWICE.test('abc!abc') // true RE_TWICE.test('abc!ab') // false 这两种引用语法还可以同时使用。 const RE_TWICE = /^(?[a-z]+)!\\k!\\1$/; RE_TWICE.test('abc!abc!abc') // true RE_TWICE.test('abc!abc!ab') // false 7. String.prototype.matchAll() * ES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 const string = 'test1test2test3'; // g 修饰符加不加都可以 const regex = /t(e)(st(\\d?))/g; for (const match of string.matchAll(regex)) { console.log(match); } // [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"] // [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"] // [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"] 上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for...of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。 遍历器转为数组是非常简单的，使用...运算符和Array.from()方法就可以了。 // 转为数组方法一 [...string.matchAll(regex)] // 转为数组方法二 Array.from(string.matchAll(regex)) Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-25 23:45 "},"number-extend.html":{"url":"number-extend.html","title":"数值的扩展","keywords":"","body":"数值的扩展 1. 二进制和八进制的写法 ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 0b111110111 === 503 // true 0o767 === 503 // true 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 Number('0b111') // 7 Number('0o10') // 8 2. Number.isFinite(), Number.isNaN() * Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。 如果参数类型不是数值，Number.isFinite一律返回false。 Number.isFinite(15); // true Number.isFinite(0.8); // true Number.isFinite(NaN); // false Number.isFinite(Infinity); // false Number.isFinite(-Infinity); // false Number.isFinite('foo'); // false Number.isFinite('15'); // false Number.isFinite(true); // false Number.isNaN()用来检查一个值是否为NaN。 如果参数类型不是NaN，Number.isNaN()一律返回false。 Number.isNaN(NaN) // true Number.isNaN(15) // false Number.isNaN('15') // false Number.isNaN(true) // false Number.isNaN(9/NaN) // true Number.isNaN('true' / 0) // true Number.isNaN('true' / 'true') // true 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 isFinite(25) // true isFinite(\"25\") // true Number.isFinite(25) // true Number.isFinite(\"25\") // false isNaN(NaN) // true isNaN(\"NaN\") // true Number.isNaN(NaN) // true Number.isNaN(\"NaN\") // false 3. Number.parseInt(), Number,parseFloat() * // ES5的写法 parseInt('12.34') // 12 parseFloat('123.45#') // 123.45 // ES6的写法 Number.parseInt('12.34') // 12 Number.parseFloat('123.45#') // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 Number.parseInt === parseInt // true Number.parseFloat === parseFloat // true 4. Number.isInterger() * Number.isInteger()用来判断一个数值是否为整数。 Number.isInteger(25) // true Number.isInteger(25.1) // false JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。 Number.isInteger(25) // true Number.isInteger(25.0) // true 如果参数不是数值，Number.isInteger返回false。 Number.isInteger() // false Number.isInteger(null) // false Number.isInteger('15') // false Number.isInteger(true) // false 注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。 Number.isInteger(3.0000000000000002) // true 5. Number.EPSILON * ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。 对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。 Number.EPSILON === Math.pow(2, -52) // true Number.EPSILON // 2.220446049250313e-16 Number.EPSILON.toFixed(20) // \"0.00000000000000022204\" Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。 0.1 + 0.2 // 0.30000000000000004 0.1 + 0.2 - 0.3 // 5.551115123125783e-17 5.551115123125783e-17.toFixed(20) // '0.00000000000000005551' 上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。 0.1 + 0.2 === 0.3 // false Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。 5.551115123125783e-17 因此，Number.EPSILON的实质是一个可以接受的最小误差范围。 function withinErrorMargin (left, right) { return Math.abs(left - right) 上面的代码为浮点数运算，部署了一个误差检查函数。 6. Math.trunc() * Math.trunc方法用于去除一个数的小数部分，返回整数部分。 Math.trunc(4.1) // 4 Math.trunc(4.9) // 4 Math.trunc(-4.1) // -4 Math.trunc(-4.9) // -4 Math.trunc(-0.1234) // -0 对于非数值，Math.trunc内部使用Number方法将其先转为数值。 Math.trunc('123.456') // 123 Math.trunc(true) //1 Math.trunc(false) // 0 Math.trunc(null) // 0 对于空值和无法截取整数的值，返回NaN。 Math.trunc(NaN); // NaN Math.trunc('foo'); // NaN Math.trunc('1w'); // NaN Math.trunc(); // NaN Math.trunc(undefined) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 Math.trunc = Math.trunc || function(x) { return x 7. Math.sign() Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 它会返回五种值。 参数为正数，返回+1； 参数为负数，返回-1； 参数为 0，返回0； 参数为-0，返回-0; 其他数值，返回NaN。 如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。 Math.sign('') // 0 Math.sign(true) // +1 Math.sign(false) // 0 Math.sign(null) // 0 Math.sign('9') // +1 Math.sign('foo') // NaN Math.sign() // NaN Math.sign(undefined) // NaN 8. Math.cbrt() Math.cbrt方法用于计算一个数的立方根。 Math.cbrt(-1) // -1 Math.cbrt(0) // 0 Math.cbrt(1) // 1 Math.cbrt(2) // 1.2599210498948734 对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。 Math.cbrt('8') // 2 Math.cbrt('hello') // NaN 9. Math.hypot() Math.hypot方法返回所有参数的平方和的平方根。 如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。 Math.hypot(3, 4); // 5 Math.hypot(3, 4, 5); // 7.0710678118654755 Math.hypot(); // 0 Math.hypot(NaN); // NaN Math.hypot(3, 4, 'foo'); // NaN Math.hypot(3, 4, '5'); // 7.0710678118654755 Math.hypot(-3); // 3 10. 指数运算符 ** ES2016 新增了一个指数运算符（**）。 2 ** 2 // 4 2 ** 3 // 8 这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。 // 相当于 2 ** (3 ** 2) 2 ** 3 ** 2 // 512 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。 let a = 1.5; a **= 2; // 等同于 a = a * a; let b = 4; b **= 3; // 等同于 b = b * b * b; Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-26 23:57 "},"function-extend.html":{"url":"function-extend.html","title":"函数的扩展","keywords":"","body":"函数的扩展 1. 函数参数的默认值 * 1）基本用法 ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 function log(x, y) { y = y || 'World'; console.log(x, y); } log('Hello') // Hello World log('Hello', 'China') // Hello China log('Hello', '') // Hello World 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。 if (typeof y === 'undefined') { y = 'World'; } ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 function log(x, y = 'World') { console.log(x, y); } log('Hello') // Hello World log('Hello', 'China') // Hello China log('Hello', '') // Hello 参数变量是默认声明的，所以不能用let或const再次声明。 function foo(x = 5) { let x = 1; // error } 2）与结构赋值默认值的结合使用 参数默认值可以与解构赋值的默认值，结合起来使用。 function foo({x, y = 5}) { console.log(x, y); } foo({}) // undefined 5 foo({x: 1}) // 1 5 foo({x: 1, y: 2}) // 1 2 foo() // TypeError: Cannot read property 'x' of undefined function fetch(url, { body = '', method = 'GET', headers = {} } = {}) { console.log(method); } fetch('http://example.com') // \"GET\" 上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET 请问下面两种写法有什么差别？ // 写法一 function m1({x = 0, y = 0} = {}) { return [x, y]; } // 写法二 function m2({x, y} = { x: 0, y: 0 }) { return [x, y]; } 上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。 // 函数没有参数的情况 m1() // [0, 0] m2() // [0, 0] // x 和 y 都有值的情况 m1({x: 3, y: 8}) // [3, 8] m2({x: 3, y: 8}) // [3, 8] // x 有值，y 无值的情况 m1({x: 3}) // [3, 0] m2({x: 3}) // [3, undefined] // x 和 y 都无值的情况 m1({}) // [0, 0]; m2({}) // [undefined, undefined] m1({z: 3}) // [0, 0] m2({z: 3}) // [undefined, undefined] 3）参数默认值的位置 通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 // 例一 function f(x = 1, y) { return [x, y]; } f() // [1, undefined] f(2) // [2, undefined]) f(, 1) // 报错 f(undefined, 1) // [1, 1] // 例二 function f(x, y = 5, z) { return [x, y, z]; } f() // [undefined, 5, undefined] f(1) // [1, 5, undefined] f(1, ,2) // 报错 f(1, undefined, 2) // [1, 5, 2] 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 function foo(x = 5, y = 6) { console.log(x, y); } foo(undefined, null) // 5 null 4）函数的length属性 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数 (function (a) {}).length // 1 (function (a = 5) {}).length // 0 (function (a, b, c = 5) {}).length // 2 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。 (function(...args) {}).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 (function (a = 0, b, c) {}).length // 0 (function (a, b = 1, c) {}).length // 1 5）作用域 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 var x = 1; function f(x, y = x) { console.log(y); } f(2) // 2 上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。 let x = 1; function f(y = x) { let x = 2; console.log(y); } f() // 1 上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。 如果此时，全局变量x不存在，就会报错。 function f(y = x) { let x = 2; console.log(y); } f() // ReferenceError: x is not defined 上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。 如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。 let foo = 'outer'; function bar(func = () => foo) { let foo = 'inner'; console.log(func()); } bar(); // outer 6）应用 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 function throwIfMissing() { throw new Error('Missing parameter'); } function foo(mustBeProvided = throwIfMissing()) { return mustBeProvided; } foo() // Error: Missing parameter 也可以将参数默认值设为undefined，表明这个参数是可以省略的。 function foo(optional = undefined) { ··· } 2. reset 参数 ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 function add(...values) { let sum = 0; for (var val of values) { sum += val; } return sum; } add(2, 5, 3) // 10 上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。 下面是一个 rest 参数代替arguments变量的例子。 // arguments变量的写法 function sortNumbers() { return Array.prototype.slice.call(arguments).sort(); } // rest参数的写法 const sortNumbers = (...numbers) => numbers.sort(); arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组 下面是一个利用 rest 参数改写数组push方法的例子。 function push(array, ...items) { items.forEach(function(item) { array.push(item); console.log(item); }); } var a = []; push(a, 1, 2, 3) 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 // 报错 function f(a, ...b, c) { // ... } 函数的length属性，不包括 rest 参数。 (function(a) {}).length // 1 (function(...a) {}).length // 0 (function(a, ...b) {}).length // 1 3. 严格模式 从 ES5 开始，函数内部可以设定为严格模式。 function doSomething(a, b) { 'use strict'; // code } ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 // 报错 function doSomething(a, b = a) { 'use strict'; // code } // 报错 const doSomething = function ({a, b}) { 'use strict'; // code }; // 报错 const doSomething = (...a) => { 'use strict'; // code }; const obj = { // 报错 doSomething({a, b}) { 'use strict'; // code } }; 两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。 'use strict'; function doSomething(a, b = a) { // code } 第二种是把函数包在一个无参数的立即执行函数里面。 const doSomething = (function () { 'use strict'; return function(value = 42) { return value; }; }()); 4. name属性 函数的name属性，返回该函数的函数名。 function foo() {} foo.name // \"foo\" Function构造函数返回的函数实例，name属性的值为anonymous。 (new Function).name // \"anonymous\" 5. 箭头函数 * 1）基本用法 var f = v => v; // 等同于 var f = function (v) { return v; }; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 var f = () => 5; // 等同于 var f = function () { return 5 }; var sum = (num1, num2) => num1 + num2; // 等同于 var sum = function(num1, num2) { return num1 + num2; }; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 var sum = (num1, num2) => { if(true){ return num1 + num2; } } 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 // 报错 let getTempItem = id => { id: id, name: \"Temp\" }; // 不报错 let getTempItem = id => ({ id: id, name: \"Temp\" }); 如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。 let fn = () => void doesNotReturn(); 箭头函数可以与变量解构结合使用。 const full = ({ first, last }) => first + ' ' + last; 箭头函数使得表达更加简洁。 const isEven = n => n % 2 === 0; const square = n => n * n; 箭头函数的一个用处是简化回调函数。 // 正常函数写法 [1,2,3].map(function (x) { return x * x; }); // 箭头函数写法 [1,2,3].map(x => x * x); // 正常函数写法 var result = values.sort(function (a, b) { return a - b; }); // 箭头函数写法 var result = values.sort((a, b) => a - b); 下面是 rest 参数与箭头函数结合的例子。 const numbers = (...nums) => nums; numbers(1, 2, 3, 4, 5) // [1,2,3,4,5] const headAndTail = (head, ...tail) => [head, tail]; headAndTail(1, 2, 3, 4, 5) // [1,[2,3,4,5]] 2）使用注意点 * 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 this对象的指向是可变的，但是在箭头函数中，它是固定的。 function foo() { setTimeout(() => { console.log('id:', this.id); }, 100); } var id = 21; foo.call({ id: 42 }); // id: 42 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。 function Timer() { this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() => this.s1++, 1000); // 普通函数 setInterval(function () { this.s2++; }, 1000); } var timer = new Timer(); setTimeout(() => console.log('s1: ', timer.s1), 3100); setTimeout(() => console.log('s2: ', timer.s2), 3100); // s1: 3 // s2: 0 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 箭头函数转成 ES5 的代码如下。 // ES6 function foo() { setTimeout(() => { console.log('id:', this.id); }, 100); } // ES5 function foo() { var _this = this; setTimeout(function () { console.log('id:', _this.id); }, 100); } 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 function foo() { setTimeout(() => { console.log('args:', arguments); }, 100); } foo(2, 4, 6, 8) // args: [2, 4, 6, 8] 由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 (function() { return [ (() => this.x).bind({ x: 'inner' })() ]; }).call({ x: 'outer' }); // ['outer'] 3）不适用场合 * 定义对象的方法时使用箭头函数，且该方法内部包括this，以下是错误示范 const cat = { lives: 9, jumps: () => { this.lives--; } } cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致jumps箭头函数定义时的作用域就是全局作用域。 需要动态this的时候，也不应使用箭头函数。 var button = document.getElementById('press'); button.addEventListener('click', () => { this.classList.toggle('on'); }); 上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。 另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。 6. 尾调用优化 1）什么是尾调用 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 function f(x){ return g(x); } 函数f的最后一步是调用函数g，这就叫尾调用。 以下三种情况，都不属于尾调用。 // 情况一 function f(x){ let y = g(x); return y; } // 情况二 function f(x){ return g(x) + 1; } // 情况三 function f(x){ g(x); } 情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。函数无返回值默认返回 undefined function f(x){ g(x); return undefined; } 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 function f(x) { if (x > 0) { return m(x) } return n(x); } 函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 2）尾调用优化 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 function f() { let m = 1; let n = 2; return g(m + n); } f(); // 等同于 function f() { return g(3); } f(); // 等同于 g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 3）尾递归 * 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1); } factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5, 1) // 120 4）递归函数的改写 * 柯里化 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，两个方法可以解决这个问题 在尾递归函数之外，再提供一个正常形式的函数。 function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total); } function factorial(n) { return tailFactorial(n, 1); } factorial(5) // 120 上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 就是采用 ES6 的函数默认值，这种就简单多了 function factorial(n, total = 1) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5) // 120 5）严格模式 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。 function restricted() { 'use strict'; restricted.caller; // 报错 restricted.arguments; // 报错 } restricted(); 6）尾递归优化的实现 * 蹦床函数 尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 下面是一个正常的递归函数。 function sum(x, y) { if (y > 0) { return sum(x + 1, y - 1); } else { return x; } } sum(1, 100000) // Uncaught RangeError: Maximum call stack size exceeded(…) 蹦床函数（trampoline）可以将递归执行转为循环执行。 function trampoline(f) { while (f && f instanceof Function) { f = f(); } return f; } 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。 function sum(x, y) { if (y > 0) { return sum.bind(null, x + 1, y - 1); } else { return x; } } trampoline(sum(1, 100000)) // 100001 上面代码中，sum函数的每次执行，都会返回自身的另一个版本，使用蹦床函数执行sum，就不会发生调用栈溢出。 蹦床函数并不是真正的尾递归优化，下面的实现才是。 function tco(f) { var value; var active = false; var accumulated = []; return function accumulator() { accumulated.push(arguments); if (!active) { active = true; while (accumulated.length) { value = f.apply(this, accumulated.shift()); } active = false; return value; } }; } var sum = tco(function(x, y) { if (y > 0) { return sum(x + 1, y - 1) } else { return x } }); sum(1, 100000) // 100001 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。 7. 函数参数的尾逗号 ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。 function a( x, y ){ ... } a( 'xxx', 'yyy' ) 如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数a添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。因此新的语法规定定义和调用函数时，尾部允许有逗号 function a( x, y, ){ ... } a( 'xxx', 'yyy', ) 这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。 8. Function.prototype.toString() ES2019 对函数实例的toString()方法做出了修改。 toString()方法返回函数代码本身，以前会省略注释和空格。 修改前 function /* foo comment */ foo () {} foo.toString() // function foo() {} 修改后的写法 function /* foo comment */ foo () {} foo.toString() // \"function /* foo comment */ foo () {}\" 9. catch 命令的参数省略 JavaScript 语言的try...catch结构，以前明确要求catch命令后面必须跟参数，接受try代码块抛出的错误对象 try { // ... } catch (err) { // 处理错误 } 上面代码中，catch命令后面带有参数err。 很多时候，catch代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。ES2019 做出了改变，允许catch语句省略参数。 try { // ... } catch { // ... } Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-27 23:48 "},"array-extend.html":{"url":"array-extend.html","title":"数组的扩展","keywords":"","body":"数组的扩展 1. 扩展运算符 1）含义 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 console.log(...[1, 2, 3]) // 1 2 3 console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5 扩展运算符后面还可以放置表达式。 const arr = [ ...(x > 0 ? ['a'] : []), 'b', ]; 如果扩展运算符后面是一个空数组，则不产生任何效果。 [...[], 1] // [1] 注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。 (...[1, 2]) // Uncaught SyntaxError: Unexpected number console.log((...[1, 2])) // Uncaught SyntaxError: Unexpected number console.log(...[1, 2]) // 1 2 2）替代函数的 apply 方法 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。 // ES5 的写法 function f(x, y, z) { // ... } var args = [0, 1, 2]; f.apply(null, args); // ES6的写法 function f(x, y, z) { // ... } let args = [0, 1, 2]; f(...args); 通过push函数，将一个数组添加到另一个数组的尾部。 // ES5的 写法 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; Array.prototype.push.apply(arr1, arr2); // ES6 的写法 let arr1 = [0, 1, 2]; let arr2 = [3, 4, 5]; arr1.push(...arr2); 上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。 3）扩展运算符的应用 * （1）复制数组 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。 const a1 = [1, 2]; const a2 = a1; a2[0] = 2; a1 // [2, 2] ES5 只能用变通方法来复制数组。 const a1 = [1, 2]; const a2 = a1.concat(); a2[0] = 2; a1 // [1, 2] 扩展运算符提供了复制数组的简便写法。 const a1 = [1, 2]; // 写法一,这种写法较为常用 const a2 = [...a1]; // 写法二 const [...a2] = a1; （2）合并数组 扩展运算符提供了数组合并的新写法。 const arr1 = ['a', 'b']; const arr2 = ['c']; const arr3 = ['d', 'e']; // ES5 的合并数组 arr1.concat(arr2, arr3); // [ 'a', 'b', 'c', 'd', 'e' ] // ES6 的合并数组 [...arr1, ...arr2, ...arr3] // [ 'a', 'b', 'c', 'd', 'e' ] 不过，这两种方法都是浅拷贝，使用的时候需要注意。 const a1 = [{ foo: 1 }]; const a2 = [{ bar: 2 }]; const a3 = a1.concat(a2); const a4 = [...a1, ...a2]; a3[0] === a1[0] // true a4[0] === a1[0] // true 上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。 （3）与结构赋值结合 扩展运算符可以与解构赋值结合起来，用于生成数组。 // ES5 a = list[0], rest = list.slice(1) // ES6 [a, ...rest] = list const [first, ...rest] = [1, 2, 3, 4, 5]; first // 1 rest // [2, 3, 4, 5] const [first, ...rest] = []; first // undefined rest // [] const [first, ...rest] = [\"foo\"]; first // \"foo\" rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 const [...butLast, last] = [1, 2, 3, 4, 5]; // 报错 const [first, ...middle, last] = [1, 2, 3, 4, 5]; // 报错 （4）字符串 扩展运算符还可以将字符串转为真正的数组。 [...'hello'] // [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。 'x\\uD83D\\uDE80y'.length // 4 [...'x\\uD83D\\uDE80y'].length // 3 （5）实现了 Iterator 接口的对象 任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。 let nodeList = document.querySelectorAll('div'); let array = [...nodeList]; 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。 let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3 }; // TypeError: Cannot spread non-iterable object. let arr = [...arrayLike]; 上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 （6）Map 和 Set 结构， Generator函数 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。 let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'], ]); let arr = [...map.keys()]; // [1, 2, 3] Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 const go = function*(){ yield 1; yield 2; yield 3; }; [...go()] // [1, 2, 3] 2. Array.from() 1）含义 Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 2）用法 把一个类似数组的对象，Array.from将它转为真正的数组。 let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3 }; // ES5的写法 var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c'] // ES6的写法 let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 // NodeList对象 let ps = document.querySelectorAll('p'); Array.from(ps).filter(p => { return p.textContent.length > 100; }); // arguments对象 function foo() { var args = Array.from(arguments); // ... } 只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。 Array.from('hello') // ['h', 'e', 'l', 'l', 'o'] let namesSet = new Set(['a', 'b']) Array.from(namesSet) // ['a', 'b'] 参数是一个真正的数组，Array.from会返回一个一模一样的新数组。 Array.from([1, 2, 3]) // [1, 2, 3] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 Array.from({ length: 3 }); // [ undefined, undefined, undefined ] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 Array.from(arrayLike, x => x * x); // 等同于 Array.from(arrayLike).map(x => x * x); Array.from([1, 2, 3], (x) => x * x) // [1, 4, 9] 将数组中布尔值为false的成员转为0。 Array.from([1, , 2, , 3], (n) => n || 0) // [1, 0, 2, 0, 3] 返回各种数据的类型。 function typesOf () { return Array.from(arguments, value => typeof value) } typesOf(null, [], NaN) // ['object', 'object', 'number'] 3）模拟实现 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 const toArray = (() => Array.from ? Array.from : obj => [].slice.call(obj) )(); 3. Array.of() 1） 含义 Array.of方法用于将一组值，转换为数组。 Array.of(3, 11, 8) // [3,11,8] Array.of(3) // [3] Array.of(3).length // 1 2）用法 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 Array() // [] Array(3) // [, , ,] Array(3, 11, 8) // [3, 11, 8] 只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 3）模拟实现 Array.of方法可以用下面的代码模拟实现。 function ArrayOf(){ return [].slice.call(arguments); } 4. 数组实例的 copyWith() 1）含义 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 2）用法 它接受三个参数。 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。 这三个参数都应该是数值，如果不是，会自动转为数值。 [1, 2, 3, 4, 5,6,7,8].copyWithin(0, 3) // [4, 5, 6, 7, 8, 6, 7, 8] // 将3号位复制到0号位 [1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5] // -2相当于3号位，-1相当于4号位 [1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5] 5. 数组实例的 find() 和 findIndex() 1）find 含义 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 [1, 4, -5, 10].find((n) => n 2）find 用法 find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 [1, 5, 10, 15].find(function(value, index, arr) { return value > 9; }) // 10 3）findIndex 含义 返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 [1, 5, 10, 15].findIndex(function(value, index, arr) { return value > 9; }) // 2 4）用法 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 function f(v){ return v > this.age; } let person = {name: 'John', age: 20}; [10, 12, 26, 15].find(f, person); // 26 这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。 [NaN].indexOf(NaN) // -1 [NaN].findIndex(y => Object.is(NaN, y)) // 0 indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。 6. 数组实例的 fill() 1）含义 fill方法使用给定值，填充一个数组。 ['a', 'b', 'c'].fill(7) // [7, 7, 7] new Array(3).fill(7) // [7, 7, 7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 2）用法 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 ['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] 如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 let arr = new Array(3).fill({name: \"Mike\"}); arr[0].name = \"Ben\"; arr // [{name: \"Ben\"}, {name: \"Ben\"}, {name: \"Ben\"}] let arr = new Array(3).fill([]); arr[0].push(5); arr // [[5], [5], [5]] 7. 数组实例的 entries()， keys()，和values() 1）含义 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 for (let index of ['a', 'b'].keys()) { console.log(index); } // 0 // 1 for (let elem of ['a', 'b'].values()) { console.log(elem); } // 'a' // 'b' for (let [index, elem] of ['a', 'b'].entries()) { console.log(index, elem); } // 0 \"a\" // 1 \"b\" 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。 let letter = ['a', 'b', 'c']; let entries = letter.entries(); console.log(entries.next().value); // [0, 'a'] console.log(entries.next().value); // [1, 'b'] console.log(entries.next().value); // [2, 'c'] 8. 数组实例的 includes() 1）含义 Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。 [1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false [1, 2, NaN].includes(NaN) // true 2）用法 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 [1, 2, 3].includes(3, 3); // false [1, 2, 3].includes(3, -1); // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。 if (arr.indexOf(el) !== -1) { // ... } indexOf方法有两个缺点 不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。 它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。 [NaN].indexOf(NaN) // -1 includes使用的是不一样的判断算法，就没有这个问题。 [NaN].includes(NaN) // true Map 和 Set 数据结构有一个has方法，需要注意与includes区分。 Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。 Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。 9. 数组实例的 flat(), flatMap() 1）flat() 含义 数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。 [1, 2, [3, 4]].flat() // [1, 2, 3, 4] 2）flat() 用法 flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。参数为2，表示要“拉平”两层的嵌套数组。 [1, 2, [3, [4, 5]]].flat() // [1, 2, 3, [4, 5]] [1, 2, [3, [4, 5]]].flat(2) // [1, 2, 3, 4, 5] 如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。 [1, [2, [3]]].flat(Infinity) // [1, 2, 3] 如果原数组有空位，flat()方法会跳过空位。 [1, 2, , 4, 5].flat() // [1, 2, 4, 5] 3） flatMap() 含义 flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。 // 相当于 [[2, 4], [3, 6], [4, 8]].flat() [2, 3, 4].flatMap((x) => [x, x * 2]) // [2, 4, 3, 6, 4, 8] flatMap()只能展开一层数组，返回的还是一个嵌套数组。 // 相当于 [[[2]], [[4]], [[6]], [[8]]].flat() [1, 2, 3, 4].flatMap(x => [[x * 2]]) // [[2], [4], [6], [8]] 4）flatMap() 用法 flatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。 10. 数组的空位 1）含义 数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 Array(3) // [, , ,] 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。 0 in [undefined, undefined, undefined] // true 0 in [, , ,] // false 2）用法 ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 ES6 则是明确将空位转为undefined。 Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。 Array.from(['a',,'b']) // [ \"a\", undefined, \"b\" ] 扩展运算符（...）也会将空位转为undefined。 [...['a',,'b']] // [ \"a\", undefined, \"b\" ] copyWithin()会连空位一起拷贝。 [,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"] fill()会将空位视为正常的数组位置。 new Array(3).fill('a') // [\"a\",\"a\",\"a\"] for...of循环也会遍历空位。 let arr = [, ,]; for (let i of arr) { console.log(1); } // 1 // 1 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 // entries() [...[,'a'].entries()] // [[0,undefined], [1,\"a\"]] // keys() [...[,'a'].keys()] // [0,1] // values() [...[,'a'].values()] // [undefined,\"a\"] // find() [,'a'].find(x => true) // undefined // findIndex() [,'a'].findIndex(x => true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。 11. Array.prototype.sort() 的排序稳定性 2）含义 排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。 const arr = [ 'peach', 'straw', 'apple', 'spork' ]; const stableSorting = (s1, s2) => { if (s1[0] 上面代码对数组arr按照首字母进行排序。排序结果中，straw在spork的前面，跟原始顺序一致，所以排序算法stableSorting是稳定排序。 const unstableSorting = (s1, s2) => { if (s1[0] 上面代码中，排序结果是spork在straw前面，跟原始顺序相反，所以排序算法unstableSorting是不稳定的。 早先的 ECMAScript 没有规定，Array.prototype.sort()的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。ES2019 明确规定，Array.prototype.sort()的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 13:53 "},"object-extend.html":{"url":"object-extend.html","title":"对象的扩展","keywords":"","body":"对象的扩展 1. 属性的简介表示法 ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 const foo = 'bar'; const baz = {foo}; baz // {foo: \"bar\"} // 等同于 const baz = {foo: foo}; 变量foo直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。 函数也可以简写 let birth = '2000/01/01'; const Person = { name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() { console.log('我的名字是', this.name); } }; 属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。 const cart = { _wheels: 4, get wheels () { return this._wheels; }, set wheels (value) { if (value 简洁写法在打印对象时也很有用。 let user = { name: 'test' }; let foo = { bar: 'baz' }; console.log(user, foo) // {name: \"test\"} {bar: \"baz\"} console.log({user, foo}) // {user: {name: \"test\"}, foo: {bar: \"baz\"}} 上面代码中，console.log直接输出user和foo两个对象时，就是两组键值对，可能会混淆。把它们放在大括号里面输出，就变成了对象的简洁表示法，每组键值对前面会打印对象名，这样就比较清晰了。 注意，简写的对象方法不能用作构造函数，会报错。 const obj = { f() { this.foo = 'bar'; } }; new obj.f() // 报错 2. 属性名表达式 1）定义属性名 JavaScript 定义对象的属性，有两种方法。 // 方法一 obj.foo = true; // 方法二 obj['a' + 'bc'] = 123; 上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。 ES6 允许字面量定义对象时，把表达式放在方括号内。 let propKey = 'foo'; let obj = { [propKey]: true, ['a' + 'bc']: 123 }; // {foo: true, abc: 123} let lastWord = 'last word'; const a = { 'first word': 'hello', [lastWord]: 'world' }; a['first word'] // \"hello\" a['firstWord'] // undefined a[lastWord] // \"world\" a['last word'] // \"world\" 属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。 const keyA = {a: 1}; const keyB = {b: 2}; const myObject = { [keyA]: 'valueA', [keyB]: 'valueB' }; myObject // Object {[object Object]: \"valueB\"} [keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。 2）定义方法名 let obj = { ['h' + 'ello']() { return 'hi'; } }; obj.hello() // hi 3. 方法的 name 属性 函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。 const person = { sayName() { console.log('hello!'); }, }; person.sayName.name // \"sayName\" 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 const obj = { get foo() {}, set foo(x) {} }; obj.foo.name // TypeError: Cannot read property 'name' of undefined const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo'); descriptor.get.name // \"get foo\" descriptor.set.name // \"set foo\" 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。 (new Function()).name // \"anonymous\" var doSomething = function() { // ... }; doSomething.bind().name // \"bound doSomething\" 4. 属性的可没举性和遍历 1）可枚举性 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 let obj = { foo: 123 }; Object.getOwnPropertyDescriptor(obj, 'foo') // { // value: 123, // writable: true, // enumerable: true, // configurable: true // } 引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for...in遍历到。 Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable // false Object.getOwnPropertyDescriptor([], 'length').enumerable // false ES6 规定，所有 Class 的原型的方法都是不可枚举的。 Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable // false 操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替。 2）属性的遍历 ES6 公有5种方法可以实现对属性的遍历 （1）for...in for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 （2）Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 （3）Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 （4）Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 （5）Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。 Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 }) // ['2', '10', 'b', 'a', Symbol()] 5. super 关键字 this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。 const proto = { foo: 'hello' }; const obj = { foo: 'world', find() { return super.foo; } }; Object.setPrototypeOf(obj, proto); obj.find() // \"hello\" 上面代码中，对象obj.find()方法之中，通过super.foo引用了原型对象proto的foo属性。 注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 // 报错 const obj = { foo: super.foo } // 报错 const obj = { foo: () => super.foo } // 报错 const obj = { foo: function () { return super.foo } } 上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。 JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。 const proto = { x: 'hello', foo() { console.log(this.x); }, }; const obj = { x: 'world', foo() { super.foo(); } } Object.setPrototypeOf(obj, proto); obj.foo() // \"world\" 6. 对象的扩展运算符 1）解构赋值 对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; x // 1 y // 2 z // { a: 3, b: 4 } 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。 let { ...z } = null; // 运行时错误 let { ...z } = undefined; // 运行时错误 解构赋值必须是最后一个参数，否则会报错。 let { ...x, y, z } = someObject; // 句法错误 let { x, ...y, ...z } = someObject; // 句法错误 注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。 let obj = { a: { b: 1 } }; let { ...x } = obj; obj.a.b = 2; x.a.b // 2 扩展运算符的解构赋值，不能复制继承自原型对象的属性。 let o1 = { a: 1 }; let o2 = { b: 2 }; o2.__proto__ = o1; let { ...o3 } = o2; o3 // { b: 2 } o3.a // undefined 2）扩展运算符 对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 let z = { a: 3, b: 4 }; let n = { ...z }; n // { a: 3, b: 4 } 由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。 let foo = { ...['a', 'b', 'c'] }; foo // {0: \"a\", 1: \"b\", 2: \"c\"} 如果扩展运算符后面是一个空对象，则没有任何效果。 {...{}, a: 1} // { a: 1 } 如果扩展运算符后面不是对象，则会自动将其转为对象。 // 等同于 {...Object(1)} {...1} // {} // 等同于 {...Object(true)} {...true} // {} // 等同于 {...Object(undefined)} {...undefined} // {} // 等同于 {...Object(null)} {...null} // {} 但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。 {...'hello'} // {0: \"h\", 1: \"e\", 2: \"l\", 3: \"l\", 4: \"o\"} 对象的扩展运算符等同于使用Object.assign()方法。 let aClone = { ...a }; // 等同于 let aClone = Object.assign({}, a); 上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。 // 写法一 const clone1 = { __proto__: Object.getPrototypeOf(obj), ...obj }; // 写法二 const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj ); // 写法三 const clone3 = Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj) ) 上面代码中，写法一的__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。 扩展运算符可以用于合并两个对象。 let ab = { ...a, ...b }; // 等同于 let ab = Object.assign({}, a, b); 如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。这用来修改现有对象部分的属性就很方便了。 let newVersion = { ...previousVersion, name: 'New Name' // Override the name property }; 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。 let aWithDefaults = { x: 1, y: 2, ...a }; // 等同于 let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a); // 等同于 let aWithDefaults = Object.assign({ x: 1, y: 2 }, a); 与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。 const obj = { ...(x > 1 ? {a: 1} : {}), b: 2, }; 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。 // 并不会抛出错误，因为 x 属性只是被定义，但没执行 let aWithXGetter = { ...a, get x() { throw new Error('not throw yet'); } }; // 会抛出错误，因为 x 属性被执行了 let runtimeError = { ...a, ...{ get x() { throw new Error('throw now'); } } }; 7. 链判断运算符 ?. * 编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。 比如，要读取message.body.user.firstName，安全的写法是写成下面这样。 const firstName = (message && message.body && message.body.user && message.body.user.firstName) || 'default'; 这样的层层判断非常麻烦，因此 ES2020 引入了“链判断运算符”（optional chaining operator）?.，简化上面的写法。 const firstName = message?.body?.user?.firstName || 'default'; 上面代码使用了?.运算符，直接在链式调用的时候判断，左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined。 链判断运算符有三种用法。 obj?.prop // 对象属性 obj?.[expr] // 同上 func?.(...args) // 函数或对象方法的调用 下面是判断对象方法是否存在，如果存在就立即执行的例子。 obj.fn?.() 上面代码中，obj.fn如果有定义，就会调用该方法，否则直接返回undefined`。 对于那些可能没有实现的方法，这个运算符尤其有用。 if (myForm.checkValidity?.() === false) { // 表单校验失败 return; } 上面代码中，老式浏览器的表单可能没有checkValidity这个方法，这时?.运算符就会返回undefined，判断语句就变成了undefined === false，所以就会跳过下面的代码。 下面是这个运算符常见的使用形式，以及不使用该运算符时的等价形式。 a?.b // 等同于 a == null ? undefined : a.b a?.[x] // 等同于 a == null ? undefined : a[x] a?.b() // 等同于 a == null ? undefined : a.b() a?.() // 等同于 a == null ? undefined : a() 使用这个运算符，有几个注意点。 1）断路机制 a?.[++x] // 等同于 a == null ? undefined : a[++x] 上面代码中，如果a是undefined或null，那么x不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。 2）delete 运算符 delete a?.b // 等同于 a == null ? undefined : delete a.b 上面代码中，如果a是undefined或null，会直接返回undefined，而不会进行delete运算。 3）括号的影响 如果属性链有圆括号，链判断运算符只对圆括号内部有影响。 (a?.b).c // 等价于 (a == null ? undefined : a.b).c 一般来说，使用?.运算符的场合，不应该使用圆括号。 4）报错场合 以下写法是禁止的，会报错。 // 构造函数 new a?.() new a?.b() // 链判断运算符的右侧有模板字符串 a?.`{b}` a?.b`{c}` // 链判断运算符的左侧是 super super?.() super?.foo // 链运算符用于赋值运算符左侧 a?.b = c 5）右侧不得为十进制数值 为了保证兼容以前的代码，允许foo?.3:0被解析成foo ? .3 : 0，因此规定如果?.后面紧跟一个十进制数字，那么?.不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。 8. Null 判断运算符 ?? * 读取对象属性的时候，如果某个属性的值是null或undefined，有时候需要为它们指定默认值。常见做法是通过||运算符指定默认值。 const headerText = response.settings.headerText || 'Hello, world!'; const animationDuration = response.settings.animationDuration || 300; const showSplashScreen = response.settings.showSplashScreen || true; 上面的三行代码都通过||运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为null或undefined，默认值就会生效，但是属性的值如果为空字符串或false或0，默认值也会生效。 ES2020 引入了一个新的 Null 判断运算符??。它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值。 const headerText = response.settings.headerText ?? 'Hello, world!'; const animationDuration = response.settings.animationDuration ?? 300; const showSplashScreen = response.settings.showSplashScreen ?? true; 这个运算符的一个目的，就是跟链判断运算符?.配合使用，为null或undefined的值设置默认值。 const animationDuration = response.settings?.animationDuration ?? 300; 这个运算符很适合判断函数参数是否赋值。 function Component(props) { const enable = props.enabled ?? true; // … } //等同于 function Component(props) { const { enabled: enable = true, } = props; // … } ??有一个运算优先级问题，它与&&和||的优先级孰高孰低。现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。 // 报错 lhs && middle ?? rhs lhs ?? middle && rhs lhs || middle ?? rhs lhs ?? middle || rhs 必须加入表明优先级的括号。 (lhs && middle) ?? rhs; lhs && (middle ?? rhs); (lhs ?? middle) && rhs; lhs ?? (middle && rhs); (lhs || middle) ?? rhs; lhs || (middle ?? rhs); (lhs ?? middle) || rhs; lhs ?? (middle || rhs); 9. 操作符反回值 && || 1）&& （1）真真反后 let a = 1 && 2 // a = 2 （2）假假反前 let a = 0 && null // a = 0 （3）真假反假 let a = 0 && 1 // a = 0 let a = 1 && 0 // a = 0 2）|| （1）真真反前 let a = 1 || 2 // a = 1 （2）假假反后 let a = 0 || null // a = null （3）真假反真 let a = 0 && 1 // a = 1 let a = 1 && 0 // a = 1 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "},"object-new-method.html":{"url":"object-new-method.html","title":"对象的新增方法","keywords":"","body":"对象的新增方法 1. Object.is() * 1）含义 用来比较两个值是否严格相等 2）用法 ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。 ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。与严格比较运算符（===）的行为基本一致。 Object.is('foo', 'foo') // true Object.is({}, {}) // false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 +0 === -0 //true NaN === NaN // false Object.is(+0, -0) // false Object.is(NaN, NaN) // true 2. Object.assign() * 1）含义 Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 const target = { a: 1 }; const source1 = { b: 2 }; const source2 = { c: 3 }; Object.assign(target, source1, source2); target // {a:1, b:2, c:3} Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 2）用法 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 const target = { a: 1, b: 1 }; const source1 = { b: 2, c: 2 }; const source2 = { c: 3 }; Object.assign(target, source1, source2); target // {a:1, b:2, c:3} 如果只有一个参数，Object.assign会直接返回该参数。 const obj = {a: 1}; Object.assign(obj) === obj // true 如果该参数不是对象，则会先转成对象，然后返回。 typeof Object.assign(2) // \"object\" 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。 Object.assign(undefined) // 报错 Object.assign(null) // 报错 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。 let obj = {a: 1}; Object.assign(obj, undefined) === obj // true Object.assign(obj, null) === obj // true 除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。 const str = 'abc' const num = 1 const boo = true const obj = Object.assign({}, str, num, boo); console.log(obj); // { \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" } 只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。 Object(true) // {[[PrimitiveValue]]: true} Object(10) // {[[PrimitiveValue]]: 10} Object('abc') // {0: \"a\", 1: \"b\", 2: \"c\", length: 3, [[PrimitiveValue]]: \"abc\"} Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。 Object.assign({b: 'c'}, Object.defineProperty({}, 'invisible', { enumerable: false, value: 'hello' }) ) // { b: 'c' } Object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。 属性名为 Symbol 值的属性，也会被Object.assign拷贝。 Object.assign({ a: 'b' }, { [Symbol('c')]: 'd' }) // { a: 'b', Symbol(c): 'd' } 3）注意点 （1）浅拷贝 Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 const obj1 = {a: {b: 1}}; const obj2 = Object.assign({}, obj1); obj1.a.b = 2; obj2.a.b // 2 （2）同名属性的替换 一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。 const target = { a: { b: 'c', d: 'e' } } const source = { a: { b: 'hello' } } Object.assign(target, source) // { a: { b: 'hello' } } 一些函数库提供Object.assign的定制版本（比如 Lodash 的_.defaultsDeep方法），可以得到深拷贝的合并。 （3）数组的处理 Object.assign可以用来处理数组，但是会把数组视为对象。 Object.assign([1, 2, 3], [4, 5]) // [4, 5, 3] Object.assign把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。 （4）取值函数的处理 Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。 const source = { get foo() { return 1 } }; const target = {}; Object.assign(target, source) // { foo: 1 } 3）常见用途 （1）为对象添加属性 class Point { constructor(x, y) { Object.assign(this, {x, y}); } } （2）为对象添加方法 Object.assign(SomeClass.prototype, { someMethod(arg1, arg2) { ··· }, anotherMethod() { ··· } }); // 等同于下面的写法 SomeClass.prototype.someMethod = function (arg1, arg2) { ··· }; SomeClass.prototype.anotherMethod = function () { ··· }; （3）克隆对象 将原始对象拷贝到一个空对象，就得到了原始对象的克隆。采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。 function clone(origin) { return Object.assign({}, origin); } 如果想要保持继承链，可以采用下面的代码。 function clone(origin) { let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin); } （4）合并多个对象 将多个对象合并到某个对象。 const merge = (target, ...sources) => Object.assign(target, ...sources); 如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。 const merge = (...sources) => Object.assign({}, ...sources); （5）为属性指定默认值 const DEFAULTS = { logLevel: 0, outputFormat: 'html' }; function processContent(options) { options = Object.assign({}, DEFAULTS, options); console.log(options); // ... } 如果两者有同名属性，则options的属性值会覆盖DEFAULTS的属性值。 由于存在浅拷贝的问题，DEFAULTS对象和options对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS对象的该属性很可能不起作用。 const DEFAULTS = { url: { host: 'example.com', port: 7070 }, }; processContent({ url: {port: 8000} }) // { // url: {port: 8000} // } 上面代码的原意是将url.port改成 8000，url.host不变。实际结果却是options.url覆盖掉DEFAULTS.url，所以url.host就不存在了。 3. Object.getOwnPropertyDescriptors() 1）含义 返回指定对象所有自身属性（非继承属性）的描述对象。 ES5 的Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象 const obj = { foo: 123, get bar() { return 'abc' } }; Object.getOwnPropertyDescriptors(obj) // { foo: // { value: 123, // writable: true, // enumerable: true, // configurable: true }, // bar: // { get: [Function: get bar], // set: undefined, // enumerable: true, // configurable: true } } 2）用法 为了解决Object.assign()无法正确拷贝get属性和set属性 const source = { set foo(value) { console.log(value); } }; const target1 = {}; Object.assign(target1, source); Object.getOwnPropertyDescriptor(target1, 'foo') // { value: undefined, // writable: true, // enumerable: true, // configurable: true } 这时，Object.getOwnPropertyDescriptors()方法配合Object.defineProperties()方法，就可以实现正确拷贝。 const source = { set foo(value) { console.log(value); } }; const target2 = {}; Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source)); Object.getOwnPropertyDescriptor(target2, 'foo') // { get: undefined, // set: [Function: set foo], // enumerable: true, // configurable: true } // 等同于 const shallowMerge = (target, source) => Object.defineProperties( target, Object.getOwnPropertyDescriptors(source) ); Object.getOwnPropertyDescriptors()方法的另一个用处，是配合Object.create()方法，将对象属性克隆到一个新对象。这属于浅拷贝。 const clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)); // 或者 const shallowClone = (obj) => Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj) ); 另外，Object.getOwnPropertyDescriptors()方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。 const obj = { __proto__: prot, foo: 123, }; ES6 规定__proto__只有浏览器要部署，其他环境不用部署。如果去除__proto__，上面代码就要改成下面这样。 const obj = Object.create(prot); obj.foo = 123; // 或者 const obj = Object.assign( Object.create(prot), { foo: 123, } ); 有了Object.getOwnPropertyDescriptors()，我们就有了另一种写法。 const obj = Object.create( prot, Object.getOwnPropertyDescriptors({ foo: 123, }) ); Object.getOwnPropertyDescriptors()也可以用来实现 Mixin（混入）模式。 let mix = (object) => ({ with: (...mixins) => mixins.reduce( (c, mixin) => Object.create( c, Object.getOwnPropertyDescriptors(mixin) ), object) }); // multiple mixins example let a = {a: 'a'}; let b = {b: 'b'}; let c = {c: 'c'}; let d = mix(c).with(a, b); d.c // \"c\" d.b // \"b\" d.a // \"a\" 4. __proto__属性，Object.setPrototypeOf(), Object.getPrototypeOf() 1）__proto__属性 （1）含义 __proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。 // es5 的写法 const obj = { method: function() { ... } }; obj.__proto__ = someOtherObj; // es6 的写法 var obj = Object.create(someOtherObj); obj.method = function() { ... }; 标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。 如果一个对象本身部署了__proto__属性，该属性的值就是对象的原型。 Object.getPrototypeOf({ __proto__: null }) // null 2） Object.setPrototypeOf() Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。 let proto = {}; let obj = { x: 10 }; Object.setPrototypeOf(obj, proto); proto.y = 20; proto.z = 40; obj.x // 10 obj.y // 20 obj.z // 40 上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。 如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。 Object.setPrototypeOf(1, {}) === 1 // true Object.setPrototypeOf('foo', {}) === 'foo' // true Object.setPrototypeOf(true, {}) === true // true 由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。 Object.setPrototypeOf(undefined, {}) // TypeError: Object.setPrototypeOf called on null or undefined Object.setPrototypeOf(null, {}) // TypeError: Object.setPrototypeOf called on null or undefined 3） Object.getPrototypeOf() 该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。 Object.getPrototypeOf(obj); function Rectangle() { // ... } const rec = new Rectangle(); Object.getPrototypeOf(rec) === Rectangle.prototype // true Object.setPrototypeOf(rec, Object.prototype); Object.getPrototypeOf(rec) === Rectangle.prototype // false 如果参数不是对象，会被自动转为对象。 // 等同于 Object.getPrototypeOf(Number(1)) Object.getPrototypeOf(1) // Number {[[PrimitiveValue]]: 0} // 等同于 Object.getPrototypeOf(String('foo')) Object.getPrototypeOf('foo') // String {length: 0, [[PrimitiveValue]]: \"\"} // 等同于 Object.getPrototypeOf(Boolean(true)) Object.getPrototypeOf(true) // Boolean {[[PrimitiveValue]]: false} Object.getPrototypeOf(1) === Number.prototype // true Object.getPrototypeOf('foo') === String.prototype // true Object.getPrototypeOf(true) === Boolean.prototype // true 如果参数是undefined或null，它们无法转为对象，所以会报错。 Object.getPrototypeOf(null) // TypeError: Cannot convert undefined or null to object Object.getPrototypeOf(undefined) // TypeError: Cannot convert undefined or null to object 5. Object.keys(), Object.values(), Object.entries() * 1）Object.keys() * （1）含义 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 var obj = { foo: 'bar', baz: 42 }; Object.keys(obj) // [\"foo\", \"baz\"] （2）用法 作为遍历一个对象的补充手段，供for...of循环使用。 let {keys, values, entries} = Object; let obj = { a: 1, b: 2, c: 3 }; for (let key of keys(obj)) { console.log(key); // 'a', 'b', 'c' } 2）Object.values() * （1）含义 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。 const obj = { foo: 'bar', baz: 42 }; Object.values(obj) // [\"bar\", 42] 返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。 const obj = { 100: 'a', 2: 'b', 7: 'c' }; Object.values(obj) // [\"b\", \"c\", \"a\"] 上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a。 （2）用法 Object.values只返回对象自身的可遍历属性。 const obj = Object.create({}, {p: {value: 42}}); Object.values(obj) // [] 上面代码中，Object.create方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p的属性描述对象的enumerable默认是false，Object.values不会返回这个属性。只要把enumerable改成true，Object.values就会返回属性p的值。 const obj = Object.create({}, {p: { value: 42, enumerable: true } }); Object.values(obj) // [42] Object.values会过滤属性名为 Symbol 值的属性。 Object.values({ [Symbol()]: 123, foo: 'abc' }); // ['abc'] 如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。 Object.values('foo') // ['f', 'o', 'o'] 如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组。 Object.values(42) // [] Object.values(true) // [] 3）Object.entries() * （1）含义 Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 const obj = { foo: 'bar', baz: 42 }; Object.entries(obj) // [ [\"foo\", \"bar\"], [\"baz\", 42] ] （2）用法 如果原对象的属性名是一个 Symbol 值，该属性会被忽略。 Object.entries({ [Symbol()]: 123, foo: 'abc' }); // [ [ 'foo', 'abc' ] ] Object.entries的基本用途是遍历对象的属性。 let obj = { one: 1, two: 2 }; for (let [k, v] of Object.entries(obj)) { console.log( `${JSON.stringify(k)}: ${JSON.stringify(v)}` ); } // \"one\": 1 // \"two\": 2 Object.entries方法的另一个用处是，将对象转为真正的Map结构。 const obj = { foo: 'bar', baz: 42 }; const map = new Map(Object.entries(obj)); console.log(map)// Map { foo: \"bar\", baz: 42 } 7. Object.fromEntries() * 1）含义 Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。 Object.fromEntries([ ['foo', 'bar'], ['baz', 42] ]) // { foo: \"bar\", baz: 42 } 2）用法 该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。 // 例一 const entries = new Map([ ['foo', 'bar'], ['baz', 42] ]); Object.fromEntries(entries) // { foo: \"bar\", baz: 42 } // 例二 const map = new Map().set('foo', true).set('bar', false); Object.fromEntries(map) // { foo: true, bar: false } 该方法的一个用处是配合URLSearchParams对象，将查询字符串转为对象 Object.fromEntries(new URLSearchParams('?foo=bar&baz=qux')) // { foo: \"bar\", baz: \"qux\" } Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 22:44 "},"Symbol.html":{"url":"Symbol.html","title":"Symbol","keywords":"","body":"Symbol 1. 概述 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型 前六种是：undefined、null、boolean、number、string、object Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。 let s = Symbol(); typeof s // \"symbol\" 注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 let s1 = Symbol('foo'); let s2 = Symbol('bar'); s1 // Symbol(foo) s2 // Symbol(bar) s1.toString() // \"Symbol(foo)\" s2.toString() // \"Symbol(bar)\" 注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。 // 没有参数的情况 let s1 = Symbol(); let s2 = Symbol(); s1 === s2 // false // 有参数的情况 let s1 = Symbol('foo'); let s2 = Symbol('foo'); s1 === s2 // false Symbol 值不能与其他类型的值进行运算，会报错。 let sym = Symbol('My symbol'); \"your symbol is \" + sym // TypeError: can't convert symbol to string `your symbol is ${sym}` // TypeError: can't convert symbol to string 但是，Symbol 值可以显式转为字符串。 let sym = Symbol('My symbol'); String(sym) // 'Symbol(My symbol)' sym.toString() // 'Symbol(My symbol)' 另外，Symbol 值也可以转为布尔值，但是不能转为数值。 let sym = Symbol(); Boolean(sym) // true !sym // false if (sym) { // ... } Number(sym) // TypeError sym + 2 // TypeError 2. Symbol.prototype.description * 创建 Symbol 的时候，可以添加一个描述。ES2019 提供了一个实例属性description，直接返回 Symbol 的描述。 const sym = Symbol('foo'); sym.description // \"foo\" 3. 作为属性名的 Symbol * Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。 let mySymbol = Symbol(); // 第一种写法 let a = {}; a[mySymbol] = 'Hello!'; // 第二种写法 let a = { [mySymbol]: 'Hello!' }; // 第三种写法 let a = {}; Object.defineProperty(a, mySymbol, { value: 'Hello!' }); // 以上写法都得到同样结果 a[mySymbol] // \"Hello!\" 在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。 let s = Symbol(); let obj = { [s]: function (arg) { ... } }; obj[s](123); 4. 实例：消除魔术字符串 * 常用的消除魔术字符串的方法，就是把它写成一个变量。 const shapeType = { triangle: 'Triangle' }; function getArea(shape, options) { let area = 0; switch (shape) { case shapeType.triangle: area = .5 * options.width * options.height; break; } return area; } getArea(shapeType.triangle, { width: 100, height: 100 }); 如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用 Symbol 值。 const shapeType = { triangle: Symbol() }; 5. 属性名的遍历 * Symbol 作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。 但是，它也不是私有属性，有一个Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 const obj = {}; let a = Symbol('a'); let b = Symbol('b'); obj[a] = 'Hello'; obj[b] = 'World'; const objectSymbols = Object.getOwnPropertySymbols(obj); objectSymbols // [Symbol(a), Symbol(b)] Object.getOwnPropertySymbols()方法与for...in循环、Object.getOwnPropertyNames方法进行对比的例子。 const obj = {}; const foo = Symbol('foo'); obj[foo] = 'bar'; for (let i in obj) { console.log(i); // 无输出 } Object.getOwnPropertyNames(obj) // [] Object.getOwnPropertySymbols(obj) // [Symbol(foo)] Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 let obj = { [Symbol('my_key')]: 1, enum: 2, nonEnum: 3 }; Reflect.ownKeys(obj) // [\"enum\", \"nonEnum\", Symbol(my_key)] 由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。 let size = Symbol('size'); class Collection { constructor() { this[size] = 0; } add(item) { this[this[size]] = item; this[size]++; } static sizeOf(instance) { return instance[size]; } } let x = new Collection(); Collection.sizeOf(x) // 0 x.add('foo'); Collection.sizeOf(x) // 1 Object.keys(x) // ['0'] Object.getOwnPropertyNames(x) // ['0'] Object.getOwnPropertySymbols(x) // [Symbol(size)] 6. Symbol.for(), Symbol.keyFor() * 1）Symbol.for() （1）含义 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。 let s1 = Symbol.for('foo'); let s2 = Symbol.for('foo'); s1 === s2 // true （2）用法 Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。 Symbol.for(\"bar\") === Symbol.for(\"bar\") // true Symbol(\"bar\") === Symbol(\"bar\") // false 2）Symbol.keyFor() （1）含义 Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。Symbol则无返回key let s1 = Symbol.for(\"foo\"); Symbol.keyFor(s1) // \"foo\" let s2 = Symbol(\"foo\"); Symbol.keyFor(s2) // undefined （2）用法 Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。 function foo() { return Symbol.for('bar'); } const x = foo(); const y = Symbol.for('bar'); console.log(x === y); // true Symbol.for()的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。 iframe = document.createElement('iframe'); iframe.src = String(window.location); document.body.appendChild(iframe); iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo') // true 7. 实例：模块的 Singleton 模式 * 1）含义 Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。 2）用法 对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？很容易想到，可以把实例放到顶层对象global。 // mod.js function A() { this.foo = 'hello'; } if (!global._foo) { global._foo = new A(); } module.exports = global._foo; 然后，加载上面的mod.js。 const a = require('./mod.js'); console.log(a.foo); // 'hello' 但是，这里有一个问题，全局变量global._foo是可写的，任何文件都可以修改。 global._foo = { foo: 'world' }; const a = require('./mod.js'); console.log(a.foo); // 'world' 为了防止这种情况出现，我们就可以使用 Symbol。 // mod.js const FOO_KEY = Symbol.for('foo'); function A() { this.foo = 'hello'; } if (!global[FOO_KEY]) { global[FOO_KEY] = new A(); } module.exports = global[FOO_KEY]; 上面代码中，可以保证global[FOO_KEY]不会被无意间覆盖，但还是可以被改写。 global[Symbol.for('foo')] = { foo: 'world' }; const a = require('./mod.js'); console.log(a.foo); // 'world' 如果键名使用Symbol方法生成，那么外部将无法引用这个值，当然也就无法改写。 // mod.js const FOO_KEY = Symbol('foo'); // 后面代码相同 …… 上面代码将导致其他脚本都无法引用FOO_KEY。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的FOO_KEY都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 22:44 "},"Set-Map.html":{"url":"Set-Map.html","title":"Set 和 Map 数据结构","keywords":"","body":"Set 和 Map 数据结构 1.Set 1）Set用法 类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成 Set 数据结构。 const s = new Set(); [2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x)); for (let i of s) { console.log(i); } // 2 3 5 4 上面代码通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。 Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。 // 例一 const set = new Set([1, 2, 3, 4, 4]); [...set] // [1, 2, 3, 4] // 例二 const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]); items.size // 5 // 例三 const set = new Set(document.querySelectorAll('div')); set.size // 56 上面代码也展示了一种去除数组重复成员的方法。 [...new Set('ababbc')].join('') // \"abc\" 向 Set 加入值的时候，不会发生类型转换，所以5和\"5\"是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===） 主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。 let set = new Set(); let a = NaN; let b = NaN; set.add(a); set.add(b); set // Set {NaN} 2）Set 实例的属性和方法 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。 四个操作方法 Set.prototype.add(value)：添加某个值，返回 Set 结构本身。 Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 Set.prototype.clear()：清除所有成员，没有返回值。 let s = new Set(); s.add(1).add(2).add(2); // 注意2被加入了两次 s.size // 2 s.has(1) // true s.has(2) // true s.has(3) // false s.delete(2); s.has(2) // false Array.from方法可以将 Set 结构转为数组。 const items = new Set([1, 2, 3, 4, 5]); const array = Array.from(items); 这就提供了去除数组重复成员的另一种方法。 function dedupe(array) { return Array.from(new Set(array)); } dedupe([1, 1, 2, 3]) // [1, 2, 3] 3）Set 实例的遍历操作 Set 结构的实例有四个遍历方法，可以用于遍历成员。 Set.prototype.keys()：返回键名的遍历器 Set.prototype.values()：返回键值的遍历器 Set.prototype.entries()：返回键值对的遍历器 Set.prototype.forEach()：使用回调函数遍历每个成员 Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。 （1）keys(), values(), entries() keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 let set = new Set(['red', 'green', 'blue']); for (let item of set.keys()) { console.log(item); } // red // green // blue for (let item of set.values()) { console.log(item); } // red // green // blue for (let item of set.entries()) { console.log(item); } // [\"red\", \"red\"] // [\"green\", \"green\"] // [\"blue\", \"blue\"] Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。 Set.prototype[Symbol.iterator] === Set.prototype.values // true 这意味着，可以省略values方法，直接用for...of循环遍历 Set。 let set = new Set(['red', 'green', 'blue']); for (let x of set) { console.log(x); } // red // green // blue （2）forEach() Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。 let set = new Set([1, 4, 9]); set.forEach((value, key) => console.log(key + ' : ' + value)) // 1 : 1 // 4 : 4 // 9 : 9 forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。 （3）遍历的应用 扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。 let set = new Set(['red', 'green', 'blue']); let arr = [...set]; // ['red', 'green', 'blue'] 扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。 let arr = [3, 5, 2, 2, 5, 5]; let unique = [...new Set(arr)]; // [3, 5, 2] 数组的map和filter方法也可以间接用于 Set 了。 let set = new Set([1, 2, 3]); set = new Set([...set].map(x => x * 2)); // 返回Set结构：{2, 4, 6} let set = new Set([1, 2, 3, 4, 5]); set = new Set([...set].filter(x => (x % 2) == 0)); // 返回Set结构：{2, 4} 因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。 let a = new Set([1, 2, 3]); let b = new Set([4, 3, 2]); // 并集 let union = new Set([...a, ...b]); // Set {1, 2, 3, 4} // 交集 let intersect = new Set([...a].filter(x => b.has(x))); // set {2, 3} // 差集 let difference = new Set([...a].filter(x => !b.has(x))); // Set {1} 如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。 // 方法一 let set = new Set([1, 2, 3]); set = new Set([...set].map(val => val * 2)); // set的值是2, 4, 6 // 方法二 let set = new Set([1, 2, 3]); set = new Set(Array.from(set, val => val * 2)); // set的值是2, 4, 6 2. WeakSet 1）WeakSet含义 WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。 const ws = new WeakSet(); ws.add(1) // TypeError: Invalid value used in weak set ws.add(Symbol()) // TypeError: invalid value used in weak set 上面代码试图向 WeakSet 添加一个数值和Symbol值，结果报错，因为 WeakSet 只能放置对象。 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。ES6 规定 WeakSet 不可遍历。 2）WeakSet语法 WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构。 const a = [[1, 2], [3, 4]]; const ws = new WeakSet(a); // WeakSet {[1, 2], [3, 4]} 注意，是a数组的成员成为 WeakSet 的成员，而不是a数组本身。这意味着，数组的成员只能是对象。 const b = [3, 4]; const ws = new WeakSet(b); // Uncaught TypeError: Invalid value used in weak set(…) WeakSet 结构有以下三个方法。 WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。 WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。 const ws = new WeakSet(); const obj = {}; const foo = {}; ws.add(window); ws.add(obj); ws.has(window); // true ws.has(foo); // false ws.delete(window); ws.has(window); // false WeakSet 没有size属性，没有办法遍历它的成员。 ws.size // undefined ws.forEach // undefined ws.forEach(function(item){ console.log('WeakSet has ' + item)}) // TypeError: undefined is not a function const foos = new WeakSet() class Foo { constructor() { foos.add(this) } method () { if (!foos.has(this)) { throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！'); } } } 3. Map 1）Map含义 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 const m = new Map(); const o = {p: 'Hello World'}; m.set(o, 'content') m.get(o) // \"content\" m.has(o) // true m.delete(o) // true m.has(o) // false 上面代码使用 Map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。 Map构造函数接受数组作为参数，实际上执行的是下面的算法。 const items = [ ['name', '张三'], ['title', 'Author'] ]; const map = new Map(); items.forEach( ([key, value]) => map.set(key, value) ); 事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。 const set = new Set([ ['foo', 1], ['bar', 2] ]); const m1 = new Map(set); m1.get('foo') // 1 const m2 = new Map([['baz', 3]]); const m3 = new Map(m2); m3.get('baz') // 3 如果读取一个未知的键，则返回undefined。 new Map().get('asfddfsasadf') // undefined 注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。 const map = new Map(); map.set(['a'], 555); map.get(['a']) // undefined 同样的值的两个实例，在 Map 结构中被视为两个键。 Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 2）Map实例的属性和操作方法 （1）size属性 size属性返回 Map 结构的成员总数。 const map = new Map(); map.set('foo', true); map.set('bar', false); map.size // 2 （2）Map.prototype.set(key,value) set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。 const m = new Map(); m.set('edition', 6) // 键是字符串 m.set(262, 'standard') // 键是数值 m.set(undefined, 'nah') // 键是 undefined set方法返回的是当前的Map对象，因此可以采用链式写法。 let map = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c'); （3）Map.prototype.get(key) get方法读取key对应的键值，如果找不到key，返回undefined。 const m = new Map(); const hello = function() {console.log('hello');}; m.set(hello, 'Hello ES6!') // 键是函数 m.get(hello) // Hello ES6! （4）Map.prototype.has(key) has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 const m = new Map(); m.set('edition', 6); m.set(262, 'standard'); m.set(undefined, 'nah'); m.has('edition') // true m.has('years') // false m.has(262) // true m.has(undefined) // true （5）Map.prototype.delete(key) delete方法删除某个键，返回true。如果删除失败，返回false。 const m = new Map(); m.set(undefined, 'nah'); m.has(undefined) // true m.delete(undefined) m.has(undefined) // false （6）Map.prototype.clear() clear方法清除所有成员，没有返回值。 let map = new Map(); map.set('foo', true); map.set('bar', false); map.size // 2 map.clear() map.size // 0 3）遍历方法 Map 结构原生提供三个遍历器生成函数和一个遍历方法。 Map.prototype.keys()：返回键名的遍历器。 Map.prototype.values()：返回键值的遍历器。 Map.prototype.entries()：返回所有成员的遍历器。 Map.prototype.forEach()：遍历 Map 的所有成员。 const map = new Map([ ['F', 'no'], ['T', 'yes'], ]); for (let key of map.keys()) { console.log(key); } // \"F\" // \"T\" for (let value of map.values()) { console.log(value); } // \"no\" // \"yes\" for (let item of map.entries()) { console.log(item[0], item[1]); } // \"F\" \"no\" // \"T\" \"yes\" // 或者 for (let [key, value] of map.entries()) { console.log(key, value); } // \"F\" \"no\" // \"T\" \"yes\" for (let [key, value] of map) { console.log(key, value); } // \"F\" \"no\" // \"T\" \"yes\" // Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。 map[Symbol.iterator] === map.entries // true Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。 const map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'], ]); [...map.keys()] // [1, 2, 3] [...map.values()] // ['one', 'two', 'three'] [...map.entries()] // [[1,'one'], [2, 'two'], [3, 'three']] 4） 与其他数据结构的互相转换 （1）Map转为数组 Map 转为数组最方便的方法，就是使用扩展运算符（...）。 const myMap = new Map() .set(true, 7) .set({foo: 3}, ['abc']); [...myMap] // [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ] （2）数组转为 Map 将数组传入 Map 构造函数，就可以转为 Map。 new Map([ [true, 7], [{foo: 3}, ['abc']] ]) // Map { // true => 7, // Object {foo: 3} => ['abc'] // } （3）Map 转为对象 如果所有 Map 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。 function strMapToObj(strMap) { let obj = Object.create(null); for (let [k,v] of strMap) { obj[k] = v; } return obj; } const myMap = new Map() .set('yes', true) .set('no', false); strMapToObj(myMap) // { yes: true, no: false } （4） 对象转为Map 对象转为 Map 可以通过Object.entries()。 let obj = {\"a\":1, \"b\":2}; let map = new Map(Object.entries(obj)); （5）Map转为 json Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。 function strMapToJson(strMap) { return JSON.stringify(strMapToObj(strMap)); } let myMap = new Map().set('yes', true).set('no', false); strMapToJson(myMap) // '{\"yes\":true,\"no\":false}' 一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。 function mapToArrayJson(map) { return JSON.stringify([...map]); } let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']); mapToArrayJson(myMap) // '[[true,7],[{\"foo\":3},[\"abc\"]]]' （6）JSON转Map JSON 转为 Map，正常情况下，所有键名都是字符串。 function jsonToStrMap(jsonStr) { return objToStrMap(JSON.parse(jsonStr)); } jsonToStrMap('{\"yes\": true, \"no\": false}') // Map {'yes' => true, 'no' => false} 4. WeakMap 1）WeakMap 含义 WeakMap结构与Map结构类似，也是用于生成键值对的集合。 // WeakMap 可以使用 set 方法添加成员 const wm1 = new WeakMap(); const key = {foo: 1}; wm1.set(key, 2); wm1.get(key) // 2 // WeakMap 也可以接受一个数组， // 作为构造函数的参数 const k1 = [1, 2, 3]; const k2 = [4, 5, 6]; const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]); wm2.get(k2) // \"bar\" 2）WeakMap 用法 WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。 const map = new WeakMap(); map.set(1, 2) // TypeError: 1 is not an object! map.set(Symbol(), 2) // TypeError: Invalid value used as weak map key map.set(null, 2) // TypeError: Invalid value used as weak map key 如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。 const wm = new WeakMap(); const element = document.getElementById('example'); wm.set(element, 'some information'); wm.get(element) // \"some information\" WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。 const wm = new WeakMap(); let key = {}; let obj = {foo: 1}; wm.set(key, obj); obj = null; wm.get(key) // Object {foo: 1} 3）WeakMap 的语法 WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。 WeakMap只有四个方法可用：get()、set()、has()、delete()。 const wm = new WeakMap(); // size、forEach、clear 方法都不存在 wm.size // undefined wm.forEach // undefined wm.clear // undefined 4）WeakMap 用途 WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。 let myWeakmap = new WeakMap(); myWeakmap.set( document.getElementById('logo'), {timesClicked: 0}) ; document.getElementById('logo').addEventListener('click', function() { let logoData = myWeakmap.get(document.getElementById('logo')); logoData.timesClicked++; }, false); WeakMap 的另一个用处是部署私有属性。 const _counter = new WeakMap(); const _action = new WeakMap(); class Countdown { constructor(counter, action) { _counter.set(this, counter); _action.set(this, action); } dec() { let counter = _counter.get(this); if (counter console.log('DONE')); c.dec() c.dec() // DONE Countdown类的两个内部属性_counter和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-01 22:14 "},"Proxy.html":{"url":"Proxy.html","title":"Proxy","keywords":"","body":"Proxy 1. 含义 Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 拦截读取属性行为的例子。 var proxy = new Proxy({}, { get: function(target, propKey) { return 35; } }); proxy.time // 35 proxy.name // 35 proxy.title // 35 配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。 如果handler没有设置任何拦截，那就等同于直接通向原对象。 var target = {}; var handler = {}; var proxy = new Proxy(target, handler); proxy.a = 'b'; target.a // \"b\" 一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用。 var object = { proxy: new Proxy(target, handler) }; 同一个拦截器函数，可以设置拦截多个操作。 var handler = { get: function(target, name) { if (name === 'prototype') { return Object.prototype; } return 'Hello, ' + name; }, apply: function(target, thisBinding, args) { return args[0]; }, construct: function(target, args) { return {value: args[1]}; } }; var fproxy = new Proxy(function(x, y) { return x + y; }, handler); fproxy(1, 2) // 1 new fproxy(1, 2) // {value: 2} fproxy.prototype === Object.prototype // true fproxy.foo === \"Hello, foo\" // true 下面是 Proxy 支持的拦截操作一览，一共 13 种。 has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。 deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。 2. get() * 1）get() 含义 get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。 2）get() 用法 拦截读取操作的例子。 var person = { name: \"张三\" }; var proxy = new Proxy(person, { get: function(target, propKey) { if (propKey in target) { return target[propKey]; } else { throw new ReferenceError(\"Prop name \\\"\" + propKey + \"\\\" does not exist.\"); } } }); proxy.name // \"张三\" proxy.age // 抛出一个错误 如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。 get方法可以继承。 let proto = new Proxy({}, { get(target, propertyKey, receiver) { console.log('GET ' + propertyKey); return target[propertyKey]; } }); let obj = Object.create(proto); obj.foo // \"GET foo\" 下面的例子是利用get拦截，实现一个生成各种 DOM 节点的通用函数dom。 const dom = new Proxy({}, { get(target, property) { return function(attrs = {}, ...children) { const el = document.createElement(property); for (let prop of Object.keys(attrs)) { el.setAttribute(prop, attrs[prop]); } for (let child of children) { if (typeof child === 'string') { child = document.createTextNode(child); } el.appendChild(child); } return el; } } }); const el = dom.div({}, 'Hello, my name is ', dom.a({href: '//example.com'}, 'Mark'), '. I like:', dom.ul({}, dom.li({}, 'The web'), dom.li({}, 'Food'), dom.li({}, '…actually that\\'s it') ) ); document.body.appendChild(el); get方法的第三个参数，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。 const proxy = new Proxy({}, { get: function(target, key, receiver) { return receiver; } }); proxy.getReceiver === proxy // true proxy对象的getReceiver属性是由proxy对象提供的，所以receiver指向proxy对象。 const proxy = new Proxy({}, { get: function(target, key, receiver) { return receiver; } }); const d = Object.create(proxy); d.a === d // true d对象本身没有a属性，所以读取d.a的时候，会去d的原型proxy对象找。这时，receiver就指向d，代表原始的读操作所在的那个对象。 3. set() * 1）set() 含义 set(target, propKey, value, receiver)：拦截某个属性的赋值操作，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。 2）set() 用法 假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求。 let validator = { set: function(obj, prop, value) { if (prop === 'age') { if (!Number.isInteger(value)) { throw new TypeError('The age is not an integer'); } if (value > 200) { throw new RangeError('The age seems invalid'); } } // 对于满足条件的 age 属性以及其他属性，直接保存 obj[prop] = value; } }; let person = new Proxy({}, validator); person.age = 100; person.age // 100 person.age = 'young' // 报错 person.age = 300 // 报错 有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。 const handler = { get (target, key) { invariant(key, 'get'); return target[key]; }, set (target, key, value) { invariant(key, 'set'); target[key] = value; return true; } }; function invariant (key, action) { if (key[0] === '_') { throw new Error(`Invalid attempt to ${action} private \"${key}\" property`); } } const target = {}; const proxy = new Proxy(target, handler); proxy._prop // Error: Invalid attempt to get private \"_prop\" property proxy._prop = 'c' // Error: Invalid attempt to set private \"_prop\" property 上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。 set方法的第四个参数receiver，指的是原始的操作行为所在的那个对象，一般情况下是proxy实例本身 3. apply() 1）apply() 含义 apply方法拦截函数的调用、call和apply操作。 apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。 var target = function () { return 'I am the target'; }; var handler = { apply: function () { return 'I am the proxy'; } }; var p = new Proxy(target, handler); p() // \"I am the proxy\" 2）apply() 用法 var twice = { apply (target, ctx, args) { return Reflect.apply(...arguments) * 2; } }; function sum (left, right) { return left + right; }; var proxy = new Proxy(sum, twice); proxy(1, 2) // 6 proxy.call(null, 5, 6) // 22 proxy.apply(null, [7, 8]) // 30 上面代码中，每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截。 直接调用Reflect.apply方法，也会被拦截。 Reflect.apply(proxy, null, [9, 10]) // 38 3. has() 1）has() 含义 has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。 2）has() 用法 has方法可以接受两个参数，分别是目标对象、需查询的属性名。 下面的例子使用has方法隐藏某些属性，不被in运算符发现。 var handler = { has (target, key) { if (key[0] === '_') { return false; } return key in target; } }; var target = { _prop: 'foo', prop: 'foo' }; var proxy = new Proxy(target, handler); '_prop' in proxy // false 值得注意的是，has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。 4. construct() 1）construct() 含义 construct方法用于拦截new命令，下面是拦截对象的写法。 var handler = { construct (target, args, newTarget) { return new target(...args); } }; 2）construct() 用法 construct方法可以接受三个参数。 target：目标对象 args：构造函数的参数对象 newTarget：创造实例对象时，new命令作用的构造函数（下面例子的p） var p = new Proxy(function () {}, { construct: function(target, args) { console.log('called: ' + args.join(', ')); return { value: args[0] * 10 }; } }); (new p(1)).value // \"called: 1\" // 10 construct方法返回的必须是一个对象，否则会报错。 var p = new Proxy(function() {}, { construct: function(target, argumentsList) { return 1; } }); new p() // 报错 // Uncaught TypeError: 'construct' on proxy: trap returned non-object ('1') 5. deleteProperty() 1）deleteProperty() 含义 deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。 2）deleteProperty() 用法 var handler = { deleteProperty (target, key) { invariant(key, 'delete'); delete target[key]; return true; } }; function invariant (key, action) { if (key[0] === '_') { throw new Error(`Invalid attempt to ${action} private \"${key}\" property`); } } var target = { _prop: 'foo' }; var proxy = new Proxy(target, handler); delete proxy._prop // Error: Invalid attempt to delete private \"_prop\" property 上面代码中，deleteProperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错。 6. defineProperty() defineProperty方法拦截了Object.defineProperty操作。 var handler = { defineProperty (target, key, descriptor) { return false; } }; var target = {}; var proxy = new Proxy(target, handler); proxy.foo = 'bar' // 不会生效 7. getOwnPropertyDescriptor() getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。 var handler = { getOwnPropertyDescriptor (target, key) { if (key[0] === '_') { return; } return Object.getOwnPropertyDescriptor(target, key); } }; var target = { _foo: 'bar', baz: 'tar' }; var proxy = new Proxy(target, handler); Object.getOwnPropertyDescriptor(proxy, 'wat') // undefined Object.getOwnPropertyDescriptor(proxy, '_foo') // undefined Object.getOwnPropertyDescriptor(proxy, 'baz') // { value: 'tar', writable: true, enumerable: true, configurable: true } 8. getPrototypeOf() getPrototypeOf方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。 Object.prototype.__proto__ Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof 例如 var proto = {}; var p = new Proxy({}, { getPrototypeOf(target) { return proto; } }); Object.getPrototypeOf(p) === proto // true 9. isExtensible() isExtensible方法拦截Object.isExtensible操作。 var p = new Proxy({}, { isExtensible: function(target) { console.log(\"called\"); return true; } }); Object.isExtensible(p) // \"called\" // true 10. ownKeys() 1）含义 ownKeys方法用来拦截对象自身属性的读取操作。例如： Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() for...in循环 拦截Object.keys()的例子 let target = { a: 1, b: 2, c: 3 }; let handler = { ownKeys(target) { return ['a']; } }; let proxy = new Proxy(target, handler); Object.keys(proxy) // [ 'a' ] 上面代码拦截了对于target对象的Object.keys()操作，只返回a、b、c三个属性之中的a属性。 2） ownKeys() 用法 拦截第一个字符为下划线的属性名。 let target = { _bar: 'foo', _prop: 'bar', prop: 'baz' }; let handler = { ownKeys (target) { return Reflect.ownKeys(target).filter(key => key[0] !== '_'); } }; let proxy = new Proxy(target, handler); for (let key of Object.keys(proxy)) { console.log(target[key]); } // \"baz\" 使用Object.keys方法时，有三类属性会被ownKeys方法自动过滤，不会返回。 目标对象上不存在的属性 属性名为 Symbol 值 不可遍历（enumerable）的属性 11. preventExtensions() preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。 这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。 var proxy = new Proxy({}, { preventExtensions: function(target) { return true; } }); Object.preventExtensions(proxy) // Uncaught TypeError: 'preventExtensions' on proxy: trap returned truish but the proxy target is extensible 通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensions。 var proxy = new Proxy({}, { preventExtensions: function(target) { console.log('called'); Object.preventExtensions(target); return true; } }); Object.preventExtensions(proxy) // \"called\" // Proxy {} 12. setPrototypeOf() setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。 var handler = { setPrototypeOf (target, proto) { throw new Error('Changing the prototype is forbidden'); } }; var proto = {}; var target = function () {}; var proxy = new Proxy(target, handler); Object.setPrototypeOf(proxy, proto); // Error: Changing the prototype is forbidden 只要修改target的原型对象，就会报错。 13 Proxy.revocable() Proxy.revocable方法返回一个可取消的 Proxy 实例。 let target = {}; let handler = {}; let {proxy, revoke} = Proxy.revocable(target, handler); proxy.foo = 123; proxy.foo // 123 revoke(); proxy.foo // TypeError: Revoked Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。 14. this 问题 虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 const target = { m: function () { console.log(this === proxy); } }; const handler = {}; const proxy = new Proxy(target, handler); target.m() // false proxy.m() // true 一旦proxy代理target.m，后者内部的this就是指向proxy，而不是target。 下面是一个例子，由于this指向的变化，导致 Proxy 无法代理目标对象。 const _name = new WeakMap(); class Person { constructor(name) { _name.set(this, name); } get name() { return _name.get(this); } } const jane = new Person('Jane'); jane.name // 'Jane' const proxy = new Proxy(jane, {}); proxy.name // undefined 有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。 const target = new Date(); const handler = {}; const proxy = new Proxy(target, handler); proxy.getDate(); // TypeError: this is not a Date object. 上面代码中，getDate方法只能在Date对象实例上面拿到，如果this不是Date对象实例就会报错。这时，this绑定原始对象，就可以解决这个问题。 const target = new Date('2015-01-01'); const handler = { get(target, prop) { if (prop === 'getDate') { return target.getDate.bind(target); } return Reflect.get(target, prop); } }; const proxy = new Proxy(target, handler); proxy.getDate() // 1 15. 实例：web服务的客户端 Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。 const service = createWebService('http://example.com/data'); service.employees().then(json => { const employees = JSON.parse(json); // ··· }); Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。 function createWebService(baseUrl) { return new Proxy({}, { get(target, propKey, receiver) { return () => httpGet(baseUrl + '/' + propKey); } }); } 同理，Proxy 也可以用来实现数据库的 ORM 层。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-03 21:34 "},"Reflect.html":{"url":"Reflect.html","title":"Reflect","keywords":"","body":"Reflect 1. 概述 Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 // 老写法 try { Object.defineProperty(target, property, attributes); // success } catch (e) { // failure } // 新写法 if (Reflect.defineProperty(target, property, attributes)) { // success } else { // failure } 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 // 老写法 'assign' in Object // true // 新写法 Reflect.has(Object, 'assign') // true Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 Proxy(target, { set: function(target, name, value, receiver) { var success = Reflect.set(target, name, value, receiver); if (success) { console.log('property ' + name + ' on ' + target + ' set to ' + value); } return success; } }); 有了Reflect对象以后，很多操作会更易读。 // 老写法 Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1 // 新写法 Reflect.apply(Math.floor, undefined, [1.75]) // 1 2. Reflect.get(target, name, receiver) Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。 var myObject = { foo: 1, bar: 2, get baz() { return this.foo + this.bar; }, } Reflect.get(myObject, 'foo') // 1 Reflect.get(myObject, 'bar') // 2 Reflect.get(myObject, 'baz') // 3 如果第一个参数不是对象，Reflect.get方法会报错。 Reflect.get(1, 'foo') // 报错 Reflect.get(false, 'foo') // 报错 如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。 var myObject = { foo: 1, bar: 2, get baz() { return this.foo + this.bar; }, }; var myReceiverObject = { foo: 4, bar: 4, }; Reflect.get(myObject, 'baz', myReceiverObject) // 8 3. Reflect.set() Reflect.set方法设置target对象的name属性等于value。 var myObject = { foo: 1, set bar(value) { return this.foo = value; }, } myObject.foo // 1 Reflect.set(myObject, 'foo', 2); myObject.foo // 2 Reflect.set(myObject, 'bar', 3) myObject.foo // 3 如果name属性设置了赋值函数，则赋值函数的this绑定receiver。 var myObject = { foo: 4, set bar(value) { return this.foo = value; }, }; var myReceiverObject = { foo: 0, }; Reflect.set(myObject, 'bar', 1, myReceiverObject); myObject.foo // 4 myReceiverObject.foo // 1 4. Reflect.has(obj, name) Reflect.has方法对应name in obj里面的in运算符。 var myObject = { foo: 1, }; // 旧写法 'foo' in myObject // true // 新写法 Reflect.has(myObject, 'foo') // true 5. Reflect.deleteProperty(obj, name) Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。 const myObj = { foo: 'bar' }; // 旧写法 delete myObj.foo; // 新写法 Reflect.deleteProperty(myObj, 'foo'); 该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。 6. Reflect.construct(target, args) Reflect.construct方法等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。 function Greeting(name) { this.name = name; } // new 的写法 const instance = new Greeting('张三'); // Reflect.construct 的写法 const instance = Reflect.construct(Greeting, ['张三']); 7. Reflect.getPrototypeOf()obj Reflect.getPrototypeOf方法用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。 const myObj = new FancyThing(); // 旧写法 Object.getPrototypeOf(myObj) === FancyThing.prototype; // 新写法 Reflect.getPrototypeOf(myObj) === FancyThing.prototype; 8. Reflect.setPrototypeOf(obj, newProto) Reflect.setPrototypeOf方法用于设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。它返回一个布尔值，表示是否设置成功。 const myObj = {}; // 旧写法 Object.setPrototypeOf(myObj, Array.prototype); // 新写法 Reflect.setPrototypeOf(myObj, Array.prototype); myObj.length // 0 9. Reflect.apply(func, thisArg, args) Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。 const ages = [11, 33, 12, 54, 18, 96]; // 旧写法 const youngest = Math.min.apply(Math, ages); const oldest = Math.max.apply(Math, ages); const type = Object.prototype.toString.call(youngest); // 新写法 const youngest = Reflect.apply(Math.min, Math, ages); const oldest = Reflect.apply(Math.max, Math, ages); const type = Reflect.apply(Object.prototype.toString, youngest, []); 10. Reflect.defineProperty(target, propertyKey, attributes) Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。 function MyDate() { /*…*/ } // 旧写法 Object.defineProperty(MyDate, 'now', { value: () => Date.now() }); // 新写法 Reflect.defineProperty(MyDate, 'now', { value: () => Date.now() }); 这个方法可以与Proxy.defineProperty配合使用。 const p = new Proxy({}, { defineProperty(target, prop, descriptor) { console.log(descriptor); return Reflect.defineProperty(target, prop, descriptor); } }); p.foo = 'bar'; // {value: \"bar\", writable: true, enumerable: true, configurable: true} p.foo // \"bar\" Proxy.defineProperty对属性赋值设置了拦截，然后使用Reflect.defineProperty完成了赋值。 11. Reflect.getOwnPropertyDescriptor(target, propertyKey) Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。 var myObject = {}; Object.defineProperty(myObject, 'hidden', { value: true, enumerable: false, }); // 旧写法 var theDescriptor = Object.getOwnPropertyDescriptor(myObject, 'hidden'); // 新写法 var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, 'hidden'); 12. Reflect.isExtensible(target) Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。 const myObject = {}; // 旧写法 Object.isExtensible(myObject) // true // 新写法 Reflect.isExtensible(myObject) // true 13. Reflect.preventExtensions(target) Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。 var myObject = {}; // 旧写法 Object.preventExtensions(myObject) // Object {} // 新写法 Reflect.preventExtensions(myObject) // true 14. Reflect.ownKeys(target) Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。 var myObject = { foo: 1, bar: 2, [Symbol.for('baz')]: 3, [Symbol.for('bing')]: 4, }; // 旧写法 Object.getOwnPropertyNames(myObject) // ['foo', 'bar'] Object.getOwnPropertySymbols(myObject) //[Symbol(baz), Symbol(bing)] // 新写法 Reflect.ownKeys(myObject) // ['foo', 'bar', Symbol(baz), Symbol(bing)] 15. 实例： 使用Proxy实现观察者模式 * 观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。 const person = observable({ name: '张三', age: 20 }); function print() { console.log(`${person.name}, ${person.age}`) } observe(print); person.name = '李四'; // 输出 // 李四, 20 上面代码中，数据对象person是观察目标，函数print是观察者。一旦数据对象发生变化，print就会自动执行。 下面，使用 Proxy 写一个观察者模式的最简单实现，即实现observable和observe这两个函数。思路是observable函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。 const queuedObservers = new Set(); const observe = fn => queuedObservers.add(fn); const observable = obj => new Proxy(obj, {set}); function set(target, key, value, receiver) { const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer => observer()); return result; } Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-03 21:34 "},"Promise.html":{"url":"Promise.html","title":"Promise","keywords":"","body":"Promise 对象 1. 含义 Promise 是异步编程的一种解决方案，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 Promise对象有以下两个特点。 对象的状态不受外界影响。有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 2. 基本用法 ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 const promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”，并将异步操作的结果，作为参数传递出去 reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 promise.then(function(value) { // success }, function(error) { // failure }); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。 下面是异步加载图片的例子。 function loadImageAsync(url) { return new Promise(function(resolve, reject) { const image = new Image(); image.onload = function() { resolve(image); }; image.onerror = function() { reject(new Error('Could not load image at ' + url)); }; image.src = url; }); } 下面是一个用Promise对象实现的 Ajax 操作的例子。 const getJSON = function(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); }); return promise; }; getJSON(\"/posts.json\").then(function(json) { console.log('Contents: ' + json); }, function(error) { console.error('出错了', error); }); resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例 const p1 = new Promise(function (resolve, reject) { // ... }); const p2 = new Promise(function (resolve, reject) { // ... resolve(p1); }) 调用resolve或reject并不会终结 Promise 的参数函数的执行。 new Promise((resolve, reject) => { resolve(1); console.log(2); }).then(r => { console.log(r); }); // 2 // 1 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 new Promise((resolve, reject) => { return resolve(1); // 后面的语句不会执行 console.log(2); }) 3. Promise.prototype.then() Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 getJSON(\"/posts.json\").then(function(json) { return json.post; }).then(function(post) { // ... }); 前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 getJSON(\"/post/1.json\").then(function(post) { return getJSON(post.commentURL); }).then(function (comments) { console.log(\"resolved: \", comments); }, function (err){ console.log(\"rejected: \", err); }); 4. Promise.prototype.catch() Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 getJSON('/posts.json').then(function(posts) { // ... }).catch(function(error) { // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error); }); reject方法的作用，等同于抛出错误。 如果 Promise 状态已经变成resolved，再抛出错误是无效的。 const promise = new Promise(function(resolve, reject) { resolve('ok'); throw new Error('test'); }); promise .then(function(value) { console.log(value) }) .catch(function(error) { console.log(error) }); // ok Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 getJSON('/post/1.json').then(function(post) { return getJSON(post.commentURL); }).then(function(comments) { // some code }).catch(function(error) { // 处理前面三个Promise产生的错误 }); 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 // bad promise .then(function(data) { // success }, function(err) { // error }); // good promise .then(function(data) { //cb // success }) .catch(function(err) { // error }); 后者写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。 const someAsyncThing = function() { return new Promise(function(resolve, reject) { // 下面一行会报错，因为x没有声明 resolve(x + 2); }); }; someAsyncThing().then(function() { console.log('everything is great'); }); setTimeout(() => { console.log(123) }, 2000); // Uncaught (in promise) ReferenceError: x is not defined // 123 someAsyncThing函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 这个脚本放在服务器执行，退出码就是0（即表示执行成功）。不过，Node 有一个unhandledRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。 process.on('unhandledRejection', function (err, p) { throw err; }); Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。 const someAsyncThing = function() { return new Promise(function(resolve, reject) { // 下面一行会报错，因为x没有声明 resolve(x + 2); }); }; someAsyncThing() .catch(function(error) { console.log('oh no', error); }) .then(function() { console.log('carry on'); }); // oh no [ReferenceError: x is not defined] // carry on 5. Promise.prototype.finally() finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 promise .then(result => {···}) .catch(error => {···}) .finally(() => {···}); 6. Promise.all() Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 const p = Promise.all([p1, p2, p3]); p的状态由p1、p2、p3决定，分成两种情况。 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 // 生成一个Promise对象的数组 const promises = [2, 3, 5, 7, 11, 13].map(function (id) { return getJSON('/post/' + id + \".json\"); }); Promise.all(promises).then(function (posts) { // ... }).catch(function(reason){ // ... }); const databasePromise = connectDatabase(); const booksPromise = databasePromise .then(findAllBooks); const userPromise = databasePromise .then(getCurrentUser); Promise.all([ booksPromise, userPromise ]) .then(([books, user]) => pickTopRecommendations(books, user)); booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommendations这个回调函数。 如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 如果all的参数中任何一个有catch方法就不会走到all的catch方法 7. Promise.race() Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 const p = Promise.race([p1, p2, p3]); 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。 8. Promise.allSettled() Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。 const promises = [ fetch('/api-1'), fetch('/api-2'), fetch('/api-3'), ]; await Promise.allSettled(promises); removeLoadingIndicator(); 上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。 9. Promise.any() Promise.any()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。 Promise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。 const promises = [ fetch('/endpoint-a').then(() => 'a'), fetch('/endpoint-b').then(() => 'b'), fetch('/endpoint-c').then(() => 'c'), ]; try { const first = await Promise.any(promises); console.log(first); } catch (error) { console.log(error); } 10. Promise.resove() 有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。 const jsPromise = Promise.resolve($.ajax('/whatever.json')); Promise.resolve()等价于下面的写法。 Promise.resolve('foo') // 等价于 new Promise(resolve => resolve('foo')) Promise.resolve方法的参数分成四种情况。 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象,也就是具有then方法的对象 Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。 let thenable = { then: function(resolve, reject) { resolve(42); } }; let p1 = Promise.resolve(thenable); p1.then(function(value) { console.log(value); // 42 }); 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。 const p = Promise.resolve('Hello'); p.then(function (s){ console.log(s) }); // Hello Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。 const p = Promise.resolve(); p.then(function () { // ... }); setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。 setTimeout(function () { console.log('three'); }, 0); Promise.resolve().then(function () { console.log('two'); }); console.log('one'); // one // two // three 11. Promise.reject() Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 const p = Promise.reject('出错了'); // 等同于 const p = new Promise((resolve, reject) => reject('出错了')) p.then(null, function (s) { console.log(s) }); // 出错了 12. 应用 我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 const preloadImage = function (path) { return new Promise(function (resolve, reject) { const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; }); }; 13. Promise.try() 不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。 Promise.resolve().then(f) 上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。 const f = () => console.log('now'); Promise.resolve().then(f); console.log('next'); // next // now 那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。 const f = () => console.log('now'); (async () => f())(); console.log('next'); // now // next 第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步 (async () => f())() .then(...) async () => f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。 (async () => f())() .then(...) .catch(...) 第二种写法是使用new Promise()。 const f = () => console.log('now'); ( () => new Promise( resolve => resolve(f()) ) )(); console.log('next'); // now // next 由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。 function getUsername(userId) { return database.users.get({id: userId}) .then(function(user) { return user.name; }); } 上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。 database.users.get({id: userId}) .then(...) .catch(...) 但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。 try { database.users.get({id: userId}) .then(...) .catch(...) } catch (e) { // ... } 上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。 Promise.try(() => database.users.get({id: userId})) .then(...) .catch(...) Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-04 23:27 "},"Interator-for...of.html":{"url":"Interator-for...of.html","title":"Interator 和 for...of 循环","keywords":"","body":"Iterator 和 for... of 循环 1. Iterator 遍历器的概念 JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。 Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。 2. 默认 Iterator 接口 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。 默认的 Iterator 接口部署在数据结构的Symbol.iterator 对于类似数组的对象（存在数值键名和length属性），部署 Iterator 接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的 Iterator 接口。 NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator]; // 或者 NodeList.prototype[Symbol.iterator] = [][Symbol.iterator]; [...document.querySelectorAll('div')] // 可以执行了 类似数组的对象调用数组的Symbol.iterator方法的例子。 let iterable = { 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator] }; for (let item of iterable) { console.log(item); // 'a', 'b', 'c' } 普通对象部署数组的Symbol.iterator方法，并无效果。 let iterable = { a: 'a', b: 'b', c: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator] }; for (let item of iterable) { console.log(item); // undefined, undefined, undefined } 3. 调用 Iterator 接口的场合 1）解构赋值 对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。 let set = new Set().add('a').add('b').add('c'); let [x,y] = set; // x='a'; y='b' let [first, ...rest] = set; // first='a'; rest=['b','c']; 2）扩展运算符 扩展运算符（...）也会调用默认的 Iterator 接口。 // 例一 var str = 'hello'; [...str] // ['h','e','l','l','o'] // 例二 let arr = ['b', 'c']; ['a', ...arr, 'd'] // ['a', 'b', 'c', 'd'] 这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。 3）yield* yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 let generator = function* () { yield 1; yield* [2,3,4]; yield 5; }; var iterator = generator(); iterator.next() // { value: 1, done: false } iterator.next() // { value: 2, done: false } iterator.next() // { value: 3, done: false } iterator.next() // { value: 4, done: false } iterator.next() // { value: 5, done: false } iterator.next() // { value: undefined, done: true } 4）其他场合 for...of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])） Promise.all() Promise.race() 4. 字符串的 Iterator 接口 字符串是一个类似数组的对象，也原生具有 Iterator 接口。 var someString = \"hi\"; typeof someString[Symbol.iterator] // \"function\" var iterator = someString[Symbol.iterator](); iterator.next() // { value: \"h\", done: false } iterator.next() // { value: \"i\", done: false } iterator.next() // { value: undefined, done: true } 5. Iterator接口和 Generator函数 let obj = { * [Symbol.iterator]() { yield 'hello'; yield 'world'; } }; for (let x of obj) { console.log(x); } // \"hello\" // \"world\" 6. 遍历器对象的 return()， throw() 遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。 return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。 function readLinesSync(file) { return { [Symbol.iterator]() { return { next() { return { done: false }; }, return() { file.close(); return { done: true }; } }; }, }; } 函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。下面的两种情况，都会触发执行return方法。 // 情况一 for (let line of readLinesSync(fileName)) { console.log(line); break; } // 情况二 for (let line of readLinesSync(fileName)) { console.log(line); throw new Error(); } 情况一输出文件的第一行以后，就会执行return方法，关闭这个文件；情况二会在执行return方法关闭文件之后，再抛出错误。 注意，return方法必须返回一个对象，这是 Generator 规格决定的。 7. for...of 循环 * for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串。 1）数组 数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for...of循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。 const arr = ['red', 'green', 'blue']; for(let v of arr) { console.log(v); // red green blue } const obj = {}; obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr); for(let v of obj) { console.log(v); // red green blue } for...of循环可以代替数组实例的forEach方法。 arr.forEach(function (element, index) { console.log(element); // red green blue console.log(index); // 0 1 2 }); for...in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。 var arr = ['a', 'b', 'c', 'd']; for (let a in arr) { console.log(a); // 0 1 2 3 } for (let a of arr) { console.log(a); // a b c d } for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。 let arr = [3, 5, 7]; arr.foo = 'hello'; for (let i in arr) { console.log(i); // \"0\", \"1\", \"2\", \"foo\" } for (let i of arr) { console.log(i); // \"3\", \"5\", \"7\" } 2）Set 和 Map结构 Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for...of循环。 var engines = new Set([\"Gecko\", \"Trident\", \"Webkit\", \"Webkit\"]); for (var e of engines) { console.log(e); } // Gecko // Trident // Webkit var es6 = new Map(); es6.set(\"edition\", 6); es6.set(\"committee\", \"TC39\"); es6.set(\"standard\", \"ECMA-262\"); for (var [name, value] of es6) { console.log(name + \": \" + value); } // edition: 6 // committee: TC39 // standard: ECMA-262 3）计算生成的数据结构 有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。 entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。 keys() 返回一个遍历器对象，用来遍历所有的键名。 values() 返回一个遍历器对象，用来遍历所有的键值。 var engines = new Set([\"Gecko\", \"Trident\", \"Webkit\", \"Webkit\"]); for (let [key, value] of engines.entries()) { console.log(key,value); } // Gecko Gecko // Trident Trident // Webkit Webkit 4）类似数组的对象 类似数组的对象包括好几类：字符串、DOM NodeList 对象、arguments对象。 // 字符串 let str = \"hello\"; for (let s of str) { console.log(s); // h e l l o } // DOM NodeList对象 let paras = document.querySelectorAll(\"p\"); for (let p of paras) { p.classList.add(\"test\"); } // arguments对象 function printArgs() { for (let x of arguments) { console.log(x); } } printArgs('a', 'b'); // 'a' // 'b' 并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。 let arrayLike = { length: 2, 0: 'a', 1: 'b' }; // 报错 for (let x of arrayLike) { console.log(x); } // 正确 for (let x of Array.from(arrayLike)) { console.log(x); } 5）对象 对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for...in循环依然可以用来遍历键名。 let es6 = { edition: 6, committee: \"TC39\", standard: \"ECMA-262\" }; for (let e in es6) { console.log(e); } // edition // committee // standard for (let e of es6) { console.log(e); } // TypeError: es6[Symbol.iterator] is not a function 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。 for (var key of Object.keys(someObject)) { console.log(key + ': ' + someObject[key]); } 另一个方法是使用 Generator 函数将对象重新包装一下。 function* entries(obj) { for (let key of Object.keys(obj)) { yield [key, obj[key]]; } } for (let [key, value] of entries(obj)) { console.log(key, '->', value); } // a -> 1 // b -> 2 // c -> 3 6）与其他遍历语法比较 （1）for循环/forEach() for (var index = 0; index myArray.forEach(function (value) { console.log(value); }); 这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。 （2）for... in for (var index in myArray) { console.log(myArray[index]); } for...in循环有几个缺点。 数组的键名是数字，但是for...in循环是以字符串作为键名“0”、“1”、“2”等等。 for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。 某些情况下，for...in循环会以任意顺序遍历键名。 for...in循环主要是为遍历对象而设计的，不适用于遍历数组。 （3）for...of for (let value of myArray) { console.log(value); } for...of循环相比上面几种做法，有一些显著的优点。 有着同for...in一样的简洁语法，但是没有for...in那些缺点。 不同于forEach方法，它可以与break、continue和return配合使用。 提供了遍历所有数据结构的统一操作接口。 for (var n of fibonacci) { if (n > 1000) break; console.log(n); } 上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用break语句跳出for...of循环。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-04 23:27 "},"Generator.html":{"url":"Generator.html","title":"Generator函数的语法","keywords":"","body":"Generator 函数的语法 1. 简介 1）基本概念 Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。 Generator 函数有多种理解角度。语法上，首先可以把它理解成Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 function* helloWorldGenerator() { yield 'hello'; yield 'world'; return 'ending'; } var hw = helloWorldGenerator(); 调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。 必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 hw.next() // { value: 'hello', done: false } hw.next() // { value: 'world', done: false } hw.next() // { value: 'ending', done: true } hw.next() // { value: undefined, done: true } ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。 function * foo(x, y) { ··· } function *foo(x, y) { ··· } function* foo(x, y) { ··· } function*foo(x, y) { ··· } 由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。 2）yield 表达式 由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined。 需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 function* gen() { yield 123 + 456; } yield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。 Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。 function* f() { console.log('执行了！') } var generator = f(); setTimeout(function () { generator.next() }, 2000); 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个 Generator 函数，就变成只有调用next方法时，函数f才会执行。 yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。不能用在forEach循环中，如果使用改为for循环 yield表达式如果用在另一个表达式之中，必须放在圆括号里面。 function* demo() { console.log('Hello' + yield); // SyntaxError console.log('Hello' + yield 123); // SyntaxError console.log('Hello' + (yield)); // OK console.log('Hello' + (yield 123)); // OK } yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。 function* demo() { foo(yield 'a', yield 'b'); // OK let input = yield; // OK } 3）与Iterator 接口的关系 任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。 由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。 var myIterable = {}; myIterable[Symbol.iterator] = function* () { yield 1; yield 2; yield 3; }; [...myIterable] // [1, 2, 3] Generator 函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了 Iterator 接口，可以被...运算符遍历了。 Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。 function* gen(){ // some code } var g = gen(); g[Symbol.iterator]() === g // true gen是一个 Generator 函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。 2. next 方法的参数 yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 function* f() { for(var i = 0; true; i++) { var reset = yield i; if(reset) { i = -1; } } } var g = f(); g.next() // { value: 0, done: false } g.next() // { value: 1, done: false } g.next(true) // { value: 0, done: false } 上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 3. for...of循环 for...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。 function* foo() { yield 1; yield 2; yield 3; yield 4; yield 5; return 6; } for (let v of foo()) { console.log(v); } // 1 2 3 4 5 下面是一个利用 Generator 函数和for...of循环，实现斐波那契数列的例子。 function* fibonacci() { let [prev, curr] = [0, 1]; for (;;) { yield curr; [prev, curr] = [curr, prev + curr]; } } for (let n of fibonacci()) { if (n > 1000) break; console.log(n); } 通过 Generator 函数为原生的 JavaScript 对象加上遍历接口 function* objectEntries(obj) { let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) { yield [propKey, obj[propKey]]; } } let jane = { first: 'Jane', last: 'Doe' }; for (let [key, value] of objectEntries(jane)) { console.log(`${key}: ${value}`); } // first: Jane // last: Doe 加上遍历器接口的另一种写法是，将 Generator 函数加到对象的Symbol.iterator属性上面。 function* objectEntries() { let propKeys = Object.keys(this); for (let propKey of propKeys) { yield [propKey, this[propKey]]; } } let jane = { first: 'Jane', last: 'Doe' }; jane[Symbol.iterator] = objectEntries; for (let [key, value] of jane) { console.log(`${key}: ${value}`); } // first: Jane // last: Doe 扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。 function* numbers () { yield 1 yield 2 return 3 yield 4 } // 扩展运算符 [...numbers()] // [1, 2] // Array.from 方法 Array.from(numbers()) // [1, 2] // 解构赋值 let [x, y] = numbers(); x // 1 y // 2 // for...of 循环 for (let n of numbers()) { console.log(n) } // 1 // 2 4. Generator函数应用场景 1）让函数返回多个值 function* calculate(a, b) { yield a + b; yield a - b; } let it = calculate(10, 5); console.log(it.next().value);// 10 console.log(it.next().value);// 5 2）利用Generator函数可以在任意对象上快速部署 Iterator接口 function* gen() { let keys = Object.keys(obj); for (let i = 0; i 3）用同步的流程来表示异步的操作 function request() { return new Promise(function (resolve, reject) { setTimeout(function () { resolve(\"拿到的数据\"); }, 1000); }); } function* gen() { yield request(); yield request(); yield request(); } let it = gen(); it.next().value.then(function (data) { console.log(data, 1); return it.next().value; }).then(function (data) { console.log(data, 2); return it.next().value; }).then(function (data) { console.log(data, 3); }); 5. yield* 表达式 ES6 提供了yield*表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。 function* foo() { yield 'a'; yield 'b'; } function* bar() { yield 'x'; yield* foo(); yield 'y'; } // 等同于 function* bar() { yield 'x'; yield 'a'; yield 'b'; yield 'y'; } Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-05 23:04 "},"Generator-async.html":{"url":"Generator-async.html","title":"Generator函数的异步调用","keywords":"","body":"Generator 函数的异步应用 异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。 1. 什么是异步 所谓\"异步\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 2. 回调函数 JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是\"重新调用\"。 fs.readFile('/etc/passwd', 'utf-8', function (err, data) { if (err) throw err; console.log(data); }); 上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。 一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？ 原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。 3. Promise 回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。 fs.readFile(fileA, 'utf-8', function (err, data) { fs.readFile(fileB, 'utf-8', function (err, data) { // ... }); }); 不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为\"回调函数地狱\"（callback hell）。 Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。 var readFile = require('fs-readfile-promise'); readFile(fileA) .then(function (data) { console.log(data.toString()); }) .then(function () { return readFile(fileB); }) .then(function (data) { console.log(data.toString()); }) .catch(function (err) { console.log(err); }); Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。 Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 4. Generator 函数 1）协程 传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做\"协程\"（coroutine），意思是多个线程互相协作，完成异步任务。 协程有点像函数，又有点像线程。它的运行流程大致如下。 第一步，协程A开始执行。 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。 第三步，（一段时间后）协程B交还执行权。 第四步，协程A恢复执行。 上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 举例来说，读取文件的协程写法如下。 function* asyncJob() { // ...其他代码 var f = yield readFile(fileA); // ...其他代码 } 上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。 协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。 2）协程的Generator 函数实现 Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator 函数的执行方法如下。 function* gen(x) { var y = yield x + 2; return y; } var g = gen(1); g.next() // { value: 3, done: false } g.next() // { value: undefined, done: true } next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。 3）Generator 函数的数据交换和数据处理 Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。 next返回值的 value 属性，是 Generator 函数向外输出数据；next方法还可以接受参数，向 Generator 函数体内输入数据。 function* gen(x){ var y = yield x + 2; return y; } var g = gen(1); g.next() // { value: 3, done: false } g.next(2) // { value: 2, done: true } Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 function* gen(x){ try { var y = yield x + 2; } catch (e){ console.log(e); } return y; } var g = gen(1); g.next(); g.throw('出错了'); // 出错了 4）异步任务的封装 下面看看如何使用 Generator 函数，执行一个真实的异步任务。 var fetch = require('node-fetch'); function* gen(){ var url = 'https://api.github.com/users/github'; var result = yield fetch(url); console.log(result.bio); } 上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。 执行这段代码的方法如下。 var g = gen(); var result = g.next(); result.value.then(function(data){ return data.json(); }).then(function(data){ g.next(data); }); 上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。 可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。 5. Thunk 函数 Thunk 函数是自动执行 Generator 函数的一种方法。 1）参数的求值策略 \"求值策略\"，即函数的参数到底应该何时求值。 var x = 1; function f(m) { return m * 2; } f(x + 5) \"传值调用\"（call by value）：比如C 语言： 先计算 x+5再把之歌值传入 f函数 “传名调用”（call by name）：比如Haskell 语言： 先把x+5传入 f函数，用到的时候在求值 回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。 function f(a, b){ return b; } f(3 * x * x - 2 * x - 1, x); 函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于\"传名调用\"，即只在执行时求值。 2） Thunk函数的含义 编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。 function f(m) { return m * 2; } f(x + 5); // 等同于 var thunk = function () { return x + 5; }; function f(thunk) { return thunk() * 2; } 上面代码中，函数 f 的参数x + 5被一个函数替换了。凡是用到原参数的地方，对Thunk函数求值即可。 这就是 Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。 3）Javascript 语言的 Thunk 函数 JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。 // 正常版本的readFile（多参数版本） fs.readFile(fileName, callback); // Thunk版本的readFile（单参数版本） var Thunk = function (fileName) { return function (callback) { return fs.readFile(fileName, callback); }; }; var readFileThunk = Thunk(fileName); readFileThunk(callback); 上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。 任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。 function f(a, cb) { cb(a); } const ft = Thunk(f); ft(1)(console.log) // 1 4）Thunkify模块 * 生产环境的转换器，建议使用 Thunkify 模块。 首先是安装。 $ npm install thunkify 使用方式如下。 var thunkify = require('thunkify'); var fs = require('fs'); var read = thunkify(fs.readFile); read('package.json')(function(err, str){ // ... }); 5）Generator 函数的流程管理 你可能会问， Thunk 函数有什么用？回答是以前确实没什么用，但是 ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理。 Generator 函数可以自动执行。 function* gen() { // ... } var g = gen(); var res = g.next(); while(!res.done){ console.log(res.value); res = g.next(); } 但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk 函数就能派上用处。以读取文件为例。下面的 Generator 函数封装了两个异步操作。 var fs = require('fs'); var thunkify = require('thunkify'); var readFileThunk = thunkify(fs.readFile); var gen = function* (){ var r1 = yield readFileThunk('/etc/fstab'); console.log(r1.toString()); var r2 = yield readFileThunk('/etc/shells'); console.log(r2.toString()); }; yield命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。Thunk 函数就派上用场了，因为它可以在回调函数里，将执行权交还给 Generator 函数。 var g = gen(); var r1 = g.next(); r1.value(function (err, data) { if (err) throw err; var r2 = g.next(data); r2.value(function (err, data) { if (err) throw err; g.next(data); }); }); 6）Thunk 函数的自动流程管理 Thunk 函数真正的威力，在于可以自动执行 Generator 函数。 function run(fn) { var gen = fn(); function next(err, data) { var result = gen.next(data); if (result.done) return; result.value(next); } next(); } function* g() { // ... } run(g); 有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入run函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在yield命令后面的必须是 Thunk 函数。 var g = function* (){ var f1 = yield readFileThunk('fileA'); var f2 = yield readFileThunk('fileB'); // ... var fn = yield readFileThunk('fileN'); }; run(g); 上面代码中，函数g封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。 Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。 6. co 模块 1）基本用法 用于 Generator 函数的自动执行。 下面是一个 Generator 函数，用于依次读取两个文件。 var gen = function* () { var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString()); }; co 模块可以让你不用编写 Generator 函数的执行器。 var co = require('co'); co(gen); 上面代码中，Generator 函数只要传入co函数，就会自动执行。 co函数返回一个Promise对象，因此可以用then方法添加回调函数。 co(gen).then(function (){ console.log('Generator 函数执行完成'); }); 上面代码中，等到 Generator 函数执行结束，就会输出一行提示。 2）co 模块的原理 为什么 co 可以自动执行 Generator 函数？ 前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。 两种方法可以做到这一点。 回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。 Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。 co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co 3）基于 Promise 对象的自动执行 首先，把fs模块的readFile方法包装成一个 Promise 对象。 var fs = require('fs'); var readFile = function (fileName){ return new Promise(function (resolve, reject){ fs.readFile(fileName, function(error, data){ if (error) return reject(error); resolve(data); }); }); }; var gen = function* (){ var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString()); }; 然后，手动执行上面的 Generator 函数。 var g = gen(); g.next().value.then(function(data){ g.next(data).value.then(function(data){ g.next(data); }); }); 手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。 function run(gen){ var g = gen(); function next(data){ var result = g.next(data); if (result.done) return result.value; result.value.then(function(data){ next(data); }); } next(); } run(gen); 上面代码中，只要 Generator 函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。 4）co 模块的源码 co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。 首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。 function co(gen) { var ctx = this; return new Promise(function(resolve, reject) { }); } 在返回的 Promise 对象里面，co 先检查参数gen是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为resolved。 function co(gen) { var ctx = this; return new Promise(function(resolve, reject) { if (typeof gen === 'function') gen = gen.call(ctx); if (!gen || typeof gen.next !== 'function') return resolve(gen); }); } 接着，co 将 Generator 函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。 function co(gen) { var ctx = this; return new Promise(function(resolve, reject) { if (typeof gen === 'function') gen = gen.call(ctx); if (!gen || typeof gen.next !== 'function') return resolve(gen); onFulfilled(); function onFulfilled(res) { var ret; try { ret = gen.next(res); } catch (e) { return reject(e); } next(ret); } }); } 最后，就是关键的next函数，它会反复调用自身。 function next(ret) { if (ret.done) return resolve(ret.value); var value = toPromise.call(ctx, ret.value); if (value && isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected( new TypeError( 'You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: \"' + String(ret.value) + '\"' ) ); } 5）处理并发的异步操作 co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。 这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。 // 数组的写法 co(function* () { var res = yield [ Promise.resolve(1), Promise.resolve(2) ]; console.log(res); }).catch(onerror); // 对象的写法 co(function* () { var res = yield { 1: Promise.resolve(1), 2: Promise.resolve(2), }; console.log(res); }).catch(onerror); 6）处理 Stream Node 提供 Stream 模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream 模式使用 EventEmitter API，会释放三个事件。 data事件：下一块数据块已经准备好了。 end事件：整个“数据流”处理完了。 error事件：发生错误。 使用Promise.race()函数，可以判断这三个事件之中哪一个最先发生，只有当data事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个while循环，完成所有数据的读取。 const co = require('co'); const fs = require('fs'); const stream = fs.createReadStream('./les_miserables.txt'); let valjeanCount = 0; co(function*() { while(true) { const res = yield Promise.race([ new Promise(resolve => stream.once('data', resolve)), new Promise(resolve => stream.once('end', resolve)), new Promise((resolve, reject) => stream.once('error', reject)) ]); if (!res) { break; } stream.removeAllListeners('data'); stream.removeAllListeners('end'); stream.removeAllListeners('error'); valjeanCount += (res.toString().match(/valjean/ig) || []).length; } console.log('count:', valjeanCount); // count: 1120 }); 上面代码采用 Stream 模式读取《悲惨世界》的文本文件，对于每个数据块都使用stream.once方法，在data、end、error三个事件上添加一次性回调函数。变量res只有在data事件发生时才有值，然后累加每个数据块之中valjean这个词出现的次数。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-05 23:04 "},"async.html":{"url":"async.html","title":"async函数","keywords":"","body":"async 函数 1. 含义 async 函数是什么？一句话，它就是 Generator 函数的语法糖。 const fs = require('fs'); const readFile = function (fileName) { return new Promise(function (resolve, reject) { fs.readFile(fileName, function(error, data) { if (error) return reject(error); resolve(data); }); }); }; const gen = function* () { const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString()); }; 上面代码的函数gen可以写成async函数，就是下面这样。 const asyncReadFile = async function () { const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString()); }; 一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。 async函数对 Generator 函数的改进，体现在以下四点。 内置执行器。 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 asyncReadFile(); 上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。 更好的语义。 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 更广的适用性。 co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。 返回值是 Promise。 async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。 2. 基本用法 async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 function timeout(ms) { return new Promise((resolve) => { setTimeout(resolve, ms); }); } async function asyncPrint(value, ms) { await timeout(ms); console.log(value); } asyncPrint('hello world', 3000); 3000 毫秒以后，输出hello world。 由于async函数返回的是 Promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式。 async function timeout(ms) { await new Promise((resolve) => { setTimeout(resolve, ms); }); } async function asyncPrint(value, ms) { await timeout(ms); console.log(value); } asyncPrint('hello world', 50); async 函数有多种使用形式。 函数声明 async function foo() {} 函数表达式 const foo = async function () {}; 对象的方法 let obj = { async foo() {} }; obj.foo().then(...) Class 的方法 class Storage { constructor() { this.cachePromise = caches.open('avatars'); } async getAvatar(name) { const cache = await this.cachePromise; return cache.match(`/avatars/${name}.jpg`); } } const storage = new Storage(); storage.getAvatar('jake').then(…); 箭头函数 const foo = async () => {}; 3. 语法 async函数的语法规则总体上比较简单，难点是错误处理机制。 1）返回 Promise 对象 async函数内部return语句返回的值，会成为then方法回调函数的参数。 async function f() { return 'hello world'; } f().then(v => console.log(v)) // \"hello world\" async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。 async function f() { throw new Error('出错了'); } f().then( v => console.log(v), e => console.log(e) ) // Error: 出错了 2）Promise 对象的状态变化 async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 async function getTitle(url) { let response = await fetch(url); let html = await response.text(); return html.match(/([\\s\\S]+)/i)[1]; } getTitle('https://tc39.github.io/ecma262/').then(console.log) // \"ECMAScript 2017 Language Specification\" 函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。 3）await 命令 正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。 async function f() { // 等同于 // return 123; return await 123; } f().then(v => console.log(v)) // 123 await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。 async function f() { await Promise.reject('出错了'); } f() .then(v => console.log('v',v)) .catch(e => console.log('e',e)) // e 出错了 await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。 任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。 async function f() { await Promise.reject('出错了'); await Promise.resolve('hello world'); // 不会执行 } f() .then(v => console.log('v',v)) .catch(e => console.log('e',e)) // e 出错了 有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。 async function f() { try { await Promise.reject('出错了'); } catch(e) { } return await Promise.resolve('hello world'); } f() .then(v => console.log(v)) // hello world 另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。 async function f() { await Promise.reject('出错了') .catch(e => console.log(e)); return await Promise.resolve('hello world'); } f() .then(v => console.log(v)) // 出错了 // hello world 4）错误处理 如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。 async function f() { await new Promise(function (resolve, reject) { throw new Error('出错了'); }); } f() .then(v => console.log('v',v)) .catch(e => console.log('e',e)) // e Error：出错了 async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。 防止出错的方法，也是将其放在try...catch代码块之中。 async function f() { try { await new Promise(function (resolve, reject) { throw new Error('出错了'); }); } catch(e) { } return await('hello world'); } 如果有多个await命令，可以统一放在try...catch结构中。 async function main() { try { const val1 = await firstStep(); const val2 = await secondStep(val1); const val3 = await thirdStep(val1, val2); console.log('Final: ', val3); } catch (err) { console.error(err); } } 下面的例子使用try...catch结构，实现多次重复尝试。* const superagent = require('superagent'); const NUM_RETRIES = 3; async function test() { let i; for (i = 0; i 上面代码中，如果await操作成功，就会使用break语句退出循环；如果失败，会被catch语句捕捉，然后进入下一轮循环。 5）使用注意点 await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。 async function myFunction() { try { await somethingThatReturnsAPromise(); } catch (err) { console.log(err); } } // 另一种写法 async function myFunction() { await somethingThatReturnsAPromise() .catch(function (err) { console.log(err); }); } 多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 let foo = await getFoo(); let bar = await getBar(); 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。 // 写法一 let [foo, bar] = await Promise.all([getFoo(), getBar()]); // 写法二 let fooPromise = getFoo(); let barPromise = getBar(); let foo = await fooPromise; let bar = await barPromise; 上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。 await命令只能用在async函数之中，如果用在普通函数，就会报错。 async function dbFuc(db) { let docs = [{}, {}, {}]; // 报错 docs.forEach(function (doc) { await db.post(doc); }); } 如果将forEach方法的参数改成async函数，也有问题。 function dbFuc(db) { //这里不需要 async let docs = [{}, {}, {}]; // 可能得到错误结果 docs.forEach(async function (doc) { await db.post(doc); }); } 上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。 async function dbFuc(db) { let docs = [{}, {}, {}]; for (let doc of docs) { await db.post(doc); } } 另一种方法是使用数组的reduce方法。 async function dbFuc(db) { let docs = [{}, {}, {}]; await docs.reduce(async (_, doc) => { await _; await db.post(doc); }, undefined); } 如果确实希望多个请求并发执行，可以使用Promise.all方法。 async function dbFuc(db) { let docs = [{}, {}, {}]; let promises = docs.map((doc) => db.post(doc)); let results = await Promise.all(promises); console.log(results); } async 函数可以保留运行堆栈。 const a = () => { b().then(() => c()); }; 函数a内部运行了一个异步任务b()。当b()运行的时候，函数a()不会中断，而是继续执行。等到b()运行结束，可能a()早就运行结束了，b()所在的上下文环境已经消失了。如果b()或c()报错，错误堆栈将不包括a()。 将这个例子改成async函数。 const a = async () => { await b(); c(); }; b()运行的时候，a()是暂停执行，上下文环境都保存着。一旦b()或c()报错，错误堆栈将包括a()。 4. async 函数的实现原理 async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。 async function fn(args) { // ... } // 等同于 function fn(args) { return spawn(function* () { // ... }); } 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。 function spawn(genF) { return new Promise(function(resolve, reject) { const gen = genF(); function step(nextF) { let next; try { next = nextF(); } catch(e) { return reject(e); } if(next.done) { return resolve(next.value); } Promise.resolve(next.value).then(function(v) { step(function() { return gen.next(v); }); }, function(e) { step(function() { return gen.throw(e); }); }); } step(function() { return gen.next(undefined); }); }); } 5. 实例：按顺序完成异步操作 实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。 async 函数实现： async function logInOrder(urls) { for (const url of urls) { const response = await fetch(url); console.log(await response.text()); } } 上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。 async function logInOrder(urls) { // 并发读取远程URL const textPromises = urls.map(async url => { const response = await fetch(url); return response.text(); }); // 按次序输出 for (const textPromise of textPromises) { console.log(await textPromise); } } 6. 顶层 await 根据语法规格，await命令只能出现在 async 函数内部，否则都会报错。 const data = await fetch('https://api.example.com'); // 报错 目前，有一个语法提案，允许在模块的顶层独立使用await命令，使得上面那行代码不会报错了。这个提案的目的，是借用await解决模块异步加载的问题。 // awaiting.js let output; async function main() { const dynamic = await import(someMission); const data = await fetch(url); output = someProcess(dynamic.default, data); } main(); export { output }; 模块awaiting.js的输出值output，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量output才会有值，否则就返回undefined。 下面是加载这个模块的写法。 // usage.js import { output } from \"./awaiting.js\"; function outputPlusValue(value) { return output + value } console.log(outputPlusValue(100)); setTimeout(() => console.log(outputPlusValue(100), 1000); 上面代码中，outputPlusValue()的执行结果，完全取决于执行的时间。如果awaiting.js里面的异步操作没执行完，加载进来的output的值就是undefined。 目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。 // awaiting.js let output; export default (async function main() { const dynamic = await import(someMission); const data = await fetch(url); output = someProcess(dynamic.default, data); })(); export { output }; 上面代码中，awaiting.js除了输出output，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。 下面是加载这个模块的新的写法。 // usage.js import promise, { output } from \"./awaiting.js\"; function outputPlusValue(value) { return output + value } promise.then(() => { console.log(outputPlusValue(100)); setTimeout(() => console.log(outputPlusValue(100), 1000); }); 将awaiting.js对象的输出，放在promise.then()里面，这样就能保证异步操作完成以后，才去读取output。 这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的usage.js又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。 顶层的await命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。 // awaiting.js const dynamic = import(someMission); const data = fetch(url); export const output = someProcess((await dynamic).default, await data); 上面代码中，两个异步操作在输出的时候，都加上了await命令。只有等到异步操作完成，这个模块才会输出值。 加载这个模块的写法如下。 上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。 这时，模块的加载会等待依赖模块（上例是awaiting.js）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的output，不会因为加载时机的不同，而得到不一样的值。 下面是顶层await的一些使用场景。 // import() 方法加载 const strings = await import(`/i18n/${navigator.language}`); // 数据库操作 const connection = await dbConnector(); // 依赖回滚 let jQuery; try { jQuery = await import('https://cdn-a.com/jQuery'); } catch { jQuery = await import('https://cdn-b.com/jQuery'); } 注意，如果加载多个包含顶层await命令的模块，加载命令是同步执行的。 // x.js console.log(\"X1\"); await new Promise(r => setTimeout(r, 1000)); console.log(\"X2\"); // y.js console.log(\"Y\"); // z.js import \"./x.js\"; import \"./y.js\"; console.log(\"Z\"); 上面代码有三个模块，最后的z.js加载x.js和y.js，打印结果是X1、Y、X2、Z。这说明，z.js并没有等待x.js加载完成，再去加载y.js。 顶层的await命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 20:40 "},"Class.html":{"url":"Class.html","title":"Class的基本语法","keywords":"","body":"Class 的基本用法 1.简介 1）类的由来 JavaScript 语言中，生成实例对象的传统方法是通过构造函数。 function Point(x, y) { this.x = x; this.y = y; } Point.prototype.toString = function () { return '(' + this.x + ', ' + this.y + ')'; }; var p = new Point(1, 2); ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return '(' + this.x + ', ' + this.y + ')'; } } ES6 的类，完全可以看作构造函数的另一种写法。 class Point { // ... } typeof Point // \"function\" Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。 class Point { constructor() { // ... } toString() { // ... } toValue() { // ... } } // 等同于 Point.prototype = { constructor() {}, toString() {}, toValue() {}, }; 在类的实例上面调用方法，其实就是调用原型上的方法。 class B {} let b = new B(); b.constructor === B.prototype.constructor // true 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。 class Point { constructor(){ // ... } } Object.assign(Point.prototype, { toString(){}, toValue(){} }); 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 class Point { constructor(x, y) { // ... } toString() { // ... } } Object.keys(Point.prototype) // [] Object.getOwnPropertyNames(Point.prototype) // [\"constructor\",\"toString\"] ES5 var Point = function (x, y) { // ... }; Point.prototype.toString = function() { // ... }; Object.keys(Point.prototype) // [\"toString\"] Object.getOwnPropertyNames(Point.prototype) // [\"constructor\",\"toString\"] ES5 的写法，toString方法就是可枚举的。 2）constructor 方法 constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 class Point { } // 等同于 class Point { constructor() {} } constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 class Foo { constructor() { return Object.create(null); } } new Foo() instanceof Foo // false 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。 class Foo { constructor() { return Object.create(null); } } Foo() // TypeError: Class constructor Foo cannot be invoked without 'new' 3）类的实例 生成类的实例的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。 class Point { // ... } // 报错 var point = Point(2, 3); // 正确 var point = new Point(2, 3); 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 //定义类 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return '(' + this.x + ', ' + this.y + ')'; } } var point = new Point(2, 3); point.toString() // (2, 3) point.hasOwnProperty('x') // true point.hasOwnProperty('y') // true point.hasOwnProperty('toString') // false point.__proto__.hasOwnProperty('toString') // true 与 ES5 一样，类的所有实例共享一个原型对象。 var p1 = new Point(2,3); var p2 = new Point(3,2); p1.__proto__ === p2.__proto__ //true __proto__ 并不是语言本身的特性，生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。 var p1 = new Point(2,3); var p2 = new Point(3,2); p1.__proto__.printName = function () { return 'Oops' }; p1.printName() // \"Oops\" p2.printName() // \"Oops\" var p3 = new Point(4,2); p3.printName() // \"Oops\" 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。 4）取值函数（getter）和存值函数（setter） 与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 class MyClass { constructor() { // ... } get prop() { return 'getter'; } set prop(value) { console.log('setter: '+value); } } let inst = new MyClass(); inst.prop = 123; // setter: 123 inst.prop // 'getter' 存值函数和取值函数是设置在属性的 Descriptor 对象上的。 class CustomHTMLElement { constructor(element) { this.element = element; } get html() { return this.element.innerHTML; } set html(value) { this.element.innerHTML = value; } } var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, \"html\" ); \"get\" in descriptor // true \"set\" in descriptor // true 5）函数表达式 类的属性名，可以采用表达式。 let methodName = 'getArea'; class Square { constructor(length) { // ... } [methodName]() { // ... } } 6）Class表达式 与函数一样，类也可以使用表达式的形式定义。 const MyClass = class Me { getClassName() { return Me.name; } }; 需要注意的是，这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyClass引用。 let inst = new MyClass(); inst.getClassName() // Me let ne = new Me() // ReferenceError: Me is not defined 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 const MyClass = class { /* ... */ }; 采用 Class 表达式，可以写出立即执行的 Class。 let person = new class { constructor(name) { this.name = name; } sayName() { console.log(this.name); } }('张三'); person.sayName(); // \"张三\" 7）注意点 （1）严格模式 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。 （2）不存在变量提升 new Foo(); // ReferenceError class Foo {} （3）name属性 name属性总是返回紧跟在class关键字后面的类名。 class Point {} Point.name // \"Point\" （4）Generator 方法 如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。 class Foo { constructor(...args) { this.args = args; } * [Symbol.iterator]() { for (let arg of this.args) { yield arg; } } } for (let x of new Foo('hello', 'world')) { console.log(x); } // hello // world Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。 （5）this指向 类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 class Logger { printName(name = 'there') { this.print(`Hello ${name}`); } print(text) { console.log(text); } } const logger = new Logger(); const { printName } = logger; printName(); // TypeError: Cannot read property 'print' of undefined 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 class Logger { constructor() { this.printName = this.printName.bind(this); } // ... } 另一种解决方法是使用箭头函数。 class Obj { constructor() { this.getThis = () => this; } } const myObj = new Obj(); myObj.getThis() === myObj // true 2. 静态方法 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 class Foo { constructor(name){ this.name = name } static classMethod() { return 'hello'; } sayName() { console.log(this.name); } } Foo.classMethod() // 'hello' var foo = new Foo('world'); foo.sayName() // 'world' foo.classMethod() // TypeError: foo.classMethod is not a function 如果静态方法包含this关键字，这个this指的是类，而不是实例。 class Foo { static bar() { this.baz(); } static baz() { console.log('hello'); } baz() { console.log('world'); } } Foo.bar() // hello 父类的静态方法，可以被子类继承。 class Foo { static classMethod() { return 'hello'; } } class Bar extends Foo { } Bar.classMethod() // 'hello' 上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。 静态方法也是可以从super对象上调用的。 class Foo { static classMethod() { return 'hello'; } } class Bar extends Foo { static classMethod() { return super.classMethod() + ', too'; } } Bar.classMethod() // \"hello, too\" 3. 实例属性的新写法 实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。 例如下面这个实例改写 class IncreasingCounter { constructor() { this._count = 0; } get value() { console.log('Getting the current value!'); return this._count; } increment() { this._count++; } } 实例属性this._count定义在constructor()方法里面。另一种写法是，这个属性也可以定义在类的最顶层，其他都不变。 这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。 class foo { bar = 'hello'; baz = 'world'; constructor() { // ... } } 4. 静态属性 静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。目前，只有这种写法可行： class Foo { } Foo.prop = 1; Foo.prop // 1 因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上static关键字。 class MyClass { static myStaticProp = 42; constructor() { console.log(MyClass.myStaticProp); // 42 } } 这个新写法大大方便了静态属性的表达。 // 老写法 class Foo { // ... } Foo.prop = 1; // 新写法 class Foo { static prop = 1; } 5. 私有方法和私有属性 1）现有解决方案 私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。 class Widget { // 公有方法 foo (baz) { this._bar(baz); } // 私有方法 _bar(baz) { return this.snaf = baz; } // ... } 上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。 class Widget { foo (baz) { bar.call(this, baz); } // ... } function bar(baz) { return this.snaf = baz; } 上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 const bar = Symbol('bar'); const snaf = Symbol('snaf'); export default class myClass{ // 公有方法 foo(baz) { this[bar](baz); } // 私有方法 [bar](baz) { return this[snaf] = baz; } // ... }; 上面代码中，bar和snaf都是Symbol值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，Reflect.ownKeys()依然可以拿到它们。 const inst = new myClass(); Reflect.ownKeys(myClass.prototype) // [ 'constructor', 'foo', Symbol(bar) ] Symbol 值的属性名依然可以从类的外部拿到。 2）私有属性的提案 目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。 class IncreasingCounter { #count = 0; get value() { console.log('Getting the current value!'); return this.#count; } increment() { this.#count++; } } 上面代码中，#count就是私有属性，只能在类的内部使用（this.#count）。如果在类的外部使用，就会报错。 const counter = new IncreasingCounter(); counter.#count // 报错 counter.#count = 42 // 报错 这种写法不仅可以写私有属性，还可以用来写私有方法。 class Foo { #a; #b; constructor(a, b) { this.#a = a; this.#b = b; } #sum() { return #a + #b; } printSum() { console.log(this.#sum()); } } 私有属性也可以设置 getter 和 setter 方法。 class Counter { #xValue = 0; constructor() { super(); // ... } get #x() { return #xValue; } set #x(value) { this.#xValue = value; } } 6. new.target 属性 new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 Class 内部调用new.target，返回当前 Class。 function Person(name) { if (new.target === Person) { this.name = name; } else { throw new Error('必须使用 new 命令生成实例'); } } var person = new Person('张三'); // 正确 var notAPerson = Person.call(person, '张三'); // 报错 需要注意的是，子类继承父类时，new.target会返回子类。 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 class Shape { constructor() { if (new.target === Shape) { throw new Error('本类不能实例化'); } } } class Rectangle extends Shape { constructor(length, width) { super(); // ... } } var x = new Shape(); // 报错 var y = new Rectangle(3, 4); // 正确 上面代码中，Shape类不能被实例化，只能用于继承。 注意，在函数外部，使用new.target会报错。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:28 "},"Class-inherit.html":{"url":"Class-inherit.html","title":"Class的继承","keywords":"","body":"Class 的继承 1. 简介 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 class Point { constructor(x, y){ } toString(){ return `x:${x},y:${y}` } } class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + ' ' + super.toString(); // 调用父类的toString() } } constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。 class Point { /* ... */ } class ColorPoint extends Point { constructor() { } } let cp = new ColorPoint(); // ReferenceError 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 class ColorPoint extends Point { } // 等同于 class ColorPoint extends Point { constructor(...args) { super(...args); } } 在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。 class Point { constructor(x, y) { this.x = x; this.y = y; } } class ColorPoint extends Point { constructor(x, y, color) { this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 } } 下面是生成子类实例的代码。 let cp = new ColorPoint(25, 8, 'green'); cp instanceof ColorPoint // true cp instanceof Point // true 2. Object.getPrototypeOf() Object.getPrototypeOf方法可以用来从子类上获取父类，可以使用这个方法判断，一个类是否继承了另一个类。 Object.getPrototypeOf(ColorPoint) === Point // true 3. super 关键字 super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 1）super作为函数调用 super作为函数调用时，代表父类的构造函数，ES6 要求，子类的构造函数必须执行一次super函数。 class A {} class B extends A { constructor() { super(); } } super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。 class A { constructor() { console.log(new.target.name); } } class B extends A { constructor() { super(); } } new A() // A new B() // B 上面代码中，new.target指向当前正在执行的函数。 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 class A {} class B extends A { m() { super(); // 报错 } } 2）super 作为对象调用 super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 class A { p() { return 2; } } class B extends A { constructor() { super(); console.log(super.p()); // 2 } } let b = new B(); super.p()就相当于A.prototype.p()。 由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 如果属性定义在父类的原型对象上，super就可以取到。 class A { constructor() { this.p = 2; } } A.prototype.x = 2; class B extends A { constructor() { super(); console.log(super.x) // 2 } get m() { return super.p; } } let b = new B(); b.m // undefined 注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。 class A {} class B extends A { constructor() { super(); console.log(super); // 报错 } } 如果能清晰地表明super的数据类型，就不会报错。 class A {} class B extends A { constructor() { super(); console.log(super.valueOf() instanceof B); // true } } let b = new B(); 由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。 var obj = { toString() { return \"MyObject: \" + super.toString(); } }; obj.toString(); // MyObject: [object Object] 4. 类的 prototype 属性和 __proto__ 属性 大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 子类的__proto__属性，表示构造函数的继承，总是指向父类。 子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 class A { } class B extends A { } B.__proto__ === A // true B.prototype.__proto__ === A.prototype // true 子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。 这样的结果是因为，类的继承是按照下面的模式实现的。 class A { } class B { } // B 的实例继承 A 的实例 Object.setPrototypeOf(B.prototype, A.prototype); // B 继承 A 的静态属性 Object.setPrototypeOf(B, A); const b = new B(); 《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。 Object.setPrototypeOf = function (obj, proto) { obj.__proto__ = proto; return obj; } 因此，就得到了上面的结果。 Object.setPrototypeOf(B.prototype, A.prototype); // 等同于 B.prototype.__proto__ = A.prototype; Object.setPrototypeOf(B, A); // 等同于 B.__proto__ = A; 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。 B.prototype = Object.create(A.prototype); // 等同于 B.prototype.__proto__ = A.prototype; extends关键字后面可以跟多种类型的值。 子类继承Object类 class A extends Object { } A.__proto__ === Object // true A.prototype.__proto__ === Object.prototype // true 不存在任何继承 这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype 但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。 5. 原生构造函数的继承 原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。 Boolean() Number() String() Array() Date() Function() RegExp() Error() Object() 以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。 function MyArray() { Array.apply(this, arguments); } MyArray.prototype = Object.create(Array.prototype, { constructor: { value: MyArray, writable: true, configurable: true, enumerable: true } }); 上面代码定义了一个继承 Array 的MyArray类。但是，这个类的行为与Array完全不一致。 var colors = new MyArray(); colors[0] = \"red\"; colors.length // 0 colors.length = 0; colors[0] // \"red\" 之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。 ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。 class MyArray extends Array { constructor(...args) { super(...args); } } var arr = new MyArray(); arr[0] = 12; arr.length // 1 arr.length = 0; arr[0] // undefined 上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。 class VersionedArray extends Array { constructor() { super(); this.history = [[]]; } commit() { this.history.push(this.slice()); } revert() { this.splice(0, this.length, ...this.history[this.history.length - 1]); } } var x = new VersionedArray(); x.push(1); x.push(2); x // [1, 2] x.history // [[]] x.commit(); x.history // [[], [1, 2]] x.push(3); x // [1, 2, 3] x.history // [[], [1, 2]] x.revert(); x // [1, 2] 6. Mixin 模式的实现 Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。 const a = { a: 'a' }; const b = { b: 'b' }; const c = {...a, ...b}; // {a: 'a', b: 'b'} 上面代码中，c对象是a对象和b对象的合成，具有两者的接口。 下面是一个更完备的实现，将多个类的接口“混入”（mixin）另一个类。 function mix(...mixins) { class Mix { constructor() { for (let mixin of mixins) { copyProperties(this, new mixin()); // 拷贝实例属性 } } } for (let mixin of mixins) { copyProperties(Mix, mixin); // 拷贝静态属性 copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性 } return Mix; } function copyProperties(target, source) { for (let key of Reflect.ownKeys(source)) { if ( key !== 'constructor' && key !== 'prototype' && key !== 'name' ) { let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); } } } 上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。 class DistributedEdit extends mix(Loggable, Serializable) { // ... } Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:28 "},"Module.html":{"url":"Module.html","title":"Module的语法","keywords":"","body":"Module 的语法 1.概述 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 // CommonJS模块 let { stat, exists, readFile } = require('fs'); // 等同于 let _fs = require('fs'); let stat = _fs.stat; let exists = _fs.exists; let readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 // ES6模块 import { stat, exists, readFile } from 'fs'; 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 ES6 模块有以下好处： 静态加载 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。 2.严格模式 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上\"use strict\";。 严格模式主要有以下限制。 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 尤其需要注意this的限制。ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。 3. export 命令 模块功能主要由两个命令构成：export和import。export命令用于导出模块，import命令用于导入模块 // profile.js export var firstName = 'Michael'; export var lastName = 'Jackson'; export var year = 1958; export的写法，除了像上面这样，还有另外一种。 // profile.js var firstName = 'Michael'; var lastName = 'Jackson'; var year = 1958; export { firstName, lastName, year }; 上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。 export命令除了输出变量，还可以输出函数或类（class）。 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。 function v1() { ... } function v2() { ... } export { v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion }; 上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 // 报错 export 1; // 报错 var m = 1; export m; 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样。 // 写法一 export var m = 1; // 写法二 var m = 1; export {m}; // 写法三 var n = 1; export {n as m}; 同样的，function和class的输出，也必须遵守这样的写法。 // 报错 function f() {} export f; // 正确 export function f() {}; // 正确 function f() {} export {f}; export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。 function foo() { export default 'bar' // SyntaxError } foo() 上面代码中，export语句放在函数之中，结果报错。 4. import 命令 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 // main.js import { firstName, lastName, year } from './profile.js'; function setName(element) { element.textContent = firstName + ' ' + lastName; } 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 import { lastName as surname } from './profile.js'; import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。 import {a} from './xxx.js' a = {}; // Syntax Error : 'a' is read-only; 上面代码中，脚本加载了变量a，对其重新赋值就会报错，因为a是一个只读的接口。但是，如果a是一个对象，改写a的属性是允许的。 import {a} from './xxx.js' a.foo = 'hello'; // 合法操作 上面代码中，a的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。 import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。 import {myMethod} from 'util'; 注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。 foo(); import { foo } from 'my_module'; 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 // 报错 import { 'f' + 'oo' } from 'my_module'; // 报错 let module = 'my_module'; import { foo } from module; // 报错 if (x === 1) { import { foo } from 'module1'; } else { import { foo } from 'module2'; } 上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。 最后，import语句会执行所加载的模块，但是不输入任何值。 import 'lodash'; 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。 import 'lodash'; import 'lodash'; import { foo } from 'my_module'; import { bar } from 'my_module'; // 等同于 import { foo, bar } from 'my_module'; 5. 模块的整体加载 除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 下面是一个circle.js文件，它输出两个方法area和circumference。 // circle.js export function area(radius) { return Math.PI * radius * radius; } export function circumference(radius) { return 2 * Math.PI * radius; } 逐一指定要加载的方法： // main.js import { area, circumference } from './circle'; console.log('圆面积：' + area(4)); console.log('圆周长：' + circumference(14)); 整体加载的写法： import * as circle from './circle'; console.log('圆面积：' + circle.area(4)); console.log('圆周长：' + circle.circumference(14)); 注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。 import * as circle from './circle'; // 下面两行都是不允许的 circle.foo = 'hello'; circle.area = function () {}; 6. export default 命令 export default命令，为模块指定默认输出。 // export-default.js export default function () { console.log('foo'); } 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。 // import-default.js import customName from './export-default'; customName(); // 'foo' export default命令用在非匿名函数前，也是可以的。 // export-default.js export default function foo() { console.log('foo'); } // 或者写成 function foo() { console.log('foo'); } export default foo; 上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。 // 第一组 export default function crc32() { // 输出 // ... } import crc32 from 'crc32'; // 输入 // 第二组 export function crc32() { // 输出 // ... }; import {crc32} from 'crc32'; // 输入 export default命令用于指定模块的默认输出，一个模块只能有一个默认输出 export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。 // 正确 export var a = 1; // 正确 var a = 1; export default a; // 错误 export default var a = 1; 有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例。 import _ from 'lodash'; 如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样。 import _, { each, forEach } from 'lodash'; 对应上面代码的export语句如下。 export default function (obj) { // ··· } export function each(obj, iterator, context) { // ··· } export { each as forEach }; export default也可以用来输出类。 // MyClass.js export default class { ... } // main.js import MyClass from 'MyClass'; let o = new MyClass(); 7. export 和 import 的复合写法 如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 export { foo, bar } from 'my_module'; // 可以简单理解为 import { foo, bar } from 'my_module'; export { foo, bar }; 上面代码中，export和import语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。 8. 模块的继承 假设有一个circleplus模块，继承了circle模块。 // circleplus.js export * from 'circle'; export var e = 2.71828182846; export default function(x) { return Math.exp(x); } 上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。 这时，也可以将circle的属性或方法，改名后再输出。 // circleplus.js export { area as circleArea } from 'circle'; 加载上面模块的写法如下。 // main.js import * as math from 'circleplus'; import exp from 'circleplus'; console.log(exp(math.e)); 上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。 9. 跨模块的常量 const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。 // constants.js 模块 export const A = 1; export const B = 3; export const C = 4; // test1.js 模块 import * as constants from './constants'; console.log(constants.A); // 1 console.log(constants.B); // 3 // test2.js 模块 import {A, B} from './constants'; console.log(A); // 1 console.log(B); // 3 如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。 // constants/db.js export const db = { url: 'http://my.couchdbserver.local:5984', admin_username: 'admin', admin_password: 'admin password' }; // constants/user.js export const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator']; 然后，将这些文件输出的常量，合并在index.js里面。 // constants/index.js export {db} from './db'; export {users} from './users'; 使用的时候，直接加载index.js就可以了。 // script.js import {db, users} from './constants/index'; 10. import() 1）简介 import()函数，支持动态加载模块。 import(specifier) 上面代码中，import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。 import()返回一个 Promise 对象。下面是一个例子。 const main = document.querySelector('main'); import(`./section-modules/${someVariable}.js`) .then(module => { module.loadPageInto(main); }) .catch(err => { main.textContent = err.message; }); import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。 2）使用场合 （1）按需加载 import()可以在需要的时候，再加载某个模块。 button.addEventListener('click', event => { import('./dialogBox.js') .then(dialogBox => { dialogBox.open(); }) .catch(error => { /* Error handling */ }) }); （2）条件加载 import()可以放在if代码块，根据不同的情况，加载不同的模块。 if (condition) { import('moduleA').then(...); } else { import('moduleB').then(...); } 上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。 （3）动态的模块路径 import()允许模块路径动态生成。 import(f()) .then(...); 上面代码中，根据函数f的返回结果，加载不同的模块。 3）注意点 import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。 import('./myModule.js') .then(({export1, export2}) => { // ...· }); 上面代码中，export1和export2都是myModule.js的输出接口，可以解构获得。 如果模块有default输出接口，可以用参数直接获得。 import('./myModule.js') .then(myModule => { console.log(myModule.default); }); 上面的代码也可以使用具名输入的形式。 import('./myModule.js') .then(({default: theDefault}) => { console.log(theDefault); }); 如果想同时加载多个模块，可以采用下面的写法。 Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'), ]) .then(([module1, module2, module3]) => { ··· }); import()也可以用在 async 函数之中。 async function main() { const myModule = await import('./myModule.js'); const {export1, export2} = await import('./myModule.js'); const [module1, module2, module3] = await Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'), ]); } main(); Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-09 23:15 "},"Module-loading.html":{"url":"Module-loading.html","title":"Module的加载实现","keywords":"","body":"Module 的加载实现 1. 浏览器加载 1）传统方法 HTML 网页中，浏览器通过``标签加载 JavaScript 脚本。 // module code 上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此type=\"application/javascript\"可以省略。 默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到``标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。 如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。 上面代码中，`标签打开defer或async`属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。 defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。 2）加载规则 浏览器加载 ES6 模块，也使用`标签，但是要加入type=\"module\"`属性。 上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个 ES6 模块。 浏览器对于带有type=\"module\"的，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了标签的defer属性。 如果网页有多个，它们会按照在页面出现的顺序依次执行。 标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。 一旦使用了async属性，``就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。 浏览器使用es6模块，有几点注意事项 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。 模块脚本自动采用严格模式，不管有没有声明use strict。 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。 同一个模块如果加载多次，将只执行一次。 import utils from 'https://example.com/js/utils.js'; const x = 1; console.log(x === window.x); //false console.log(this === undefined); // true 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。 const isNotModuleScript = this !== undefined; 2. ES6模块和CommonJS模块的差异 ES6 模块与 CommonJS 模块完全不同。它们有两个重大差异： CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。 // lib.js var counter = 3; function incCounter() { counter++; } module.exports = { counter: counter, incCounter: incCounter, } 在main.js里面加载这个模块： // main.js var mod = require('./lib'); console.log(mod.counter); // 3 mod.incCounter(); console.log(mod.counter); // 3 上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。 // lib.js var counter = 3; function incCounter() { counter++; } module.exports = { get counter() { return counter }, incCounter: incCounter, }; 上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。 $ node main.js 3 4 ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。原始值变了，import加载的值也会跟着变。 // lib.js export let counter = 3; export function incCounter() { counter++; } // main.js import { counter, incCounter } from './lib'; console.log(counter); // 3 incCounter(); console.log(counter); // 4 3. NodeJs 加载 1）概述 Node.js 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。从 v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。 Node.js 要求 ES6 模块采用.mjs后缀文件名。也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。Node.js 遇到.mjs文件，就认为它是 ES6 模块，默认启用严格模式。 如果不希望将后缀名改成.mjs，可以在项目的package.json文件中，指定type字段为module。 { \"type\": \"module\" } 一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块。 # 解释成 ES6 模块 $ node my-app.js 注意，ES6 模块与 CommonJS 模块尽量不要混用。require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。反过来，.mjs文件里面也不能使用require命令，必须使用import。 2）main 字段 package.json文件有两个字段可以指定模块的入口文件：main和exports。比较简单的模块，可以只使用main字段，指定模块加载的入口文件。 // ./node_modules/es-module-package/package.json { \"type\": \"module\", \"main\": \"./src/index.js\" } 上面代码指定项目的入口脚本为./src/index.js，它的格式为 ES6 模块。如果没有type字段，index.js就会被解释为 CommonJS 模块。 然后，import命令就可以加载这个模块。 // ./my-app.mjs import { something } from 'es-module-package'; // 实际加载的是 ./node_modules/es-module-package/src/index.js 上面代码中，运行该脚本以后，Node.js 就会到./node_modules目录下面，寻找es-module-package模块，然后根据该模块package.json的main字段去执行入口文件。 这时，如果用 CommonJS 模块的require()命令去加载es-module-package模块会报错，因为 CommonJS 模块不能处理export命令。 3）exports 字段 exports字段的优先级高于main字段。它有多种用法。 （1）子目录别名 package.json文件的exports字段可以指定脚本或子目录的别名。 // ./node_modules/es-module-package/package.json { \"exports\": { \"./submodule\": \"./src/submodule.js\" } } 上面的代码指定src/submodule.js别名为submodule，然后就可以从别名加载这个文件。 import submodule from 'es-module-package/submodule'; // 加载 ./node_modules/es-module-package/src/submodule.js 如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。 // 报错 import submodule from 'es-module-package/private-module.js'; // 不报错 import submodule from './node_modules/es-module-package/private-module.js'; （2）main 的别名 exports字段的别名如果是.，就代表模块的主入口，优先级高于main字段，并且可以直接简写成exports字段的值。 { \"exports\": { \".\": \"./main.js\" } } // 等同于 { \"exports\": \"./main.js\" } 由于exports字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。 { \"main\": \"./main-legacy.cjs\", \"exports\": { \".\": \"./main-modern.cjs\" } } 上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是main-legacy.cjs，新版本的 Node.js 的入口文件是main-modern.cjs。 （3）按需引入 利用.这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开--experimental-conditional-exports标志。 { \"type\": \"module\", \"exports\": { \".\": { \"require\": \"./main.cjs\", \"default\": \"./main.js\" } } } 上面代码中，别名.的require条件指定require()命令的入口文件（即 CommonJS 的入口），default条件指定其他情况的入口（即 ES6 的入口）。 上面的写法可以简写如下。 { \"exports\": { \"require\": \"./main.cjs\", \"default\": \"./main.js\" } } 注意，如果同时还有其他别名，就不能采用简写，否则或报错。 { // 报错 \"exports\": { \"./feature\": \"./lib/feature.js\", \"require\": \"./main.cjs\", \"default\": \"./main.js\" } } 4）ES6模块加载CommonJS模块 目前，一个模块同时支持 ES6 和 CommonJS 两种格式的常见方法是，package.json文件的main字段指定 CommonJS 入口，给 Node.js 使用；module字段指定 ES6 模块入口，给打包工具使用，因为 Node.js 不认识module字段。 有了上一节的条件加载以后，Node.js 本身就可以同时处理两种模块。 // ./node_modules/pkg/package.json { \"type\": \"module\", \"main\": \"./index.cjs\", \"exports\": { \"require\": \"./index.cjs\", \"default\": \"./wrapper.mjs\" } } 上面代码指定了 CommonJS 入口文件index.cjs，下面是这个文件的代码。 // ./node_modules/pkg/index.cjs exports.name = 'value'; 然后，ES6 模块可以加载这个文件。 // ./node_modules/pkg/wrapper.mjs import cjsModule from './index.cjs'; export const name = cjsModule.name; 注意，import命令加载 CommonJS 模块，只能整体加载，不能只加载单一的输出项。 // 正确 import packageMain from 'commonjs-package'; // 报错 import { method } from 'commonjs-package'; 还有一种变通的加载方法，就是使用 Node.js 内置的module.createRequire()方法。 / cjs.cjs module.exports = 'cjs'; // esm.mjs import { createRequire } from 'module'; const require = createRequire(import.meta.url); const cjs = require('./cjs.cjs'); cjs === 'cjs'; // true 5）CommonJS加载ES6模块 CommonJS 的require命令不能加载 ES6 模块，会报错，只能使用import()这个方法加载。 (async () => { await import('./my-app.mjs'); })(); 6）NodeJs 的内置模块 Node.js 的内置模块可以整体加载，也可以加载指定的输出项。 // 整体加载 import EventEmitter from 'events'; const e = new EventEmitter(); // 加载指定的输出项 import { readFile } from 'fs'; readFile('./foo.txt', (err, source) => { if (err) { console.error(err); } else { console.log(source); } }); 7）加载路径 ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。import命令和package.json文件的main字段如果省略脚本的后缀名，会报错。 // ES6 模块中将报错 import { something } from './index'; 为了与浏览器的import加载规则相同，Node.js 的.mjs文件支持 URL 路径。 import './foo.mjs?query=1'; // 加载 ./foo 传入参数 ?query=1 8）内部变量 ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。 首先，就是this关键字。ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。 其次，以下这些顶层变量在 ES6 模块之中都是不存在的。 arguments require module exports __filename __dirname 4. 循环加载 “循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。 // a.js var b = require('b'); // b.js var a = require('a'); 通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。 但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现a依赖b，b依赖c，c又依赖a这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。 1）CommonJS模块的加载原理 CommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。 { id: '...', exports: { ... }, loaded: true, ... } 上面代码就是 Node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。 以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。 2）CommonJS模块的循环加载 让我们来看，Node 官方文档里面的例子。脚本文件a.js代码如下。 exports.done = false; var b = require('./b.js'); console.log('在 a.js 之中，b.done = %j', b.done); exports.done = true; console.log('a.js 执行完毕'); 上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。 再看b.js的代码。 exports.done = false; var a = require('./a.js'); console.log('在 b.js 之中，a.done = %j', a.done); exports.done = true; console.log('b.js 执行完毕'); 上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。 a.js已经执行的部分，只有一行。 exports.done = false; 因此，对于b.js来说，它从a.js只输入一个变量done，值为false。 然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。 var a = require('./a.js'); var b = require('./b.js'); console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done); 执行main.js，运行结果如下。 $ node main.js 在 b.js 之中，a.done = false b.js 执行完毕 在 a.js 之中，b.done = true a.js 执行完毕 在 main.js 之中, a.done=true, b.done=true 上面的代码证明了两件事。一是，在b.js之中，a.js没有执行完毕，只执行了第一行。二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。 exports.done = true; 另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。 var a = require('a'); // 安全的写法 var foo = require('a').foo; // 危险的写法 exports.good = function (arg) { return a.foo('good', arg); // 使用的是 a.foo 的最新值 }; exports.bad = function (arg) { return foo('bad', arg); // 使用的是一个部分加载时的值 }; 上面代码中，如果发生循环加载，require('a').foo的值很可能后面会被改写，改用require('a')会更保险一点。 3）ES6模块的循环加载 // a.mjs import {bar} from './b'; console.log('a.mjs'); console.log(bar); export let foo = 'foo'; // b.mjs import {foo} from './a'; console.log('b.mjs'); console.log(foo); export let bar = 'bar'; 执行a.mjs，结果如下。 $ node --experimental-modules a.mjs b.mjs ReferenceError: foo is not defined 执行a.mjs以后会报错，foo变量未定义，这是为什么？ 让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。 解决这个问题的方法，就是让b.mjs运行的时候，foo已经有定义了。这可以通过将foo写成函数来解决。 / a.mjs import {bar} from './b'; console.log('a.mjs'); console.log(bar()); function foo() { return 'foo' } export {foo}; // b.mjs import {foo} from './a'; console.log('b.mjs'); console.log(foo()); function bar() { return 'bar' } export {bar}; 这时再执行a.mjs就可以得到预期结果。 $ node --experimental-modules a.mjs b.mjs foo a.mjs bar 这是因为函数具有提升作用，在执行import {bar} from './b'时，函数foo就已经有定义了，所以b.mjs加载的时候不会报错。这也意味着，如果把函数foo改写成函数表达式，也会报错。 // a.mjs import {bar} from './b'; console.log('a.mjs'); console.log(bar()); const foo = () => 'foo'; export {foo}; 上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-09 23:15 "},"programming-style.html":{"url":"programming-style.html","title":"编程风格","keywords":"","body":"编程风格 1.块级作用域 1）let 取代var 不允许重复声明 不存在变量提升 2）全局常量和线程安全 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。 const优于let有几个原因： const可以提醒阅读程序的人，这个变量不应该改变； const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算； JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。 阅读代码的人立刻会意识到不应该修改这个值 防止了无意间修改变量值所导致的错误。 // bad var a = 1, b = 2, c = 3; // good const a = 1; const b = 2; const c = 3; // best const [a, b, c] = [1, 2, 3]; 所有的函数都应该设置为常量。 2. 字符串 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 // bad const a = \"foobar\"; const b = 'foo' + a + 'bar'; // acceptable const c = `foobar`; // good const a = 'foobar'; const b = `foo${a}bar`; 3. 解构赋值 使用数组成员对变量赋值时，优先使用解构赋值。 const arr = [1, 2, 3, 4]; // bad const first = arr[0]; const second = arr[1]; // good const [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。 // bad function getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; } // good function getFullName(obj) { const { firstName, lastName } = obj; } // best function getFullName({ firstName, lastName }) { } 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 // bad function processInput(input) { return [left, right, top, bottom]; } // good function processInput(input) { return { left, right, top, bottom }; } const { left, right } = processInput(input); 4. 对象 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 // bad const a = { k1: v1, k2: v2, }; const b = { k1: v1, k2: v2 }; // good const a = { k1: v1, k2: v2 }; const b = { k1: v1, k2: v2, }; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 // bad const a = {}; a.x = 3; // if reshape unavoidable const a = {}; Object.assign(a, { x: 3 }); // good const a = { x: null }; a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 // bad const obj = { id: 5, name: 'San Francisco', }; obj[getKey('enabled')] = true; // good const obj = { id: 5, name: 'San Francisco', [getKey('enabled')]: true, }; 上面对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。 对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 var ref = 'some value'; // bad const atom = { ref: ref, value: 1, addValue: function (value) { return atom.value + value; }, }; // good const atom = { ref, value: 1, addValue(value) { return atom.value + value; }, }; 5. 数组 使用扩展运算符（...）拷贝数组。 // bad const len = items.length; const itemsCopy = []; let i; for (i = 0; i 使用 Array.from 方法，将类似数组的对象转为数组。 const foo = document.querySelectorAll('.foo'); const nodes = Array.from(foo); 6. 函数 立即执行函数可以写成箭头函数的形式。 (() => { console.log('Welcome to the Internet.'); })(); 那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。 // bad [1, 2, 3].map(function (x) { return x * x; }); // good [1, 2, 3].map((x) => { return x * x; }); // best [1, 2, 3].map(x => x * x); 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。 // bad const self = this; const boundMethod = function(...params) { return method.apply(self, params); } // acceptable const boundMethod = method.bind(this); // best const boundMethod = (...params) => method.apply(this, params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 // bad function divide(a, b, option = false ) { } // good function divide(a, b, { option = false } = {}) { } 不要在函数体内使用 arguments 变量，使用 rest 运算符（...）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。 // bad function concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join(''); } // good function concatenateAll(...args) { return args.join(''); } 使用默认值语法设置函数参数的默认值。 // bad function handleThings(opts) { opts = opts || {}; } // good function handleThings(opts = {}) { // ... } 7. Map 结构 注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。 let map = new Map(arr); for (let key of map.keys()) { console.log(key); } for (let value of map.values()) { console.log(value); } for (let item of map.entries()) { console.log(item[0], item[1]); } 8. Class 总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。 // bad function Queue(contents = []) { this._queue = [...contents]; } Queue.prototype.pop = function() { const value = this._queue[0]; this._queue.splice(0, 1); return value; } // good class Queue { constructor(contents = []) { this._queue = [...contents]; } pop() { const value = this._queue[0]; this._queue.splice(0, 1); return value; } } 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 // bad const inherits = require('inherits'); function PeekableQueue(contents) { Queue.apply(this, contents); } inherits(PeekableQueue, Queue); PeekableQueue.prototype.peek = function() { return this._queue[0]; } // good class PeekableQueue extends Queue { peek() { return this._queue[0]; } } 9. 模块 首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require。 // bad const moduleA = require('moduleA'); const func1 = moduleA.func1; const func2 = moduleA.func2; // good import { func1, func2 } from 'moduleA'; 使用export取代module.exports。 // commonJS的写法 var React = require('react'); var Breadcrumbs = React.createClass({ render() { return ; } }); module.exports = Breadcrumbs; // ES6的写法 import React from 'react'; class Breadcrumbs extends React.Component { render() { return ; } }; export default Breadcrumbs; 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 // bad import * as myObject from './importModule'; // good import myObject from './importModule'; 如果模块默认输出一个函数，函数名的首字母应该小写。 function makeStyleGuide() { } export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。 const StyleGuide = { es6: { } }; export default StyleGuide; 10. ESLint 的使用 ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 首先，安装 ESLint。 $ npm i -g eslint 然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。 $ npm i -g eslint-config-airbnb $ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react 最后，在项目的根目录下新建一个.eslintrc文件，配置 ESLint。 { \"extends\": \"eslint-config-airbnb\" } 现在就可以检查，当前项目的代码是否符合预设的规则。 index.js文件的代码如下： var unusued = 'I have no purpose!'; function greet() { var message = 'Hello, World!'; alert(message); } greet(); 使用 ESLint 检查这个文件，就会报出错误： $ eslint index.js index.js 1:1 error Unexpected var, use let or const instead no-var 1:5 error unusued is defined but never used no-unused-vars 4:5 error Expected indentation of 2 characters but found 4 indent 4:5 error Unexpected var, use let or const instead no-var 5:5 error Expected indentation of 2 characters but found 4 indent ✖ 5 problems (5 errors, 0 warnings) 上面代码说明，原文件有五个错误，其中两个是不应该使用var命令，而要使用let或const；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-09 23:15 "},"understand-specification.html":{"url":"understand-specification.html","title":"读懂规格","keywords":"","body":"读懂规格 1.概述 规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。 一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。 这对 JavaScript 语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。 本章介绍如何读懂 ECMAScript 6 的规格文件。 ECMAScript 6 的规格，可以在 ECMA 国际标准组织的官方网站（www.ecma-international.org/ecma-262/6.0/）免费下载和在线阅读。 这个规格文件相当庞大，一共有 26 章，A4 打印的话，足足有 545 页。它的特点就是规定得非常细致，每一个语法行为、每一个函数的实现都做了详尽的清晰的描述。基本上，编译器作者只要把每一步翻译成代码就可以了。这很大程度上，保证了所有 ES6 实现都有一致的行为。 ECMAScript 6 规格的 26 章之中，第 1 章到第 3 章是对文件本身的介绍，与语言关系不大。第 4 章是对这门语言总体设计的描述，有兴趣的读者可以读一下。第 5 章到第 8 章是语言宏观层面的描述。第 5 章是规格的名词解释和写法的介绍，第 6 章介绍数据类型，第 7 章介绍语言内部用到的抽象操作，第 8 章介绍代码如何运行。第 9 章到第 26 章介绍具体的语法。 对于一般用户来说，除了第 4 章，其他章节都涉及某一方面的细节，不用通读，只要在用到的时候，查阅相关章节即可。 2.术语 ES6 规格使用了一些专门的术语，了解这些术语，可以帮助你读懂规格 1）抽象操作 所谓“抽象操作”（abstract operations）就是引擎的一些内部方法，外部不能调用。规格定义了一系列的抽象操作，规定了它们的行为，留给各种引擎自己去实现。 举例来说，Boolean(value)的算法，第一步是这样的。 Let b be ToBoolean(value). 这里的ToBoolean就是一个抽象操作，是引擎内部求出布尔值的算法。 许多函数的算法都会多次用到同样的步骤，所以 ES6 规格将它们抽出来，定义成“抽象操作”，方便描述。 2）Record 和field ES6 规格将键值对（key-value map）的数据结构称为 Record，其中的每一组键值对称为 field。这就是说，一个 Record 由多个 field 组成，而每个 field 都包含一个键名（key）和一个键值（value）。 3）[[Notation]] ES6 规格大量使用[[Notation]]这种书写法，比如[[Value]]、[[Writable]]、[[Get]]、[[Set]]等等。它用来指代 field 的键名。 举例来说，obj是一个 Record，它有一个Prototype属性。ES6 规格不会写obj.Prototype，而是写obj.[[Prototype]]。一般来说，使用[[Notation]]这种书写法的属性，都是对象的内部属性。 所有的 JavaScript 函数都有一个内部属性[[Call]]，用来运行该函数。 F.[[Call]](V, argumentsList) 上面代码中，F是一个函数对象，[[Call]]是它的内部方法，F.[[call]]()表示运行该函数，V表示[[Call]]运行时this的值，argumentsList则是调用时传入函数的参数。 4）Completion Record 每一个语句都会返回一个 Completion Record，表示运行结果。每个 Completion Record 有一个[[Type]]属性，表示运行结果的类型。 [[Type]]属性有五种可能的值： normal return throw break continue 如果[[Type]]的值是normal，就称为 normal completion，表示运行正常。其他的值，都称为 abrupt completion。其中，开发者只需要关注[[Type]]为throw的情况，即运行出错；break、continue、return这三个值都只出现在特定场景，可以不用考虑。 3. 抽象操作的标准流程 抽象操作的运行流程，一般是下面这样： Let resultCompletionRecord be AbstractOp(). If resultCompletionRecord is an abrupt completion, return resultCompletionRecord. Let result be resultCompletionRecord.[[Value]]. return result. 上面的第一步是调用抽象操作AbstractOp()，得到resultCompletionRecord，这是一个 Completion Record。第二步，如果这个 Record 属于 abrupt completion，就将resultCompletionRecord返回给用户。如果此处没有返回，就表示运行结果正常，所得的值存放在resultCompletionRecord.[[Value]]属性。第三步，将这个值记为result。第四步，将result返回给用户。 ES6 规格将这个标准流程，使用简写的方式表达： Let result be AbstractOp(). ReturnIfAbrupt(result). return result. 这个简写方式里面的ReturnIfAbrupt(result)，就代表了上面的第二步和第三步，即如果有报错，就返回错误，否则取出值。 甚至还有进一步的简写格式： Let result be ? AbstractOp(). return result. 上面流程的?，就代表AbstractOp()可能会报错。一旦报错，就返回错误，否则取出值。 除了?，ES6 规格还使用另一个简写符号!。 Let result be ! AbstractOp(). return result. 上面流程的!，代表AbstractOp()不会报错，返回的一定是 normal completion，总是可以取出值。 4. 相等运算符 相等运算符（==）是一个很让人头痛的运算符，它的语法行为多变，不符合直觉。这个小节就看看规格怎么规定它的行为。 请看下面这个表达式，请问它的值是多少。 0 == null 如果你不确定答案，或者想知道语言内部怎么处理，就可以去查看规格，7.2.12 小节是对相等运算符（==）的描述。 规格对每一种语法行为的描述，都分成两部分：先是总体的行为描述，然后是实现的算法细节。相等运算符的总体描述，只有一句话。 “The comparison x == y, where x and y are values, produces true or false.” 上面这句话的意思是，相等运算符用于比较两个值，返回true或false。 下面是算法细节： 如果x不是正常值（比如抛出一个错误），中断执行。 如果y不是正常值，中断执行。 如果Type(x)与Type(y)相同，执行严格相等运算x === y。 如果x是null，y是undefined，返回true。 如果x是undefined，y是null，返回true。 如果Type(x)是数值，Type(y)是字符串，返回x == ToNumber(y)的结果。 如果Type(x)是字符串，Type(y)是数值，返回ToNumber(x) == y的结果。 如果Type(x)是布尔值，返回ToNumber(x) == y的结果。 如果Type(y)是布尔值，返回x == ToNumber(y)的结果。 如果Type(x)是字符串或数值或Symbol值，Type(y)是对象，返回x == ToPrimitive(y)的结果。 如果Type(x)是对象，Type(y)是字符串或数值或Symbol值，返回ToPrimitive(x) == y的结果。 返回false。 由于0的类型是数值，null的类型是 Null（这是规格4.3.13 小节的规定，是内部 Type 运算的结果，跟typeof运算符无关）。因此上面的前 11 步都得不到结果，要到第 12 步才能得到false。 0 == null // false 5. 数组的空位 下面看一个例子： const a1 = [undefined, undefined, undefined]; const a2 = [, , ,]; a1.length // 3 a2.length // 3 a1[0] // undefined a2[0] // undefined a1[0] === a2[0] // true 上面代码中，数组a1的成员是三个undefined，数组a2的成员是三个空位。这两个数组很相似，长度都是 3，每个位置的成员读取出来都是undefined。 但是，它们实际上存在重大差异。 0 in a1 // true 0 in a2 // false a1.hasOwnProperty(0) // true a2.hasOwnProperty(0) // false Object.keys(a1) // [\"0\", \"1\", \"2\"] Object.keys(a2) // [] a1.map(n => 1) // [1, 1, 1] a2.map(n => 1) // [, , ,] 上面代码一共列出了四种运算，数组a1和a2的结果都不一样。前三种运算（in运算符、数组的hasOwnProperty方法、Object.keys方法）都说明，数组a2取不到属性名。最后一种运算（数组的map方法）说明，数组a2没有发生遍历。 为什么a1与a2成员的行为不一致？数组的成员是undefined或空位，到底有什么不同？ \"数组成员可以省略。只要逗号前面没有任何表达式，数组的length属性就会加 1，并且相应增加其后成员的位置索引。被省略的成员不会被定义。如果被省略的成员是数组最后一个成员，则不会导致数组length属性增加。” 上面的规格说得很清楚，数组的空位会反映在length属性，也就是说空位有自己的位置，但是这个位置的值是未定义，即这个值是不存在的。如果一定要读取，结果就是undefined（因为undefined在 JavaScript 语言中表示不存在）。 这就解释了为什么in运算符、数组的hasOwnProperty方法、Object.keys方法，都取不到空位的属性名。因为这个属性名根本就不存在，规格里面没说要为空位分配属性名(位置索引），只说要为下一个元素的位置索引加 1。 6. 数组的map方法 算法描述是这样的： 得到当前数组的this对象 如果报错就返回 求出当前数组的length属性 如果报错就返回 如果 map 方法的参数callbackfn不可执行，就报错 如果 map 方法的参数之中，指定了this，就让T等于该参数，否则T为undefined 生成一个新的数组A，跟当前数组的length属性保持一致 如果报错就返回 设定k等于 0 只要k小于当前数组的length属性，就重复下面步骤 设定Pk等于ToString(k)，即将K转为字符串 设定kPresent等于HasProperty(O, Pk)，即求当前数组有没有指定属性 如果报错就返回 如果kPresent等于true，则进行下面步骤 设定kValue等于Get(O, Pk)，取出当前数组的指定属性 如果报错就返回 设定mappedValue等于Call(callbackfn, T, «kValue, k, O»)，即执行回调函数 如果报错就返回 设定status等于CreateDataPropertyOrThrow (A, Pk, mappedValue)，即将回调函数的值放入A数组的指定位置 如果报错就返回 k增加 1 返回A 仔细查看上面的算法，可以发现，当处理一个全是空位的数组时，前面步骤都没有问题。进入第 10 步中第 2 步时，kPresent会报错，因为空位对应的属性名，对于数组来说是不存在的，因此就会返回，不会进行后面的步骤。 const arr = [, , ,]; arr.map(n => { console.log(n); return 1; }) // [, , ,] Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-09 23:15 "},"async-iterator.html":{"url":"async-iterator.html","title":"异步遍历器","keywords":"","body":"异步遍历器 1.同步遍历器的问题 Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的next方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。next方法返回的对象的结构是{value, done}，其中value表示当前的数据的值，done是一个布尔值，表示遍历是否结束。 function idMaker() { let index = 0; return { next: function() { return { value: index++, done: false }; } }; } const it = idMaker(); it.next().value // 0 it.next().value // 1 it.next().value // 2 变量it是一个遍历器（iterator）。每次调用it.next()方法，就返回一个对象，表示当前遍历位置的信息。 这里隐含着一个规定，it.next()方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行it.next()方法，就必须同步地得到value和done这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。 function idMaker() { let index = 0; return { next: function() { return new Promise(function (resolve, reject) { setTimeout(() => { resolve({ value: index++, done: false }); }, 1000); }); } }; } 上面代码中，next()方法返回的是一个 Promise 对象，这样就不行，不符合 Iterator 协议，只要代码里面包含异步操作都不行。也就是说，Iterator 协议里面next()方法只能包含同步操作。 目前的解决方法是，将异步操作包装成 Thunk 函数或者 Promise 对象，即next()方法返回值的value属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而done属性则还是同步产生的。 function idMaker() { let index = 0; return { next: function() { return { value: new Promise(resolve => setTimeout(() => resolve(index++), 1000)), done: false }; } }; } const it = idMaker(); it.next().value.then(o => console.log(o)) // 1 it.next().value.then(o => console.log(o)) // 2 it.next().value.then(o => console.log(o)) // 3 上面代码中，value属性的返回值是一个 Promise 对象，用来放置异步操作。但是这样写很麻烦，不太符合直觉，语义也比较绕。 ES2018 引入了“异步遍历器”（Async Iterator），为异步操作提供原生的遍历器接口，即value和done这两个属性都是异步产生。 2. 一步遍历的接口 异步遍历器的最大的语法特点，就是调用遍历器的next方法，返回的是一个 Promise 对象。 asyncIterator .next() .then( ({ value, done }) => /* ... */ ); 上面代码中，asyncIterator是一个异步遍历器，调用next方法以后，返回一个 Promise 对象。因此，可以使用then方法指定，这个 Promise 对象的状态变为resolve以后的回调函数。回调函数的参数，则是一个具有value和done两个属性的对象，这个跟同步遍历器是一样的。 我们知道，一个对象的同步遍历器的接口，部署在Symbol.iterator属性上面。同样地，对象的异步遍历器接口，部署在Symbol.asyncIterator属性上面。不管是什么样的对象，只要它的Symbol.asyncIterator属性有值，就表示应该对它进行异步遍历。 下面是一个异步遍历器的例子： const asyncIterable = createAsyncIterable(['a', 'b']); const asyncIterator = asyncIterable[Symbol.asyncIterator](); asyncIterator .next() .then(iterResult1 => { console.log(iterResult1); // { value: 'a', done: false } return asyncIterator.next(); }) .then(iterResult2 => { console.log(iterResult2); // { value: 'b', done: false } return asyncIterator.next(); }) .then(iterResult3 => { console.log(iterResult3); // { value: undefined, done: true } }); 上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象resolve了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。 由于异步遍历器的next方法，返回的是一个 Promise 对象。因此，可以把它放在await命令后面。 async function f() { const asyncIterable = createAsyncIterable(['a', 'b']); const asyncIterator = asyncIterable[Symbol.asyncIterator](); console.log(await asyncIterator.next()); // { value: 'a', done: false } console.log(await asyncIterator.next()); // { value: 'b', done: false } console.log(await asyncIterator.next()); // { value: undefined, done: true } } 上面代码中，next方法用await处理以后，就不必使用then方法了。整个流程已经很接近同步处理了。 注意，异步遍历器的next方法是可以连续调用的，不必等到上一步产生的 Promise 对象resolve以后再调用。这种情况下，next方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的next方法放在Promise.all方法里面。 const asyncIterable = createAsyncIterable(['a', 'b']); const asyncIterator = asyncIterable[Symbol.asyncIterator](); const [{value: v1}, {value: v2}] = await Promise.all([ asyncIterator.next(), asyncIterator.next() ]); console.log(v1, v2); // a b 另一种用法是一次性调用所有的next方法，然后await最后一步操作。 async function runner() { const writer = openFile('someFile.txt'); writer.next('hello'); writer.next('world'); await writer.return(); } runner(); 3. for await...of 前面介绍过，for...of循环用于遍历同步的 Iterator 接口。新引入的for await...of循环，则是用于遍历异步的 Iterator 接口。 async function f() { for await (const x of createAsyncIterable(['a', 'b'])) { console.log(x); } } // a // b 上面代码中，createAsyncIterable()返回一个拥有异步遍历器接口的对象，for...of循环自动调用这个对象的异步遍历器的next方法，会得到一个 Promise 对象。await用来处理这个 Promise 对象，一旦resolve，就把得到的值（x）传入for...of的循环体。 for await...of循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环。 let body = ''; async function f() { for await(const data of req) body += data; const parsed = JSON.parse(body); console.log('got', parsed); } 上面代码中，req是一个 asyncIterable 对象，用来异步读取数据。可以看到，使用for await...of循环以后，代码会非常简洁。 如果next方法返回的 Promise 对象被reject，for await...of就会报错，要用try...catch捕捉。 async function () { try { for await (const x of createRejectingIterable()) { console.log(x); } } catch (e) { console.error(e); } } 注意，for await...of循环也可以用于同步遍历器。 (async function () { for await (const x of ['a', 'b']) { console.log(x); } })(); // a // b 4. 异步 Generator 函数 就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。 在语法上，异步 Generator 函数就是async函数与 Generator 函数的结合。 async function* gen() { yield 'hello'; } const genObj = gen(); genObj.next().then(x => console.log(x)); // { value: 'hello', done: false } 异步遍历器的设计目的之一，就是 Generator 函数处理同步操作和异步操作时，能够使用同一套接口。 // 同步 Generator 函数 function* map(iterable, func) { const iter = iterable[Symbol.iterator](); while (true) { const {value, done} = iter.next(); if (done) break; yield func(value); } } // 异步 Generator 函数 async function* map(iterable, func) { const iter = iterable[Symbol.asyncIterator](); while (true) { const {value, done} = await iter.next(); if (done) break; yield func(value); } } 上面代码中，map是一个 Generator 函数，第一个参数是可遍历对象iterable，第二个参数是一个回调函数func。map的作用是将iterable每一步返回的值，使用func进行处理。上面有两个版本的map，前一个处理同步遍历器，后一个处理异步遍历器，可以看到两个版本的写法基本上是一致的。 5. yield* 语句 yield*语句也可以跟一个异步遍历器。 async function* gen1() { yield 'a'; yield 'b'; return 2; } async function* gen2() { // result 最终会等于 2 const result = yield* gen1(); } 上面代码中，gen2函数里面的result变量，最后的值是2。 与同步 Generator 函数一样，for await...of循环会展开yield*。 (async function () { for await (const x of gen2()) { console.log(x); } })(); // a // b Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-09 23:15 "},"newest-proposal.html":{"url":"newest-proposal.html","title":"最新提案","keywords":"","body":"最新提案 1. do 表达式 （尚未实现） 本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。 { let t = f(); t = t * t + 1; } 上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。 现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式，然后就会返回内部最后执行的表达式的值。 let x = do { let t = f(); t * t + 1; }; 面代码中，变量x会得到整个块级作用域的返回值（t * t + 1）。 do表达式的逻辑非常简单：封装的是什么，就会返回什么。 // 等同于 do { ; } // 等同于 do { } do表达式的好处是可以封装多个语句，让程序更加模块化，就像乐高积木那样一块块拼装起来。 let x = do { if (foo()) { f() } else if (bar()) { g() } else { h() } }; 值得一提的是，do表达式在 JSX 语法中非常好用。 return ( { do { if (loggedIn) { } else { } } } ) 2. throw 表达式（尚未实现） JavaScript 语法规定throw是一个命令，用来抛出错误，不能用于表达式之中。 // 报错 console.log(throw new Error()); 上面代码中，console.log的参数必须是一个表达式，如果是一个throw语句就会报错。 现在有一个提案，允许throw用于表达式。 // 参数的默认值 function save(filename = throw new TypeError(\"Argument required\")) { } // 箭头函数的返回值 lint(ast, { with: () => throw new Error(\"avoid using 'with' statements.\") }); // 条件表达式 function getEncoder(encoding) { const encoder = encoding === \"utf8\" ? new UTF8Encoder() : encoding === \"utf16le\" ? new UTF16Encoder(false) : encoding === \"utf16be\" ? new UTF16Encoder(true) : throw new Error(\"Unsupported encoding\"); } // 逻辑表达式 class Product { get id() { return this._id; } set id(value) { this._id = value || throw new Error(\"Invalid value\"); } } 3. 函数的部分执行（尚未实现） 1）语法 多参数的函数有时需要绑定其中的一个或多个参数，然后返回一个新函数。 function add(x, y) { return x + y; } function add7(x) { return x + 7; } 上面代码中，add7函数其实是add函数的一个特殊版本，通过将一个参数绑定为7，就可以从add得到add7。 // bind 方法 const add7 = add.bind(null, 7); // 箭头函数 const add7 = x => add(x, 7); 上面两种写法都有些冗余。其中，bind方法的局限更加明显，它必须提供this，并且只能从前到后一个个绑定参数，无法只绑定非头部的参数。 现在有一个提案，使得绑定参数并返回一个新函数更加容易。这叫做函数的部分执行（partial application）。 const add = (x, y) => x + y; const addOne = add(1, ?); const maxGreaterThanZero = Math.max(0, ...); 根据新提案，?是单个参数的占位符，...是多个参数的占位符。以下的形式都属于函数的部分执行。 f(x, ?) f(x, ...) f(?, x) f(..., x) f(?, x, ?) f(..., x, ...) ?和...只能出现在函数的调用之中，并且会返回一个新函数。 const g = f(?, 1, ...); // 等同于 const g = (x, ...y) => f(x, 1, ...y); 2）注意点 函数的部分执行是基于原函数的。如果原函数发生变化，部分执行生成的新函数也会立即反映这种变化。 let f = (x, y) => x + y; const g = f(?, 3); g(1); // 4 // 替换函数 f f = (x, y) => x * y; g(1); // 3 如果预先提供的那个值是一个表达式，那么这个表达式并不会在定义时求值，而是在每次调用时求值。 let a = 3; const f = (x, y) => x + y; const g = f(?, a); g(1); // 4 // 改变 a 的值 a = 10; g(1); // 11 如果新函数的参数多于占位符的数量，那么多余的参数将被忽略。 const f = (x, ...y) => [x, ...y]; const g = f(?, 1); g(2, 3, 4); // [2, 1] 写成下面这样，多余的参数就没有问题。 const f = (x, ...y) => [x, ...y]; const g = f(?, 1, ...); g(2, 3, 4); // [2, 1, 3, 4]; ...只会被采集一次，如果函数的部分执行使用了多个...，那么每个...的值都将相同。 const f = (...x) => x; const g = f(..., 9, ...); g(1, 2, 3); // [1, 2, 3, 9, 1, 2, 3] g定义了两个...占位符，真正执行的时候，它们的值是一样的。 4. 管道运算符（尚未实现） JavaScript 的管道是一个运算符，写作|>。它的左边是一个表达式，右边是一个函数。管道运算符把左边表达式的值，传入右边的函数进行求值。 x |> f // 等同于 f(x) 管道运算符最大的好处，就是可以把嵌套的函数，写成从左到右的链式表达式。 function doubleSay (str) { return str + \", \" + str; } function capitalize (str) { return str[0].toUpperCase() + str.substring(1); } function exclaim (str) { return str + '!'; } 上面是三个简单的函数。如果要嵌套执行，传统的写法和管道的写法分别如下。 // 传统的写法 exclaim(capitalize(doubleSay('hello'))) // \"Hello, hello!\" // 管道的写法 'hello' |> doubleSay |> capitalize |> exclaim // \"Hello, hello!\" 管道运算符只能传递一个值，这意味着它右边的函数必须是一个单参数函数。如果是多参数函数，就必须进行柯里化，改成单参数的版本。 function double (x) { return x + x; } function add (x, y) { return x + y; } let person = { score: 25 }; person.score |> double |> (_ => add(7, _)) // 57 管道运算符对于await函数也适用。 x |> await f // 等同于 await f(x) const userAge = userId |> await fetchUserById |> getAgeFromUser; // 等同于 const userAge = getAgeFromUser(await fetchUserById(userId)); 5. 数值分隔符（已实现） 欧美语言中，较长的数值允许每三位添加一个分隔符（通常是一个逗号），增加数值的可读性。比如，1000可以写作1,000。 现在有一个提案，允许 JavaScript 的数值使用下划线（_）作为分隔符。 let budget = 1_000_000_000_000; budget === 10 ** 12 // true JavaScript 的数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。 123_00 === 12_300 // true 12345_00 === 123_4500 // true 12345_00 === 1_234_500 // true 小数和科学计数法也可以使用数值分隔符。 // 小数 0.000_001 // 科学计数法 1e10_000 数值分隔符有几个使用注意点。 不能在数值的最前面（leading）或最后面（trailing）。 不能两个或两个以上的分隔符连在一起。 小数点的前后不能有分隔符。 科学计数法里面，表示指数的e或E前后不能有分隔符。 下面的写法都会报错： // 全部报错 3_.141 3._141 1_e12 1e_12 123__456 _1464301 1464301_ 除了十进制，其他进制的数值也可以使用分隔符。 // 二进制 0b1010_0001_1000_0101 // 十六进制 0xA0_B0_C0 注意，分隔符不能紧跟着进制的前缀0b、0B、0o、0O、0x、0X。 // 报错 0_b111111000 0b_111111000 下面三个将字符串转成数值的函数，不支持数值分隔符。主要原因是提案的设计者认为，数值分隔符主要是为了编码时书写数值的方便，而不是为了处理外部输入的数据。 Number() parseInt() parseFloat() Number('123_456') // NaN parseInt('123_456') // 123 6. Math.signbit()（尚未实现） Math.sign()用来判断一个值的正负，但是如果参数是-0，它会返回-0。 Math.sign(-0) // -0 这导致对于判断符号位的正负，Math.sign()不是很有用。JavaScript 内部使用 64 位浮点数（国际标准 IEEE 754）表示数值，IEEE 754 规定第一位是符号位，0表示正数，1表示负数。所以会有两种零，+0是符号位为0时的零值，-0是符号位为1时的零值。实际编程中，判断一个值是+0还是-0非常麻烦，因为它们是相等的。 +0 === -0 // true 目前，有一个提案，引入了Math.signbit()方法判断一个数的符号位是否设置了。 Math.signbit(2) //false Math.signbit(-2) //true Math.signbit(0) //false Math.signbit(-0) //true 可以看到，该方法正确返回了-0的符号位是设置了的。 该方法的算法如下： 如果参数是NaN，返回false 如果参数是-0，返回true 如果参数是负值，返回true 其他情况返回false 7. 双冒号运算符（尚未实现） 箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。 foo::bar; // 等同于 bar.bind(foo); foo::bar(...arguments); // 等同于 bar.apply(foo, arguments); const hasOwnProperty = Object.prototype.hasOwnProperty; function hasOwn(obj, key) { return obj::hasOwnProperty(key); } 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 var method = obj::obj.foo; // 等同于 var method = ::obj.foo; let log = ::console.log; // 等同于 var log = console.log.bind(console); 如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。 import { map, takeWhile, forEach } from \"iterlib\"; getPlayers() ::map(x => x.character()) ::takeWhile(x => x.strength > 100) ::forEach(x => console.log(x)); 8. Realm API（尚未实现） Realm API 提供沙箱功能（sandbox），允许隔离代码，防止那些被隔离的代码拿到全局对象。 以前，经常使用作为沙箱。 const globalOne = window; let iframe = document.createElement('iframe'); document.body.appendChild(iframe); const globalTwo = iframe.contentWindow; 上面代码中，`的全局对象是独立的（iframe.contentWindow`）。Realm API 可以取代这个功能。 const globalOne = window; const globalTwo = new Realm().global; 上面代码中，Realm API单独提供了一个全局对象new Realm().global。 Realm API 提供一个Realm()构造函数，用来生成一个 Realm 对象。该对象的global属性指向一个新的顶层对象，这个顶层对象跟原始的顶层对象类似。 const globalOne = window; const globalTwo = new Realm().global; globalOne.evaluate('1 + 2') // 3 globalTwo.evaluate('1 + 2') // 3 下面的代码可以证明，Realm 顶层对象与原始顶层对象是两个对象。 let a1 = globalOne.evaluate('[1,2,3]'); let a2 = globalTwo.evaluate('[1,2,3]'); a1.prototype === a2.prototype; // false a1 instanceof globalTwo.Array; // false a2 instanceof globalOne.Array; // false Realm 沙箱里面只能运行 ECMAScript 语法提供的 API，不能运行宿主环境提供的 API。 globalTwo.evaluate('console.log(1)') // throw an error: console is undefined 上面代码中，Realm 沙箱里面没有console对象，导致报错。因为console不是语法标准，是宿主环境提供的。 如果要解决这个问题，可以使用下面的代码。 globalTwo.console = globalOne.console; 9. #! 命令 Unix 的命令行脚本都支持#!命令，又称为 Shebang 或 Hashbang。这个命令放在脚本的第一行，用来指定脚本的执行器。 #!/bin/sh Python 脚本的第一行。 #!/usr/bin/env python 现在有一个提案，为 JavaScript 脚本引入了#!命令，写在脚本文件或者模块文件的第一行。 // 写在脚本文件第一行 #!/usr/bin/env node 'use strict'; console.log(1); // 写在模块文件第一行 #!/usr/bin/env node export {}; console.log(1); 有了这一行以后，Unix 命令行就可以直接执行脚本。 # 以前执行脚本的方式 $ node hello.js # hashbang 的方式 $ hello.js 对于 JavaScript 引擎来说，会把#!理解成注释，忽略掉这一行。 10. import.meta 开发者使用一个模块时，有时需要知道模板本身的一些信息（比如模块的路径）。现在有一个提案，为 import 命令添加了一个元属性import.meta，返回当前模块的元信息。 import.meta只能在模块内部使用，如果在模块外部使用会报错。 这个属性返回一个对象，该对象的各种属性就是当前运行的脚本的元信息。具体包含哪些属性，标准没有规定，由各个运行环境自行决定。一般来说，import.meta至少会有下面两个属性。 1） import.meta.url import.meta.url返回当前模块的 URL 路径。举例来说，当前模块主文件的路径是https://foo.com/main.js，import.meta.url就返回这个路径。如果模块里面还有一个数据文件data.txt，那么就可以用下面的代码，获取这个数据文件的路径。 new URL('data.txt', import.meta.url) 注意，Node.js 环境中，import.meta.url返回的总是本地路径，即是file:URL协议的字符串，比如file:///home/user/foo.js。 2）import.meta.scriptElement import.meta.scriptElement是浏览器特有的元属性，返回加载模块的那个元素，相当于document.currentScript属性。 // HTML 代码为 // // my-module.js 内部执行下面的代码 import.meta.scriptElement.dataset.foo // \"abc\" Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-09 23:15 "},"reference-linking.html":{"url":"reference-linking.html","title":"参考链接","keywords":"","body":"参考链接 感谢 阮一峰 文档的支持，学后受益匪浅，更快的理解ES6，更容易的上手ES6，以下都是复制来的，大家可以去他的官网翻阅。 1. 官方文件 ECMAScript® 2015 Language Specification: ECMAScript 2015 规格 ECMAScript® 2016 Language Specification: ECMAScript 2016 规格 ECMAScript® 2017 Language Specification：ECMAScript 2017 规格（草案） ECMAScript Current Proposals: ECMAScript 当前的所有提案 ECMAScript Active Proposals: 已经进入正式流程的提案 ECMAScript proposals：从阶段 0 到阶段 4 的所有提案列表 TC39 meeting agendas: TC39 委员会历年的会议记录 ECMAScript Daily: TC39 委员会的动态 The TC39 Process: 提案进入正式规格的流程 TC39: A Process Sketch, Stages 0 and 1: Stage 0 和 Stage 1 的含义 TC39 Process Sketch, Stage 2: Stage 2 的含义 2. 综合介绍 Axel Rauschmayer, Exploring ES6: Upgrade to the next version of JavaScript: ES6 的专著，本书的许多代码实例来自该书 Sayanee Basu, Use ECMAScript 6 Today Ariya Hidayat, Toward Modern Web Apps with ECMAScript 6 Dale Schouten, 10 Ecmascript-6 tricks you can perform right now Colin Toh, Lightweight ES6 Features That Pack A Punch: ES6 的一些“轻量级”的特性介绍 Domenic Denicola, ES6: The Awesome Parts Nicholas C. Zakas, Understanding ECMAScript 6 Justin Drake, ECMAScript 6 in Node.JS Ryan Dao, Summary of ECMAScript 6 major features Luke Hoban, ES6 features: ES6 新语法点的罗列 Traceur-compiler, Language Features: Traceur 文档列出的一些 ES6 例子 Axel Rauschmayer, ECMAScript 6: what’s next for JavaScript?: 关于 ES6 新增语法的综合介绍，有很多例子 Axel Rauschmayer, Getting started with ECMAScript 6: ES6 语法点的综合介绍 Toby Ho, ES6 in io.js Guillermo Rauch, ECMAScript 6 Benjamin De Cock, Frontend Guidelines: ES6 最佳实践 Jani Hartikainen, ES6: What are the benefits of the new features in practice? kangax, JavaScript quiz. ES6 edition: ES6 小测试 Jeremy Fairbank, HTML5DevConf ES7 and Beyond!: ES7 新增语法点介绍 Timothy Gu, How to Read the ECMAScript Specification: 如何读懂 ES6 规格 3. let和const Kyle Simpson, For and against let: 讨论 let 命令的作用域 kangax, Why typeof is no longer “safe”: 讨论在块级作用域内，let 命令的变量声明和赋值的行为 Axel Rauschmayer, Variables and scoping in ECMAScript 6: 讨论块级作用域与 let 和 const 的行为 Nicolas Bevacqua, ES6 Let, Const and the “Temporal Dead Zone” (TDZ) in Depth acorn, Function statements in strict mode: 块级作用域对严格模式的函数声明的影响 Axel Rauschmayer, ES proposal: global: 顶层对象global Mathias Bynens, A horrifying globalThis polyfill in universal JavaScript：如何写 globalThis 的垫片库 4. 解构赋值 Nick Fitzgerald, Destructuring Assignment in ECMAScript 6: 详细介绍解构赋值的用法 Nicholas C. Zakas, ECMAScript 6 destructuring gotcha 5. 字符串 Nicholas C. Zakas, A critical review of ECMAScript 6 quasi-literals Mozilla Developer Network, Template strings Addy Osmani, Getting Literal With ES6 Template Strings: 模板字符串的介绍 Blake Winton, ES6 Templates: 模板字符串的介绍 Peter Jaszkowiak, How to write a template compiler in JavaScript: 使用模板字符串，编写一个模板编译函数 Axel Rauschmayer, ES.stage3: string padding 6. 正则 Mathias Bynens, Unicode-aware regular expressions in ES6: 详细介绍正则表达式的 u 修饰符 Axel Rauschmayer, New regular expression features in ECMAScript 6：ES6 正则特性的详细介绍 Yang Guo, RegExp lookbehind assertions：介绍后行断言 Axel Rauschmayer, ES proposal: RegExp named capture groups: 具名组匹配的介绍 Mathias Bynens, ECMAScript regular expressions are getting better!: 介绍 ES2018 添加的多项正则语法 7. 数值 Nicolas Bevacqua, ES6 Number Improvements in Depth Axel Rauschmayer, ES proposal: arbitrary precision integers Mathias Bynens, BigInt: arbitrary-precision integers in JavaScript 8. 数组 Axel Rauschmayer, ECMAScript 6’s new array methods: 对 ES6 新增的数组方法的全面介绍 TC39, Array.prototype.includes: 数组的 includes 方法的规格 Axel Rauschmayer, ECMAScript 6: holes in Arrays: 数组的空位问题 9. 函数 Nicholas C. Zakas, Understanding ECMAScript 6 arrow functions Jack Franklin, Real Life ES6 - Arrow Functions Axel Rauschmayer, Handling required parameters in ECMAScript 6 Dmitry Soshnikov, ES6 Notes: Default values of parameters: 介绍参数的默认值 Ragan Wald, Destructuring and Recursion in ES6: rest 参数和扩展运算符的详细介绍 Axel Rauschmayer, The names of functions in ES6: 函数的 name 属性的详细介绍 Kyle Simpson, Arrow This: 箭头函数并没有自己的 this Derick Bailey, Do ES6 Arrow Functions Really Solve “this” In JavaScript?：使用箭头函数处理 this 指向，必须非常小心 Mark McDonnell, Understanding recursion in functional JavaScript programming: 如何自己实现尾递归优化 Nicholas C. Zakas, The ECMAScript 2016 change you probably don't know: 使用参数默认值时，不能在函数内部显式开启严格模式 Axel Rauschmayer, ES proposal: optional catch binding Cynthia Lee, When you should use ES6 arrow functions — and when you shouldn’t: 讨论箭头函数的适用场合 Eric Elliott, What is this?: 箭头函数内部的 this 的解释。 10. 对象 Addy Osmani, Data-binding Revolutions with Object.observe(): 介绍 Object.observe()的概念 Sella Rafaeli, Native JavaScript Data-Binding: 如何使用 Object.observe 方法，实现数据对象与 DOM 对象的双向绑定 Axel Rauschmayer, __proto__ in ECMAScript 6 Axel Rauschmayer, Enumerability in ECMAScript 6 Axel Rauschmayer, ES proposal: Object.getOwnPropertyDescriptors() TC39, Object.getOwnPropertyDescriptors Proposal David Titarenco, How Spread Syntax Breaks JavaScript: 扩展运算符的一些不合理的地方 11. Symbol Axel Rauschmayer, Symbols in ECMAScript 6: Symbol 简介 MDN, Symbol: Symbol 类型的详细介绍 Jason Orendorff, ES6 In Depth: Symbols Keith Cirkel, Metaprogramming in ES6: Symbols and why they're awesome: Symbol 的深入介绍 Axel Rauschmayer, Customizing ES6 via well-known symbols Derick Bailey, Creating A True Singleton In Node.js, With ES6 Symbols Das Surma, How to read web specs Part IIa – Or: ECMAScript Symbols: 介绍 Symbol 的规格 12. Set 和 Map Mozilla Developer Network, WeakSet：介绍 WeakSet 数据结构 Dwayne Charrington, What Are Weakmaps In ES6?: WeakMap 数据结构介绍 Axel Rauschmayer, ECMAScript 6: maps and sets: Set 和 Map 结构的详细介绍 Jason Orendorff, ES6 In Depth: Collections：Set 和 Map 结构的设计思想 Axel Rauschmayer, Converting ES6 Maps to and from JSON: 如何将 Map 与其他数据结构互相转换 13. Proxy 和 Reflect Nicholas C. Zakas, Creating defensive objects with ES6 proxies Axel Rauschmayer, Meta programming with ECMAScript 6 proxies: Proxy 详解 Daniel Zautner, Meta-programming JavaScript Using Proxies: 使用 Proxy 实现元编程 Tom Van Cutsem, Harmony-reflect: Reflect 对象的设计目的 Tom Van Cutsem, Proxy Traps: Proxy 拦截操作一览 Tom Van Cutsem, Reflect API Tom Van Cutsem, Proxy Handler API Nicolas Bevacqua, ES6 Proxies in Depth Nicolas Bevacqua, ES6 Proxy Traps in Depth Nicolas Bevacqua, More ES6 Proxy Traps in Depth Axel Rauschmayer, Pitfall: not all objects can be wrapped transparently by proxies Bertalan Miklos, Writing a JavaScript Framework - Data Binding with ES6 Proxies: 使用 Proxy 实现观察者模式 Keith Cirkel, Metaprogramming in ES6: Part 2 - Reflect: Reflect API 的详细介绍 14. Promise Jake Archibald, JavaScript Promises: There and back again Jake Archibald, Tasks, microtasks, queues and schedules Tilde, rsvp.js Sandeep Panda, An Overview of JavaScript Promises: ES6 Promise 入门介绍 Dave Atchley, ES6 Promises: Promise 的语法介绍 Axel Rauschmayer, ECMAScript 6 promises (2/2): the API: 对 ES6 Promise 规格和用法的详细介绍 Jack Franklin, Embracing Promises in JavaScript: catch 方法的例子 Ronald Chen, How to escape Promise Hell: 如何使用Promise.all方法的一些很好的例子 Jordan Harband, proposal-promise-try: Promise.try() 方法的提案 Sven Slootweg, What is Promise.try, and why does it matter?: Promise.try() 方法的优点 Yehuda Katz, TC39: Promises, Promises: Promise.try() 的用处 15. Iterator Mozilla Developer Network, Iterators and generators Mozilla Developer Network, The Iterator protocol Jason Orendorff, ES6 In Depth: Iterators and the for-of loop: 遍历器与 for...of 循环的介绍 Axel Rauschmayer, Iterators and generators in ECMAScript 6: 探讨 Iterator 和 Generator 的设计目的 Axel Rauschmayer, Iterables and iterators in ECMAScript 6: Iterator 的详细介绍 Kyle Simpson, Iterating ES6 Numbers: 在数值对象上部署遍历器 16. Generator Matt Baker, Replacing callbacks with ES6 Generators Steven Sanderson, Experiments with Koa and JavaScript Generators jmar777, What's the Big Deal with Generators? Marc Harter, Generators in Node.js: Common Misconceptions and Three Good Use Cases: 讨论 Generator 函数的作用 StackOverflow, ES6 yield : what happens to the arguments of the first call next()?: 第一次使用 next 方法时不能带有参数 Kyle Simpson, ES6 Generators: Complete Series: 由浅入深探讨 Generator 的系列文章，共四篇 Gajus Kuizinas, The Definitive Guide to the JavaScript Generators: 对 Generator 的综合介绍 Jan Krems, Generators Are Like Arrays: 讨论 Generator 可以被当作数据结构看待 Harold Cooper, Coroutine Event Loops in JavaScript: Generator 用于实现状态机 Ruslan Ismagilov, learn-generators: 编程练习，共 6 道题 Steven Sanderson, Experiments with Koa and JavaScript Generators: Generator 入门介绍，以 Koa 框架为例 Mahdi Dibaiee, ES7 Array and Generator comprehensions：ES7 的 Generator 推导 Nicolas Bevacqua, ES6 Generators in Depth Axel Rauschmayer, ES6 generators in depth: Generator 规格的详尽讲解 Derick Bailey, Using ES6 Generators To Short-Circuit Hierarchical Data Iteration：使用 for...of 循环完成预定的操作步骤 17. 异步操作和 Async函数 Luke Hoban, Async Functions for ECMAScript: Async 函数的设计思想，与 Promise、Gernerator 函数的关系 Jafar Husain, Asynchronous Generators for ES7: Async 函数的深入讨论 Nolan Lawson, Taming the asynchronous beast with ES7: async 函数通俗的实例讲解 Jafar Husain, Async Generators: 对 async 与 Generator 混合使用的一些讨论 Daniel Brain, Understand promises before you start using async/await: 讨论 async/await 与 Promise 的关系 Jake Archibald, Async functions - making promises friendly Axel Rauschmayer, ES proposal: asynchronous iteration: 异步遍历器的详细介绍 Dima Grossman, How to write async await without try-catch blocks in JavaScript: 除了 try/catch 以外的 async 函数内部捕捉错误的方法 Mostafa Gaafa, 6 Reasons Why JavaScript’s Async/Await Blows Promises Away: Async 函数的6个好处 Mathias Bynens, Asynchronous stack traces: why await beats Promise#then(): async 函数可以保留错误堆栈 18. Class Sebastian Porto, ES6 classes and JavaScript prototypes: ES6 Class 的写法与 ES5 Prototype 的写法对比 Jack Franklin, An introduction to ES6 classes: ES6 class 的入门介绍 Axel Rauschmayer, ECMAScript 6: new OOP features besides classes Axel Rauschmayer, Classes in ECMAScript 6 (final semantics): Class 语法的详细介绍和设计思想分析 Eric Faust, ES6 In Depth: Subclassing: Class 语法的深入介绍 Nicolás Bevacqua, Binding Methods to Class Instance Objects: 如何绑定类的实例中的 this Jamie Kyle, JavaScript's new #private class fields：私有属性的介绍。 Mathias Bynens, Public and private class fields：实例属性的新写法的介绍。 19. Decorator Maximiliano Fierro, Declarative vs Imperative: Decorators 和 Mixin 介绍 Justin Fagnani, \"Real\" Mixins with JavaScript Classes: 使用类的继承实现 Mixin Addy Osmani, Exploring ES2016 Decorators: Decorator 的深入介绍 Sebastian McKenzie, Allow decorators for functions as well: 为什么修饰器不能用于函数 Maximiliano Fierro, Traits with ES7 Decorators: Trait 的用法介绍 Jonathan Creamer: Using ES2016 Decorators to Publish on an Event Bus: 使用修饰器实现自动发布事件 20. Module Jack Franklin, JavaScript Modules the ES6 Way: ES6 模块入门 Axel Rauschmayer, ECMAScript 6 modules: the final syntax: ES6 模块的介绍，以及与 CommonJS 规格的详细比较 Dave Herman, Static module resolution: ES6 模块的静态化设计思想 Jason Orendorff, ES6 In Depth: Modules: ES6 模块设计思想的介绍 Ben Newman, The Importance of import and export: ES6 模块的设计思想 ESDiscuss, Why is \"export default var a = 1;\" invalid syntax? Bradley Meck, ES6 Module Interoperability: 介绍 Node 如何处理 ES6 语法加载 CommonJS 模块 Axel Rauschmayer, Making transpiled ES modules more spec-compliant: ES6 模块编译成 CommonJS 模块的详细介绍 Axel Rauschmayer, ES proposal: import() – dynamically importing ES modules: import() 的用法 Node EPS, ES Module Interoperability: Node 对 ES6 模块的处理规格 21. 二进制数组 Ilmari Heikkinen, Typed Arrays: Binary Data in the Browser Khronos, Typed Array Specification Ian Elliot, Reading A BMP File In JavaScript Renato Mangini, How to convert ArrayBuffer to and from String Axel Rauschmayer, Typed Arrays in ECMAScript 6 Axel Rauschmayer, ES proposal: Shared memory and atomics Lin Clark, Avoiding race conditions in SharedArrayBuffers with Atomics: Atomics 对象使用场景的解释 Lars T Hansen, Shared memory - a brief tutorial James Milner, The Return of SharedArrayBuffers and Atomics 22. SIMD TC39, SIMD.js Stage 2 MDN, SIMD TC39, ECMAScript SIMD Axel Rauschmayer, JavaScript gains support for SIMD 23. 工具 Babel, Babel Handbook: Babel 的用法介绍 Google, traceur-compiler: Traceur 编译器 Casper Beyer, ECMAScript 6 Features and Tools Stoyan Stefanov, Writing ES6 today with jstransform ES6 Module Loader, ES6 Module Loader Polyfill: 在浏览器和 node.js 加载 ES6 模块的一个库，文档里对 ES6 模块有详细解释 Paul Miller, es6-shim: 一个针对老式浏览器，模拟 ES6 部分功能的垫片库（shim） army8735, JavaScript Downcast: 国产的 ES6 到 ES5 的转码器 esnext, ES6 Module Transpiler：基于 node.js 的将 ES6 模块转为 ES5 代码的命令行工具 Sebastian McKenzie, BabelJS: ES6 转译器 SystemJS, SystemJS: 在浏览器中加载 AMD、CJS、ES6 模块的一个垫片库 Modernizr, HTML5 Cross Browser Polyfills: ES6 垫片库清单 Facebook, regenerator: 将 Generator 函数转为 ES5 的转码器 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-29 00:41 "}}