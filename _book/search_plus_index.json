{"./":{"url":"./","title":"简介","keywords":"","body":"ES6 基础入门 以下内容多节选自 阮一峰 的 ES6 博客，本人摘抄了他的精髓，记录成册，与君共享 1. ECMAScript 和 JavaScript 的关系是 ​ 前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。 2. ES6 与 ECMAScript2015 的关系 ​ 2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。 ​ 但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。 ​ 但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。 ​ 标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。 ​ ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。 ​ 因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。 3. 查看 Node.js 默认没有打开的 ES6 实验性语法 // Linux & Mac $ node --v8-options | grep harmony // Windows $ node --v8-options | findstr harmony 4. Babel 转码器 Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。 // 转码前 input.map(item => item + 1); // 转码后 input.map(function (item) { return item + 1; }); 上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。 下面的命令在项目目录中，安装 Babel。 $ npm install --save-dev @babel/core 1. 配置文件 .babelrc Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。 该文件用来设置转码规则和插件，基本格式如下。 presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。 # 最新转码规则 $ npm install --save-dev @babel/preset-env # react 转码规则 $ npm install --save-dev @babel/preset-react 然后，将这些规则加入.babelrc。 { \"presets\": [ \"@babel/env\", \"@babel/preset-react\" ], \"plugins\": [] } 注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。 2. 命令行转码 Babel 提供命令行工具@babel/cli，用于命令行转码。 安装模块 $ npm install --save-dev @babel/cli 基本用法如下： # 转码结果输出到标准输出 $ npx babel example.js # 转码结果写入一个文件 # --out-file 或 -o 参数指定输出文件 $ npx babel example.js --out-file compiled.js # 或者 $ npx babel example.js -o compiled.js # 整个目录转码 # --out-dir 或 -d 参数指定输出目录 $ npx babel src --out-dir lib # 或者 $ npx babel src -d lib # -s 参数生成source map文件 $ npx babel src -d lib -s 3. babel-node @babel/node模块的babel-node命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。 安装模块 $ npm install --save-dev @babel/node 然后，执行babel-node就进入 REPL 环境。 $ npx babel-node > (x => x * 2)(1) 2 babel-node命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。 # es6.js 的代码 # console.log((x => x * 2)(1)); $ npx babel-node es6.js 2 4. babel/register 模块 @babel/register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 Babel 进行转码。 $ npm install --save-dev @babel/register 使用时，必须首先加载@babel/register。 // index.js require('@babel/register'); require('./es6.js') 然后，就不需要手动对index.js转码了。 $ node index.js 2 需要注意的是，@babel/register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。 5. babel API 如果某些代码需要调用 Babel 的 API 进行转码，就要使用@babel/core模块。 // 字符串转码 babel.transform('code();', options); // => { code, map, ast } // 文件转码（异步） babel.transformFile('filename.js', options, function(err, result) { result; // => { code, map, ast } }); // 文件转码（同步） babel.transformFileSync('filename.js', options); // => { code, map, ast } // Babel AST转码 babel.transformFromAst(ast, code, options); // => { code, map, ast } 配置对象options，可以参看官方文档http://babeljs.io/docs/usage/options/。 下面是一个例子。 var es6Code = 'let x = n => n + 1'; var es5Code = require('@babel/core') .transform(es6Code, { presets: ['@babel/env'] }) .code; console.log(es5Code); // '\"use strict\";\\n\\nvar x = function x(n) {\\n return n + 1;\\n};' 上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的 ES6 代码，第二个参数是转换的配置对象。 6. babel/polyfill Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。 安装命令如下: $ npm install --save-dev @babel/polyfill 然后，在脚本头部，加入如下一行代码。 import '@babel/polyfill'; // 或者 require('@babel/polyfill'); Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的definitions.js文件。 7. 浏览器环境 Babel 也可以用于浏览器环境，使用@babel/standalone模块提供的浏览器版本，将其插入网页。 // Your ES6 code 注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。 Babel 提供一个REPL 在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-24 23:53 "},"let-const.html":{"url":"let-const.html","title":"let 和 const 命令","keywords":"","body":"let 和 const 命令 1. let 命令 1.）基本用法 * ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 { let a = 10; var b = 1; } a // ReferenceError: a is not defined. b // 1 for循环的计数器，就很合适使用let命令。 for (let i = 0; i 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 var a = []; for (var i = 0; i 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。 var a = []; for (let i = 0; i 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 for (let i = 0; i 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 2）不存在变量提升 * var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; 3）暂时性死区 * 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 if (true) { // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123 } 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 typeof x; // ReferenceError let x; 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 typeof undeclared_variable // \"undefined\" 有些“死区”比较隐蔽，不太容易发现。 function bar(x = y, y = 2) { return [x, y]; } bar(); // 报错 Uncaught ReferenceError: Cannot access 'y' before initialization 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。 function bar(x = 2, y = x) { return [x, y]; } bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。 // 不报错 var x = x; // 报错 let x = x; // ReferenceError: x is not defined ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 4）不允许重复声明 * let不允许在相同作用域内，重复声明同一个变量。 // 报错 function func() { let a = 10; var a = 1; } // 报错 function func() { let a = 10; let a = 1; } 不能在函数内部重新声明参数。 function func(arg) { let arg; } func() // 报错 function func(arg) { { let arg; } } func() // 不报错 2. 块级作用域 1）为什么需要块级作用域 * ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 内层变量可能会覆盖外层变量。 var tmp = 'hello'; function f() { console.log(tmp); if (false) { var tmp = 'world'; } } f(); // undefined 用来计数的循环变量泄露为全局变量。 var tmp = 'hello'; for (var i = 0; i 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。 { {let insane = 'Hello World'} console.log(insane); // 报错 }; 内层作用域可以定义外层作用域的同名变量。 { let insane = 'Hello'; {let insane = 'World'} }; 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。 // IIFE 写法 (function () { var tmp = ...; ... }()); // 块级作用域写法 { let tmp = ...; ... } 2）块级作用域与函数声明 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 // 情况一 if (true) { function f() {} } // 情况二 try { function f() {} } catch(e) { // ... } 上面两种函数声明，根据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 function f() { console.log('I am outside!'); } (function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f(); }()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。 // ES5 环境 function f() { console.log('I am outside!'); } (function () { function f() { console.log('I am inside!'); } if (false) { } f(); }()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ // 浏览器的 ES6 环境 function f() { console.log('I am outside!'); } (function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f(); }()); // Uncaught TypeError: f is not a function ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。上面的例子实际运行的代码如下。 // 浏览器的 ES6 环境 function f() { console.log('I am outside!'); } (function () { var f = undefined; if (false) { function f() { console.log('I am inside!'); } } f(); }()); // Uncaught TypeError: f is not a function 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 // 块级作用域内部的函数声明语句，建议不要使用 { let a = 'secret'; function f() { return a; } } // 块级作用域内部，优先使用函数表达式 { let a = 'secret'; let f = function () { return a; }; } 另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。 // 第一种写法，报错 if (true) let x = 1; // 第二种写法，不报错 if (true) { let x = 1; } 函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。 // 不报错 'use strict'; if (true) { function f() {} } // 报错 'use strict'; if (true) function f() {} 3. const 命令 1）基本用法 * const声明一个只读的常量。一旦声明，常量的值就不能改变。 const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. const一旦声明变量，就必须立即初始化，不能留到以后赋值。只声明不赋值，就会报错。 const foo; // SyntaxError: Missing initializer in const declaration 除了不可改变值，其他用法和let相似 3）本质 * const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 const foo = {}; // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop // 123 // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: \"foo\" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 const a = []; a.push('Hello'); // 可执行 a.length = 0; // 可执行 a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果真的想将对象冻结，应该使用Object.freeze方法。 const foo = Object.freeze({}); // 常规模式时，下面一行不起作用； // 严格模式时，该行会报错 foo.prop = 123; 将对象彻底冻结的函数。 var constantize = (obj) => { Object.freeze(obj); Object.keys(obj).forEach( (key, i) => { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } }); }; 4. 顶层对象的属性 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 window.a = 1; a // 1 a = 2; window.a // 2 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题： 没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）。 程序员很容易不知不觉地就创建了全局变量（比如打字出错）。 顶层对象的属性是到处可以读写的，这非常不利于模块化编程。 window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性。 另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。 var a = 1; // 如果在 Node 的 REPL 环境，可以写成 global.a // 或者采用通用方法，写成 this.a window.a // 1 let b = 1; window.b // undefined 5. globalThis对象 * JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。 ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-26 23:56 "},"destructuring-assignment.html":{"url":"destructuring-assignment.html","title":"变量的解构赋值","keywords":"","body":"变量的解构赋值 重要知识点 ： 1. 交换变量的值 * let [x,y] = [1,2] [x,y] = [y,x] 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 2. 从函数返回多个值 * 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 // 返回一个数组,数组中取出多个对象 function example() { return [1, 2, 3]; } let [a, b, c] = example(); // 返回一个对象,对象中取出多个对象 function example() { return { foo: 1, bar: 2 }; } let { foo, bar } = example(); 3. 函数参数的定义 * 解构赋值可以方便地将一组参数与变量名对应起来。 // 参数是一组有次序的值 function f([x, y, z]) { ... } f([1, 2, 3]); // 参数是一组无次序的值 function f({x, y, z}) { ... } f({z: 3, y: 2, x: 1}); 4. 提取 JSON 数据 * 可以快速提取 JSON 数据的值。 let jsonData = { id: 42, status: \"OK\", data: [867, 5309] }; let { id, status, data: number } = jsonData; console.log(id, status, number); // 42, \"OK\", [867, 5309] 5. 函数参数的默认值 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。 const fn = function({x='hello',y='world'}={}){ ... } 6. 遍历 Map 结构 * 任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 const map = new Map(); map.set('first', 'hello'); map.set('second', 'world'); for (let [key, value] of map) { console.log(key + \" is \" + value); } // first is hello // second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 // 获取键名 for (let [key] of map) { // ... } // 获取键值 for (let [,value] of map) { // ... } 7. 引入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 const { SourceMapConsumer, SourceNode } = require(\"source-map\"); Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-24 23:53 "},"string-extend.html":{"url":"string-extend.html","title":"字符串的扩展","keywords":"","body":"字符串的扩展 1. 字符串的遍历接口 for (let codePoint of 'foo') { console.log(codePoint) } // \"f\" // \"o\" // \"o\" 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 let text = String.fromCodePoint(0x20BB7); for (let i = 0; i 2. 直接输入 U+2028 和 U+2029 JavaScript 字符串允许直接输入字符，以及输入字符的转义形式（Unicode编码） JavaScript 规定有3个字符，不能在字符串里面直接使用，只能使用转义形式。 U+005C：反斜杠（reverse solidus) U+000D：回车（carriage return） U+000A：换行符（line feed） 3. 模板字符串 * 传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。 $('#result').append( 'There are ' + basket.count + ' ' + 'items in your basket, ' + '' + basket.onSale + ' are on sale!' ); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 $('#result').append(` There are ${basket.count} items in your basket, ${basket.onSale} are on sale! `); 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 let greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 $('#list').html(` first second `); 模板字符串中嵌入变量，需要将变量名写在${}之中。 `User ${user.name} is not authorized to do ${action}.` 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 let x = 1; let y = 2; `${x} + ${y} = ${x + y}` // \"1 + 2 = 3\" `${x} + ${y * 2} = ${x + y * 2}` // \"1 + 4 = 5\" let obj = {x: 1, y: 2}; `${obj.x + obj.y}` // \"3\" 模板字符串之中还能调用函数。 function fn() { return \"Hello World\"; } `foo ${fn()} bar` // foo Hello World bar 模板字符串甚至还能嵌套。 const tmpl = addrs => ` ${addrs.map(addr => ` ${addr.first} ${addr.last} `).join('')} `; 4. 标签模板 它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 alert`hello` // 等同于 alert(['hello']) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 let a = 5; let b = 10; tag`Hello ${ a + b } world ${ a * b }`; // 等同于 tag(['Hello ', ' world ', ''], 15, 50); “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 let message = SaferHTML`${sender} has sent you a message.`; function SaferHTML(templateData) { let s = templateData[0]; for (let i = 1; i /g, \"&gt;\"); // Don't escape special characters in the template. s += templateData[i]; } return s; } 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 let sender = 'alert(\"abc\")'; // 恶意代码 let message = SaferHTML`${sender} has sent you a message.`; message // &lt;script&gt;alert(\"abc\")&lt;/script&gt; has sent you a message. 标签模板的另一个应用，就是多语言转换（国际化处理）。 i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!` // \"欢迎访问xxx，您是第xxxx位访问者！\" Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-25 23:45 "},"string-new-method.html":{"url":"string-new-method.html","title":"字符串的新增方法","keywords":"","body":"字符串的新增方法 1. includes(), startsWith(), endsWith() 传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 let s = 'Hello world!'; s.startsWith('Hello') // true s.endsWith('!') // true s.includes('o') // true 这三个方法都支持第二个参数，表示开始搜索的位置。 let s = 'Hello world!'; s.startsWith('world', 6) // true s.endsWith('Hello', 5) // true s.includes('Hello', 6) // false 使用第二个参数n时 endsWith针对前n个字符 startsWith针对从第n个位置直到字符串结束。 includes针对从第n个位置直到字符串结束。 2. repeat() repeat方法返回一个新字符串，表示将原字符串重复n次。 'x'.repeat(3) // \"xxx\" 'hello'.repeat(2) // \"hellohello\" 'na'.repeat(0) // \"\" 参数如果是小数，会被向下取整。 'na'.repeat(2.9) // \"nana\" 如果repeat的参数是负数或者Infinity，会报错。 'na'.repeat(Infinity) // RangeError 'na'.repeat(-1) // RangeError 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。 'na'.repeat(-0.9) // \"\" 参数NaN等同于 0。 'na'.repeat(NaN) // \"\" 如果repeat的参数是字符串，则会返回空字符串。 'na'.repeat('sdg') // \"\" 3. padStart(), padEnd() ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 'x'.padStart(5, 'ab') // 'ababx' 'x'.padStart(4, 'ab') // 'abax' 'x'.padEnd(5, 'ab') // 'xabab' 'x'.padEnd(4, 'ab') // 'xaba' padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。 'xxx'.padStart(2, 'ab') // 'xxx' 'xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。 'abc'.padStart(10, '0123456789') // '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 'x'.padStart(4) // ' x' 'x'.padEnd(4) // 'x ' padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 '1'.padStart(10, '0') // \"0000000001\" '12'.padStart(10, '0') // \"0000000012\" 另一个用途是提示字符串格式。 '12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\" '09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\" 4. trimStart(), trimEnd() ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。 const s = ' abc '; s.trim() // \"abc\" s.trimStart() // \"abc \" s.trimEnd() // \" abc\" 除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-25 23:51 "},"RegExp-extend.html":{"url":"RegExp-extend.html","title":"正则的扩展","keywords":"","body":"正则的扩展 1. RegExp 构造函数 * 在 ES5 中，RegExp构造函数的参数有两种情况。 第一种情况是，第一个参数是字符串，第二个参数是正则表达式的修饰符（flag）。 var regex = new RegExp('xyz', 'i'); // 等价于 var regex = /xyz/i; 第二种情况是，只有一个参数，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 var regex = new RegExp(/xyz/i); // 等价于 var regex = /xyz/i; 但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。 var regex = new RegExp(/xyz/, 'i'); // Uncaught TypeError: Cannot supply flags when constructing one RegExp from another 在ES6中，第一个参数是正则表示式，第二个参数可以使用修饰符（flag），返回的正则表达式会忽略原有的修饰符，使用第二个参数给的修饰符 new RegExp(/abc/ig, 'i').flags // \"i\" 2. 字符串的正则表达式 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] 3. RegExp.prototype.flags 属性 ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 // ES5 的 source 属性 // 返回正则表达式的正文 /abc/ig.source // \"abc\" // ES6 的 flags 属性 // 返回正则表达式的修饰符 /abc/sigu.flags // 'gi' 4. 具名组匹配 * 正则表达式使用圆括号进行组匹配。使用exec方法，就可以将这三组匹配结果提取出来。 const RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/; const matchObj = RE_DATE.exec('1999-12-31'); const year = matchObj[1]; // 1999 const month = matchObj[2]; // 12 const day = matchObj[3]; // 31 组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。 ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。同时，数字序号（matchObj[1]）依然有效。 const RE_DATE = /(?\\d{4})-(?\\d{2})-(?\\d{2})/; const matchObj = RE_DATE.exec('1999-12-31'); const year = matchObj.groups.year; // 1999 const month = matchObj.groups.month; // 12 const day = matchObj.groups.day; // 31 如果具名组没有匹配，那么对应的groups对象属性会是undefined。 const RE_OPT_A = /^(?a+)?$/; const matchObj = RE_OPT_A.exec(''); matchObj.groups.as // undefined 'as' in matchObj.groups // true 5. 解构赋值和替换 * 有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。 let {groups: {one, two}} = /^(?.*):(?.*)$/u.exec('foo:bar'); one // foo two // bar 字符串替换时，使用$引用具名组。 let re = /(?\\d{4})-(?\\d{2})-(?\\d{2})/u; '2015-01-02'.replace(re, '$/$/$') // '02/01/2015' 上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。 replace方法的第二个参数也可以是函数，该函数的参数序列如下。 '2015-01-02'.replace(re, ( matched, // 整个匹配结果 2015-01-02 capture1, // 第一个组匹配 2015 capture2, // 第二个组匹配 01 capture3, // 第三个组匹配 02 position, // 匹配开始的位置 0 S, // 原字符串 2015-01-02 groups // 具名组构成的一个对象 {year, month, day} ) => { let {day, month, year} = groups; return `${day}/${month}/${year}`; }); 6. 引用 如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k的写法。 const RE_TWICE = /^(?[a-z]+)!\\k$/; RE_TWICE.test('abc!abc') // true RE_TWICE.test('abc!ab') // false 数字引用（\\1）依然有效。 const RE_TWICE = /^(?[a-z]+)!\\1$/; RE_TWICE.test('abc!abc') // true RE_TWICE.test('abc!ab') // false 这两种引用语法还可以同时使用。 const RE_TWICE = /^(?[a-z]+)!\\k!\\1$/; RE_TWICE.test('abc!abc!abc') // true RE_TWICE.test('abc!abc!ab') // false 7. String.prototype.matchAll() * ES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 const string = 'test1test2test3'; // g 修饰符加不加都可以 const regex = /t(e)(st(\\d?))/g; for (const match of string.matchAll(regex)) { console.log(match); } // [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"] // [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"] // [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"] 上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for...of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。 遍历器转为数组是非常简单的，使用...运算符和Array.from()方法就可以了。 // 转为数组方法一 [...string.matchAll(regex)] // 转为数组方法二 Array.from(string.matchAll(regex)) Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-25 23:45 "},"number-extend.html":{"url":"number-extend.html","title":"数值的扩展","keywords":"","body":"数值的扩展 1. 二进制和八进制的写法 ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 0b111110111 === 503 // true 0o767 === 503 // true 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 Number('0b111') // 7 Number('0o10') // 8 2. Number.isFinite(), Number.isNaN() * Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。 如果参数类型不是数值，Number.isFinite一律返回false。 Number.isFinite(15); // true Number.isFinite(0.8); // true Number.isFinite(NaN); // false Number.isFinite(Infinity); // false Number.isFinite(-Infinity); // false Number.isFinite('foo'); // false Number.isFinite('15'); // false Number.isFinite(true); // false Number.isNaN()用来检查一个值是否为NaN。 如果参数类型不是NaN，Number.isNaN()一律返回false。 Number.isNaN(NaN) // true Number.isNaN(15) // false Number.isNaN('15') // false Number.isNaN(true) // false Number.isNaN(9/NaN) // true Number.isNaN('true' / 0) // true Number.isNaN('true' / 'true') // true 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 isFinite(25) // true isFinite(\"25\") // true Number.isFinite(25) // true Number.isFinite(\"25\") // false isNaN(NaN) // true isNaN(\"NaN\") // true Number.isNaN(NaN) // true Number.isNaN(\"NaN\") // false 3. Number.parseInt(), Number,parseFloat() * // ES5的写法 parseInt('12.34') // 12 parseFloat('123.45#') // 123.45 // ES6的写法 Number.parseInt('12.34') // 12 Number.parseFloat('123.45#') // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 Number.parseInt === parseInt // true Number.parseFloat === parseFloat // true 4. Number.isInterger() * Number.isInteger()用来判断一个数值是否为整数。 Number.isInteger(25) // true Number.isInteger(25.1) // false JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。 Number.isInteger(25) // true Number.isInteger(25.0) // true 如果参数不是数值，Number.isInteger返回false。 Number.isInteger() // false Number.isInteger(null) // false Number.isInteger('15') // false Number.isInteger(true) // false 注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。 Number.isInteger(3.0000000000000002) // true 5. Number.EPSILON * ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。 对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。 Number.EPSILON === Math.pow(2, -52) // true Number.EPSILON // 2.220446049250313e-16 Number.EPSILON.toFixed(20) // \"0.00000000000000022204\" Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。 0.1 + 0.2 // 0.30000000000000004 0.1 + 0.2 - 0.3 // 5.551115123125783e-17 5.551115123125783e-17.toFixed(20) // '0.00000000000000005551' 上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。 0.1 + 0.2 === 0.3 // false Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。 5.551115123125783e-17 因此，Number.EPSILON的实质是一个可以接受的最小误差范围。 function withinErrorMargin (left, right) { return Math.abs(left - right) 上面的代码为浮点数运算，部署了一个误差检查函数。 6. Math.trunc() * Math.trunc方法用于去除一个数的小数部分，返回整数部分。 Math.trunc(4.1) // 4 Math.trunc(4.9) // 4 Math.trunc(-4.1) // -4 Math.trunc(-4.9) // -4 Math.trunc(-0.1234) // -0 对于非数值，Math.trunc内部使用Number方法将其先转为数值。 Math.trunc('123.456') // 123 Math.trunc(true) //1 Math.trunc(false) // 0 Math.trunc(null) // 0 对于空值和无法截取整数的值，返回NaN。 Math.trunc(NaN); // NaN Math.trunc('foo'); // NaN Math.trunc('1w'); // NaN Math.trunc(); // NaN Math.trunc(undefined) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 Math.trunc = Math.trunc || function(x) { return x 7. Math.sign() Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 它会返回五种值。 参数为正数，返回+1； 参数为负数，返回-1； 参数为 0，返回0； 参数为-0，返回-0; 其他数值，返回NaN。 如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。 Math.sign('') // 0 Math.sign(true) // +1 Math.sign(false) // 0 Math.sign(null) // 0 Math.sign('9') // +1 Math.sign('foo') // NaN Math.sign() // NaN Math.sign(undefined) // NaN 8. Math.cbrt() Math.cbrt方法用于计算一个数的立方根。 Math.cbrt(-1) // -1 Math.cbrt(0) // 0 Math.cbrt(1) // 1 Math.cbrt(2) // 1.2599210498948734 对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。 Math.cbrt('8') // 2 Math.cbrt('hello') // NaN 9. Math.hypot() Math.hypot方法返回所有参数的平方和的平方根。 如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。 Math.hypot(3, 4); // 5 Math.hypot(3, 4, 5); // 7.0710678118654755 Math.hypot(); // 0 Math.hypot(NaN); // NaN Math.hypot(3, 4, 'foo'); // NaN Math.hypot(3, 4, '5'); // 7.0710678118654755 Math.hypot(-3); // 3 10. 指数运算符 ** ES2016 新增了一个指数运算符（**）。 2 ** 2 // 4 2 ** 3 // 8 这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。 // 相当于 2 ** (3 ** 2) 2 ** 3 ** 2 // 512 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。 let a = 1.5; a **= 2; // 等同于 a = a * a; let b = 4; b **= 3; // 等同于 b = b * b * b; Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-26 23:57 "},"function-extend.html":{"url":"function-extend.html","title":"函数的扩展","keywords":"","body":"函数的扩展 1. 函数参数的默认值 * 1）基本用法 ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 function log(x, y) { y = y || 'World'; console.log(x, y); } log('Hello') // Hello World log('Hello', 'China') // Hello China log('Hello', '') // Hello World 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。 if (typeof y === 'undefined') { y = 'World'; } ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 function log(x, y = 'World') { console.log(x, y); } log('Hello') // Hello World log('Hello', 'China') // Hello China log('Hello', '') // Hello 参数变量是默认声明的，所以不能用let或const再次声明。 function foo(x = 5) { let x = 1; // error } 2）与结构赋值默认值的结合使用 参数默认值可以与解构赋值的默认值，结合起来使用。 function foo({x, y = 5}) { console.log(x, y); } foo({}) // undefined 5 foo({x: 1}) // 1 5 foo({x: 1, y: 2}) // 1 2 foo() // TypeError: Cannot read property 'x' of undefined function fetch(url, { body = '', method = 'GET', headers = {} } = {}) { console.log(method); } fetch('http://example.com') // \"GET\" 上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET 请问下面两种写法有什么差别？ // 写法一 function m1({x = 0, y = 0} = {}) { return [x, y]; } // 写法二 function m2({x, y} = { x: 0, y: 0 }) { return [x, y]; } 上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。 // 函数没有参数的情况 m1() // [0, 0] m2() // [0, 0] // x 和 y 都有值的情况 m1({x: 3, y: 8}) // [3, 8] m2({x: 3, y: 8}) // [3, 8] // x 有值，y 无值的情况 m1({x: 3}) // [3, 0] m2({x: 3}) // [3, undefined] // x 和 y 都无值的情况 m1({}) // [0, 0]; m2({}) // [undefined, undefined] m1({z: 3}) // [0, 0] m2({z: 3}) // [undefined, undefined] 3）参数默认值的位置 通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 // 例一 function f(x = 1, y) { return [x, y]; } f() // [1, undefined] f(2) // [2, undefined]) f(, 1) // 报错 f(undefined, 1) // [1, 1] // 例二 function f(x, y = 5, z) { return [x, y, z]; } f() // [undefined, 5, undefined] f(1) // [1, 5, undefined] f(1, ,2) // 报错 f(1, undefined, 2) // [1, 5, 2] 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 function foo(x = 5, y = 6) { console.log(x, y); } foo(undefined, null) // 5 null 4）函数的length属性 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数 (function (a) {}).length // 1 (function (a = 5) {}).length // 0 (function (a, b, c = 5) {}).length // 2 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。 (function(...args) {}).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 (function (a = 0, b, c) {}).length // 0 (function (a, b = 1, c) {}).length // 1 5）作用域 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 var x = 1; function f(x, y = x) { console.log(y); } f(2) // 2 上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。 let x = 1; function f(y = x) { let x = 2; console.log(y); } f() // 1 上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。 如果此时，全局变量x不存在，就会报错。 function f(y = x) { let x = 2; console.log(y); } f() // ReferenceError: x is not defined 上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。 如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。 let foo = 'outer'; function bar(func = () => foo) { let foo = 'inner'; console.log(func()); } bar(); // outer 6）应用 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 function throwIfMissing() { throw new Error('Missing parameter'); } function foo(mustBeProvided = throwIfMissing()) { return mustBeProvided; } foo() // Error: Missing parameter 也可以将参数默认值设为undefined，表明这个参数是可以省略的。 function foo(optional = undefined) { ··· } 2. reset 参数 ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 function add(...values) { let sum = 0; for (var val of values) { sum += val; } return sum; } add(2, 5, 3) // 10 上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。 下面是一个 rest 参数代替arguments变量的例子。 // arguments变量的写法 function sortNumbers() { return Array.prototype.slice.call(arguments).sort(); } // rest参数的写法 const sortNumbers = (...numbers) => numbers.sort(); arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组 下面是一个利用 rest 参数改写数组push方法的例子。 function push(array, ...items) { items.forEach(function(item) { array.push(item); console.log(item); }); } var a = []; push(a, 1, 2, 3) 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 // 报错 function f(a, ...b, c) { // ... } 函数的length属性，不包括 rest 参数。 (function(a) {}).length // 1 (function(...a) {}).length // 0 (function(a, ...b) {}).length // 1 3. 严格模式 从 ES5 开始，函数内部可以设定为严格模式。 function doSomething(a, b) { 'use strict'; // code } ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 // 报错 function doSomething(a, b = a) { 'use strict'; // code } // 报错 const doSomething = function ({a, b}) { 'use strict'; // code }; // 报错 const doSomething = (...a) => { 'use strict'; // code }; const obj = { // 报错 doSomething({a, b}) { 'use strict'; // code } }; 两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。 'use strict'; function doSomething(a, b = a) { // code } 第二种是把函数包在一个无参数的立即执行函数里面。 const doSomething = (function () { 'use strict'; return function(value = 42) { return value; }; }()); 4. name属性 函数的name属性，返回该函数的函数名。 function foo() {} foo.name // \"foo\" Function构造函数返回的函数实例，name属性的值为anonymous。 (new Function).name // \"anonymous\" 5. 箭头函数 * 1）基本用法 var f = v => v; // 等同于 var f = function (v) { return v; }; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 var f = () => 5; // 等同于 var f = function () { return 5 }; var sum = (num1, num2) => num1 + num2; // 等同于 var sum = function(num1, num2) { return num1 + num2; }; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 var sum = (num1, num2) => { if(true){ return num1 + num2; } } 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 // 报错 let getTempItem = id => { id: id, name: \"Temp\" }; // 不报错 let getTempItem = id => ({ id: id, name: \"Temp\" }); 如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。 let fn = () => void doesNotReturn(); 箭头函数可以与变量解构结合使用。 const full = ({ first, last }) => first + ' ' + last; 箭头函数使得表达更加简洁。 const isEven = n => n % 2 === 0; const square = n => n * n; 箭头函数的一个用处是简化回调函数。 // 正常函数写法 [1,2,3].map(function (x) { return x * x; }); // 箭头函数写法 [1,2,3].map(x => x * x); // 正常函数写法 var result = values.sort(function (a, b) { return a - b; }); // 箭头函数写法 var result = values.sort((a, b) => a - b); 下面是 rest 参数与箭头函数结合的例子。 const numbers = (...nums) => nums; numbers(1, 2, 3, 4, 5) // [1,2,3,4,5] const headAndTail = (head, ...tail) => [head, tail]; headAndTail(1, 2, 3, 4, 5) // [1,[2,3,4,5]] 2）使用注意点 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-26 23:57 "}}