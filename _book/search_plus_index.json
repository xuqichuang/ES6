{"./":{"url":"./","title":"简介","keywords":"","body":"ES6 基础入门 以下内容多节选自 阮一峰 的 ES6 博客，本人摘抄了他的精髓，记录成册，与君共享 1. ECMAScript 和 JavaScript 的关系是 ​ 前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。 2. ES6 与 ECMAScript2015 的关系 ​ 2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。 ​ 但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。 ​ 但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。 ​ 标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。 ​ ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。 ​ 因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。 3. 查看 Node.js 默认没有打开的 ES6 实验性语法 // Linux & Mac $ node --v8-options | grep harmony // Windows $ node --v8-options | findstr harmony 4. Babel 转码器 Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。 // 转码前 input.map(item => item + 1); // 转码后 input.map(function (item) { return item + 1; }); 上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。 下面的命令在项目目录中，安装 Babel。 $ npm install --save-dev @babel/core 1. 配置文件 .babelrc Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。 该文件用来设置转码规则和插件，基本格式如下。 presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。 # 最新转码规则 $ npm install --save-dev @babel/preset-env # react 转码规则 $ npm install --save-dev @babel/preset-react 然后，将这些规则加入.babelrc。 { \"presets\": [ \"@babel/env\", \"@babel/preset-react\" ], \"plugins\": [] } 注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。 2. 命令行转码 Babel 提供命令行工具@babel/cli，用于命令行转码。 安装模块 $ npm install --save-dev @babel/cli 基本用法如下： # 转码结果输出到标准输出 $ npx babel example.js # 转码结果写入一个文件 # --out-file 或 -o 参数指定输出文件 $ npx babel example.js --out-file compiled.js # 或者 $ npx babel example.js -o compiled.js # 整个目录转码 # --out-dir 或 -d 参数指定输出目录 $ npx babel src --out-dir lib # 或者 $ npx babel src -d lib # -s 参数生成source map文件 $ npx babel src -d lib -s 3. babel-node @babel/node模块的babel-node命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。 安装模块 $ npm install --save-dev @babel/node 然后，执行babel-node就进入 REPL 环境。 $ npx babel-node > (x => x * 2)(1) 2 babel-node命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。 # es6.js 的代码 # console.log((x => x * 2)(1)); $ npx babel-node es6.js 2 4. babel/register 模块 @babel/register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 Babel 进行转码。 $ npm install --save-dev @babel/register 使用时，必须首先加载@babel/register。 // index.js require('@babel/register'); require('./es6.js') 然后，就不需要手动对index.js转码了。 $ node index.js 2 需要注意的是，@babel/register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。 5. babel API 如果某些代码需要调用 Babel 的 API 进行转码，就要使用@babel/core模块。 // 字符串转码 babel.transform('code();', options); // => { code, map, ast } // 文件转码（异步） babel.transformFile('filename.js', options, function(err, result) { result; // => { code, map, ast } }); // 文件转码（同步） babel.transformFileSync('filename.js', options); // => { code, map, ast } // Babel AST转码 babel.transformFromAst(ast, code, options); // => { code, map, ast } 配置对象options，可以参看官方文档http://babeljs.io/docs/usage/options/。 下面是一个例子。 var es6Code = 'let x = n => n + 1'; var es5Code = require('@babel/core') .transform(es6Code, { presets: ['@babel/env'] }) .code; console.log(es5Code); // '\"use strict\";\\n\\nvar x = function x(n) {\\n return n + 1;\\n};' 上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的 ES6 代码，第二个参数是转换的配置对象。 6. babel/polyfill Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。 安装命令如下: $ npm install --save-dev @babel/polyfill 然后，在脚本头部，加入如下一行代码。 import '@babel/polyfill'; // 或者 require('@babel/polyfill'); Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的definitions.js文件。 7. 浏览器环境 Babel 也可以用于浏览器环境，使用@babel/standalone模块提供的浏览器版本，将其插入网页。 // Your ES6 code 注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。 Babel 提供一个REPL 在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-24 23:53 "},"let-const.html":{"url":"let-const.html","title":"let 和 const 命令","keywords":"","body":"let 和 const 命令 1. let 命令 1.）基本用法 * ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 { let a = 10; var b = 1; } a // ReferenceError: a is not defined. b // 1 for循环的计数器，就很合适使用let命令。 for (let i = 0; i 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 var a = []; for (var i = 0; i 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。 var a = []; for (let i = 0; i 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 for (let i = 0; i 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 2）不存在变量提升 * var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; 3）暂时性死区 * 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 if (true) { // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123 } 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 typeof x; // ReferenceError let x; 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 typeof undeclared_variable // \"undefined\" 有些“死区”比较隐蔽，不太容易发现。 function bar(x = y, y = 2) { return [x, y]; } bar(); // 报错 Uncaught ReferenceError: Cannot access 'y' before initialization 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。 function bar(x = 2, y = x) { return [x, y]; } bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。 // 不报错 var x = x; // 报错 let x = x; // ReferenceError: x is not defined ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 4）不允许重复声明 * let不允许在相同作用域内，重复声明同一个变量。 // 报错 function func() { let a = 10; var a = 1; } // 报错 function func() { let a = 10; let a = 1; } 不能在函数内部重新声明参数。 function func(arg) { let arg; } func() // 报错 function func(arg) { { let arg; } } func() // 不报错 2. 块级作用域 1）为什么需要块级作用域 * ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 内层变量可能会覆盖外层变量。 var tmp = 'hello'; function f() { console.log(tmp); if (false) { var tmp = 'world'; } } f(); // undefined 用来计数的循环变量泄露为全局变量。 var tmp = 'hello'; for (var i = 0; i 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。 { {let insane = 'Hello World'} console.log(insane); // 报错 }; 内层作用域可以定义外层作用域的同名变量。 { let insane = 'Hello'; {let insane = 'World'} }; 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。 // IIFE 写法 (function () { var tmp = ...; ... }()); // 块级作用域写法 { let tmp = ...; ... } 2）块级作用域与函数声明 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 // 情况一 if (true) { function f() {} } // 情况二 try { function f() {} } catch(e) { // ... } 上面两种函数声明，根据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 function f() { console.log('I am outside!'); } (function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f(); }()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。 // ES5 环境 function f() { console.log('I am outside!'); } (function () { function f() { console.log('I am inside!'); } if (false) { } f(); }()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ // 浏览器的 ES6 环境 function f() { console.log('I am outside!'); } (function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f(); }()); // Uncaught TypeError: f is not a function ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。上面的例子实际运行的代码如下。 // 浏览器的 ES6 环境 function f() { console.log('I am outside!'); } (function () { var f = undefined; if (false) { function f() { console.log('I am inside!'); } } f(); }()); // Uncaught TypeError: f is not a function 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 // 块级作用域内部的函数声明语句，建议不要使用 { let a = 'secret'; function f() { return a; } } // 块级作用域内部，优先使用函数表达式 { let a = 'secret'; let f = function () { return a; }; } 另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。 // 第一种写法，报错 if (true) let x = 1; // 第二种写法，不报错 if (true) { let x = 1; } 函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。 // 不报错 'use strict'; if (true) { function f() {} } // 报错 'use strict'; if (true) function f() {} 3. const 命令 1）基本用法 * const声明一个只读的常量。一旦声明，常量的值就不能改变。 const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. const一旦声明变量，就必须立即初始化，不能留到以后赋值。只声明不赋值，就会报错。 const foo; // SyntaxError: Missing initializer in const declaration 除了不可改变值，其他用法和let相似 3）本质 * const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 const foo = {}; // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop // 123 // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: \"foo\" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 const a = []; a.push('Hello'); // 可执行 a.length = 0; // 可执行 a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果真的想将对象冻结，应该使用Object.freeze方法。 const foo = Object.freeze({}); // 常规模式时，下面一行不起作用； // 严格模式时，该行会报错 foo.prop = 123; 将对象彻底冻结的函数。 var constantize = (obj) => { Object.freeze(obj); Object.keys(obj).forEach( (key, i) => { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } }); }; 4. 顶层对象的属性 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 window.a = 1; a // 1 a = 2; window.a // 2 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题： 没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）。 程序员很容易不知不觉地就创建了全局变量（比如打字出错）。 顶层对象的属性是到处可以读写的，这非常不利于模块化编程。 window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性。 另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。 var a = 1; // 如果在 Node 的 REPL 环境，可以写成 global.a // 或者采用通用方法，写成 this.a window.a // 1 let b = 1; window.b // undefined 5. globalThis对象 * JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。 ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-25 00:15 "},"destructuring-assignment.html":{"url":"destructuring-assignment.html","title":"变量的解构赋值","keywords":"","body":"变量的解构赋值 重要知识点 ： 1. 交换变量的值 * let [x,y] = [1,2] [x,y] = [y,x] 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 2. 从函数返回多个值 * 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 // 返回一个数组,数组中取出多个对象 function example() { return [1, 2, 3]; } let [a, b, c] = example(); // 返回一个对象,对象中取出多个对象 function example() { return { foo: 1, bar: 2 }; } let { foo, bar } = example(); 3. 函数参数的定义 * 解构赋值可以方便地将一组参数与变量名对应起来。 // 参数是一组有次序的值 function f([x, y, z]) { ... } f([1, 2, 3]); // 参数是一组无次序的值 function f({x, y, z}) { ... } f({z: 3, y: 2, x: 1}); 4. 提取 JSON 数据 * 可以快速提取 JSON 数据的值。 let jsonData = { id: 42, status: \"OK\", data: [867, 5309] }; let { id, status, data: number } = jsonData; console.log(id, status, number); // 42, \"OK\", [867, 5309] 5. 函数参数的默认值 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。 const fn = function({x='hello',y='world'}={}){ ... } 6. 遍历 Map 结构 * 任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 const map = new Map(); map.set('first', 'hello'); map.set('second', 'world'); for (let [key, value] of map) { console.log(key + \" is \" + value); } // first is hello // second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 // 获取键名 for (let [key] of map) { // ... } // 获取键值 for (let [,value] of map) { // ... } 7. 引入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 const { SourceMapConsumer, SourceNode } = require(\"source-map\"); Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-24 23:53 "},"string-extend.html":{"url":"string-extend.html","title":"字符串的拓展","keywords":"","body":"字符串的拓展 1. 字符串的遍历接口 for (let codePoint of 'foo') { console.log(codePoint) } // \"f\" // \"o\" // \"o\" 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 let text = String.fromCodePoint(0x20BB7); for (let i = 0; i 2. 直接输入 U+2028 和 U+2029 JavaScript 字符串允许直接输入字符，以及输入字符的转义形式（Unicode编码） JavaScript 规定有3个字符，不能在字符串里面直接使用，只能使用转义形式。 U+005C：反斜杠（reverse solidus) U+000D：回车（carriage return） U+000A：换行符（line feed） 3. 模板字符串 * 传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。 $('#result').append( 'There are ' + basket.count + ' ' + 'items in your basket, ' + '' + basket.onSale + ' are on sale!' ); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 $('#result').append(` There are ${basket.count} items in your basket, ${basket.onSale} are on sale! `); 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 let greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 $('#list').html(` first second `); 模板字符串中嵌入变量，需要将变量名写在${}之中。 `User ${user.name} is not authorized to do ${action}.` 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 let x = 1; let y = 2; `${x} + ${y} = ${x + y}` // \"1 + 2 = 3\" `${x} + ${y * 2} = ${x + y * 2}` // \"1 + 4 = 5\" let obj = {x: 1, y: 2}; `${obj.x + obj.y}` // \"3\" 模板字符串之中还能调用函数。 function fn() { return \"Hello World\"; } `foo ${fn()} bar` // foo Hello World bar 模板字符串甚至还能嵌套。 const tmpl = addrs => ` ${addrs.map(addr => ` ${addr.first} ${addr.last} `).join('')} `; 4. 标签模板 它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 alert`hello` // 等同于 alert(['hello']) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 let a = 5; let b = 10; tag`Hello ${ a + b } world ${ a * b }`; // 等同于 tag(['Hello ', ' world ', ''], 15, 50); “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 let message = SaferHTML`${sender} has sent you a message.`; function SaferHTML(templateData) { let s = templateData[0]; for (let i = 1; i /g, \"&gt;\"); // Don't escape special characters in the template. s += templateData[i]; } return s; } 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 let sender = 'alert(\"abc\")'; // 恶意代码 let message = SaferHTML`${sender} has sent you a message.`; message // &lt;script&gt;alert(\"abc\")&lt;/script&gt; has sent you a message. 标签模板的另一个应用，就是多语言转换（国际化处理）。 i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!` // \"欢迎访问xxx，您是第xxxx位访问者！\" Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-24 23:53 "}}